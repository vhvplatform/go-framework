Thiết kế CSDL:
Chào bạn, đây là bản "Cheat Sheet" (Tài liệu tổng hợp) toàn bộ quy tắc thiết kế hệ thống SaaS B2B quy mô lớn mà chúng ta đã thảo luận.
Bạn có thể lưu lại bản này để làm kim chỉ nam (Guideline) cho đội ngũ phát triển (Dev Team).
PHẦN 1: KIẾN TRÚC & PHÂN LOẠI DỮ LIỆU (Architecture)
Triết lý: "Polyglot Persistence" (Dùng đúng công cụ cho đúng việc).
Loại dữ liệu Database khuyên dùng Ví dụ điển hình
Dữ liệu Động / Unstructured MongoDB Cấu hình Tenant (tenant_app_configs), Catalog sản phẩm động.
Dữ liệu Quan hệ / ACID YugabyteDB (Postgres) User, Billing, Subscription, Banking Transaction.
Dữ liệu Lớn / Analytics ClickHouse Audit Logs, Access Logs, Report thống kê.
Dữ liệu Cache / Queue Redis / Kafka Rate Limiting, User Session / CDC, Event Bus.
PHẦN 2: QUY CHUẨN KIỂU DỮ LIỆU (Data Types Standard)
Quy tắc vàng: Sự chính xác và minh bạch ưu tiên hơn dung lượng lưu trữ.
1. Định danh (Primary Key)
Quy tắc: Dùng String (UUID) hoặc ObjectId (convert sang String).
Tên trường: Thống nhất đặt là _id ở cả 3 loại DB để dễ map và sync dữ liệu.
2. Tiền tệ (Money) - ⛔ TUYỆT ĐỐI KHÔNG DÙNG FLOAT/DOUBLE
MongoDB: Decimal128.
YugabyteDB: NUMERIC(19, 4) (19 số, 4 số lẻ).
ClickHouse: Decimal128(4).
Cấu trúc: Luôn lưu kèm mã tiền tệ (Ví dụ: { amount: 100, currency: "USD" }).
3. Thời gian (DateTime)
Thời điểm (Timestamp): Luôn lưu UTC.
Mongo: Date (ISODate).
Yuga: TIMESTAMPTZ.
ClickHouse: DateTime64(3).
Ngày sinh/Ngày lễ: Không quan tâm giờ.
Mongo: String ("YYYY-MM-DD").
Yuga: DATE.
ClickHouse: Date32 (Để hỗ trợ sinh trước năm 1970).
4. Trạng thái (Status/Boolean)
Bật/Tắt: Dùng BOOL (true/false). Không dùng Int (0/1).
Liệt kê (Enum):
Mongo/Yuga: Dùng String ("ACTIVE", "PENDING") để dễ đọc.
ClickHouse: Dùng Enum8 hoặc Enum16 để tối ưu hiệu năng.
5. File/Ảnh
Quy tắc: Lưu trên Object Storage (S3/MinIO). Trong DB chỉ lưu URL (String).
PHẦN 3: NGHIỆP VỤ SAAS (Business Logic Design)
1. Phân biệt Configs vs. Features
Features (Trong Gói dịch vụ): Quy định quyền lợi ("Được làm gì?", "Được bao nhiêu?").
Ví dụ: max_users: 10, allow_export_excel: true.
Nơi lưu: service_packages & snapshot vào tenant_subscriptions.
Configs (Trong Tenant App): Quy định sở thích vận hành ("Làm như thế nào?").
Ví dụ: theme_color, workflow_steps.
Nơi lưu: tenant_app_configs.
2. Chiến lược Billing (Tính tiền)
Snapshot: Khi Tenant mua gói, phải COPY toàn bộ giá và quyền lợi vào bảng tenant_subscriptions. Không tham chiếu ngược lại bảng giá gốc (để tránh lỗi khi giá gốc thay đổi).
Custom Price: Lưu giá gốc riêng, giá đã giảm riêng (price_adjustments) để minh bạch hóa đơn.
3. Phân quyền (RBAC)
Mô hình: User -> Tenant Member -> Groups -> Roles -> Permissions.
Hiệu năng: Tính toán sẵn danh sách quyền (Flattening) khi đăng nhập và cache lại (Redis/Session) để không phải join bảng mỗi lần gọi API.
PHẦN 4: TỔ CHỨC CODE (Implementation Pattern)
1. Kiến trúc code (Go/Java/Node)
Sử dụng Repository Pattern.
Tầng Service (Business Logic) chỉ giao tiếp qua Interface, không gọi trực tiếp driver DB.
Mục đích: Dễ dàng chuyển đổi giữa Mongo <-> Yugabyte mà không sửa logic nghiệp vụ.
2. Xử lý đồng bộ (Sync)
Dùng Kafka + Debezium (CDC) để đồng bộ dữ liệu từ MongoDB (Operational) sang ClickHouse (Analytical) và YugabyteDB (nếu cần).
Tránh việc Application phải ghi (Dual Write) vào 2 DB cùng lúc.
3. Thư viện (Go specific)
Enterprise/Long-term: Tự định nghĩa Interface, dùng driver native (pgx, mongo-driver) để tối ưu sâu.
MVP/Startup: Có thể dùng GORM hoặc Upper.io để phát triển nhanh.
Hình ảnh về database architecture diagram
Getty Images
Lời khuyên cuối cùng: Hệ thống SaaS thành công là hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt". Việc bạn tuân thủ các quy tắc về kiểu dữ liệu (Decimal, Date32, UUID) ngay từ ngày đầu tiên sẽ cứu bạn khỏi hàng ngàn giờ fix bug đau đầu sau này khi hệ thống có hàng triệu User.
làm kỹ hơn PHẦN 1: KIẾN TRÚC & PHÂN LOẠI DỮ LIỆU
Chào bạn, để xây dựng một hệ thống SaaS "cường tráng", việc phân loại dữ liệu không chỉ đơn thuần là "dữ liệu nào bỏ vào đâu", mà là hiểu rõ đặc tính truy cập (Access Patterns) và vòng đời dữ liệu (Data Lifecycle).
Dưới đây là bản thiết kế chi tiết sâu (Deep Dive) cho phần Kiến trúc & Phân loại dữ liệu theo mô hình Polyglot Persistence (Đa lưu trữ bền vững).
TỔNG QUAN KIẾN TRÚC: "THE RIGHT TOOL FOR THE RIGHT JOB"
Chúng ta sẽ chia hệ thống thành 4 tầng dữ liệu (Data Tiers) dựa trên tính chất vật lý và nghiệp vụ.
1. Tier 1: Document Store (MongoDB) - "Bộ não linh hoạt"
Nơi lưu trữ các dữ liệu mang tính chất cấu trúc lồng nhau, thay đổi thường xuyên và phụ thuộc vào ngữ cảnh của Tenant.
Vai trò: Operational Database (CSDL Vận hành) - Hot Data.
Loại dữ liệu cụ thể:
Tenant Configurations: Cấu hình động của từng khách hàng (JSON tùy ý).
Product/Catalog: Danh mục sản phẩm (vì mỗi Tenant có thể có các thuộc tính sản phẩm khác nhau).
Workflow Definitions: Các quy trình duyệt động (User A -> User B -> User C).
Form Submissions: Dữ liệu người dùng nhập vào các form động.
Tại sao chọn MongoDB?
Schema Flexibility: Tenant A muốn thêm trường "Số CMND" vào form nhân viên, Tenant B thì không. MongoDB xử lý việc này tự nhiên mà không cần ALTER TABLE (điều gây lock bảng ở SQL).
Document Model: Dữ liệu cấu hình thường được lấy ra trọn gói (Get whole object). Lưu JSON giúp giảm thiểu việc JOIN nhiều bảng.
2. Tier 2: Distributed SQL (YugabyteDB) - "Két sắt an toàn"
Nơi lưu trữ dữ liệu quan hệ chặt chẽ, yêu cầu tính đúng đắn tuyệt đối (ACID) và khả năng mở rộng ngang (Horizontal Scaling).
Vai trò: Core Transactional Database (CSDL Giao dịch lõi) - Critical Data.
Loại dữ liệu cụ thể:
Identity & Access (IAM): Users, Passwords (Hash), Global Roles.
Billing & Subscriptions: Thông tin thẻ, hóa đơn, giao dịch thanh toán, số dư ví.
Relationships: Quan hệ giữa User - Tenant - Group (Mô hình graph/quan hệ phức tạp).
Inventory (Kho): Số lượng tồn kho (cần lock row để tránh bán quá số lượng).
Tại sao chọn YugabyteDB (PostgreSQL compatible)?
Strong Consistency: Đảm bảo khi User vừa thanh toán xong, số dư phải bị trừ ngay lập tức ở tất cả các node.
Distributed Transactions: Hỗ trợ giao dịch phân tán (Distributed ACID) mà MongoDB (trước v4) hoặc các NoSQL khác làm không tốt.
SQL Power: Các truy vấn báo cáo tài chính phức tạp (JOIN, GROUP BY, WINDOW FUNCTIONS) là sở trường của SQL.
3. Tier 3: OLAP / Columnar Store (ClickHouse) - "Bộ nhớ vĩnh cửu"
Nơi lưu trữ dữ liệu lịch sử, log, sự kiện với khối lượng khổng lồ, chỉ ghi thêm (Append-only) và ít khi sửa/xóa.
Vai trò: Analytical Database (CSDL Phân tích) - Cold/Warm Data.
Loại dữ liệu cụ thể:
Audit Logs: Ai làm gì, lúc nào? (Lưu hàng tỷ bản ghi).
System Logs/Events: API Latency, Error logs.
Usage Tracking: Đếm số lần gọi API, dung lượng sử dụng để tính tiền.
Business Reports: Thống kê doanh thu theo năm, xu hướng khách hàng.
Tại sao chọn ClickHouse?
Columnar Storage: Nén dữ liệu cực tốt (tỷ lệ 10:1). 1TB dữ liệu MongoDB/Postgres chuyển sang ClickHouse chỉ còn khoảng 100GB -> Tiết kiệm chi phí ổ cứng.
Aggregation Speed: Tính tổng doanh thu của 1 tỷ bản ghi chỉ mất vài mili-giây (MongoDB hay Postgres sẽ mất vài phút hoặc timeout).
4. Tier 4: Fast Data / Stream (Redis & Kafka) - "Hệ thần kinh"
Nơi trung chuyển dữ liệu và lưu trữ tạm thời.
Kafka: Đường ống dẫn dữ liệu (Data Pipeline). Dùng để đồng bộ dữ liệu từ Tier 1, 2 sang Tier 3 (CDC).
Redis: Bộ nhớ đệm (Cache). Lưu User Session, Rate Limiting counters, Feature Flags tạm thời.
CHIẾN LƯỢC DÒNG CHẢY DỮ LIỆU (DATA FLOW STRATEGY)
Để các CSDL này hoạt động nhịp nhàng, bạn cần thiết kế luồng đi của dữ liệu (Data Flow) theo mô hình CQRS (Tách biệt ghi và đọc) và CDC.
Kịch bản 1: User cấu hình hệ thống (Write Heavy Logic)
Action: Tenant vào Admin Portal sửa cấu hình "Workflow duyệt nghỉ phép".
Write: Backend ghi dữ liệu JSON vào MongoDB (tenant_app_configs).
Sync (Audit): Backend bắn một event "CONFIG_UPDATED" vào Kafka.
Archiving: Consumer đọc Kafka và ghi log vào ClickHouse (audit_logs) để sau này truy vết.
Kịch bản 2: User thanh toán gói cước (Transaction Heavy)
Action: Tenant thanh toán gia hạn gói Enterprise.
Write: Backend mở transaction trên YugabyteDB:
Trừ tiền trong bảng wallets.
Cập nhật bảng tenant_subscriptions.
Tạo bản ghi invoices.
Sync (Feature): Sau khi commit thành công, Backend bắn event cập nhật lại Cache trên Redis để User có quyền ngay lập tức.
Kịch bản 3: Xem báo cáo Dashboard (Read Heavy Analytics)
Action: CEO của Tenant muốn xem "Biểu đồ năng suất nhân viên trong 12 tháng qua".
Read: Backend KHÔNG query MongoDB hay YugabyteDB (vì sẽ làm chậm hệ thống đang chạy).
Read: Backend query ClickHouse. Dữ liệu ở đây đã được đồng bộ từ trước qua Kafka/CDC.
Result: Trả về kết quả cực nhanh mà không ảnh hưởng đến các thao tác thêm/sửa/xóa của nhân viên khác.
BẢNG TỔNG HỢP QUYẾT ĐỊNH (DECISION MATRIX)
Dưới đây là bảng giúp Developer của bạn quyết định đặt một tính năng mới vào đâu:
Đặc điểm dữ liệu Câu hỏi kiểm tra Database được chọn
Cấu trúc linh hoạt "Mỗi Tenant có cần trường khác nhau không? Có nested object sâu không?" MongoDB
Toàn vẹn dữ liệu "Nếu dữ liệu này bị sai/lệch (ví dụ số tiền), có ai bị đi tù hay mất tiền không?" YugabyteDB
Quan hệ phức tạp "Có cần JOIN quá 3 bảng để lấy dữ liệu không?" YugabyteDB
Dữ liệu lớn (Big Data) "Bảng này có thể vượt quá 100 triệu dòng trong 1 năm không?" ClickHouse
Truy vấn tổng hợp "Có cần tính SUM, AVG, COUNT trên tập dữ liệu lớn không?" ClickHouse
Bất biến (Immutable) "Dữ liệu này có bao giờ bị sửa (Update) không, hay chỉ ghi thêm (Insert)?" ClickHouse (nếu chỉ Insert)
LƯU Ý KỸ THUẬT QUAN TRỌNG
Đồng bộ dữ liệu (CDC - Change Data Capture):
Bạn không nên viết code Insert Mongo -> Insert ClickHouse (Dual Write). Rất dễ bị lỗi 1 bên thành công, 1 bên thất bại.
Giải pháp: Dùng Debezium. Nó sẽ lắng nghe OpLog của MongoDB và WAL của YugabyteDB, sau đó tự động đẩy thay đổi sang Kafka -> ClickHouse. Đảm bảo tính nhất quán cuối cùng (Eventual Consistency).
Joins giữa các DB (Cross-Database Join):
Sẽ có lúc bạn cần JOIN dữ liệu User (Yugabyte) với Log (ClickHouse).
Tuyệt đối không fetch hết về App để join.
Giải pháp:
Denormalization (Phi chuẩn hóa): Khi ghi Log vào ClickHouse, ghi luôn user_email, user_full_name vào đó (dù dữ liệu bị lặp). Disk rẻ hơn CPU.
ClickHouse Dictionary: ClickHouse có tính năng load bảng nhỏ từ Yugabyte/Mongo vào bộ nhớ (Dictionary) để join trực tiếp cực nhanh.
Việc thiết kế kỹ lưỡng phần này sẽ giúp hệ thống SaaS của bạn tránh được "cái bẫy Monolith" (một DB gánh tất cả) và sẵn sàng scale lên hàng triệu users.
làm kỹ hơn về quy tắc đặt tên, kiểu dữ liệu cho các trường
Chào bạn, để một hệ thống Polyglot (Đa cơ sở dữ liệu) vận hành trơn tru, việc có một bộ quy tắc đặt tên và định kiểu dữ liệu thống nhất (Consistent) là yếu tố sống còn. Nếu MongoDB đặt là userId (camelCase) còn YugabyteDB đặt là user_id (snake_case), đội Dev sẽ mất 50% thời gian chỉ để viết code mapping (chuyển đổi) vô nghĩa.
Dưới đây là bộ Quy chuẩn Kỹ thuật (Engineering Standard) chi tiết cho hệ thống SaaS của bạn.
PHẦN 1: QUY TẮC ĐẶT TÊN (NAMING CONVENTIONS)
Nguyên tắc cốt lõi:
Database: Sử dụng snake_case (chữ thường, gạch dưới) cho tất cả (Bảng, Cột, Index).
Lý do: YugabyteDB (Postgres) và ClickHouse không phân biệt hoa thường (case-insensitive) mặc định. Dùng camelCase sẽ phải bao quanh bằng dấu ngoặc kép " rất phiền phức và dễ lỗi.
API/Code: Sử dụng camelCase (theo chuẩn JSON/JavaScript/Go).
Mapping: Tầng Repository sẽ chịu trách nhiệm chuyển đổi snake_case <-> camelCase.
1. Tên Bảng / Collection
Quy tắc: Danh từ SỐ NHIỀU (Plural), snake_case.
Ví dụ:
✅ tenants, users, audit_logs, billing_invoices.
❌ tenant, User, auditLog, tbl_users.
2. Khóa chính (Primary Key)
Quy tắc: Thống nhất tên là _id trên toàn bộ hệ thống.
Kiểu: Chuỗi UUID (String).
Tại sao _id? Để tương thích native với MongoDB. Khi đẩy sang Yugabyte hay ClickHouse, vẫn giữ tên _id để các tool CDC (như Debezium) map tự động không cần config.
3. Khóa ngoại (Foreign Key)
Quy tắc: tên_thực_thể_số_ít + _id.
Ví dụ:
Trong bảng users: Liên kết đến tenant -> tenant_id.
Trong bảng orders: Liên kết đến người tạo -> created_by (Trường hợp đặc biệt chỉ người), hoặc user_id.
4. Trường Thời gian (Date/Time)
Phân biệt rõ hậu tố (Suffix) để biết độ chính xác:
_at: Thời điểm chính xác (Timestamp UTC). VD: created_at, expires_at, logged_in_at.
_date: Ngày tháng theo lịch (Date only). VD: birth_date, billing_start_date.
_duration: Khoảng thời gian (giây/ms). VD: processing_duration_ms.
5. Trường Boolean (Bật/Tắt)
Phải bắt đầu bằng động từ nghi vấn (Is, Has, Can) để code đọc lên như một câu văn.
Quy tắc: is_ + tính từ, has_ + danh từ, can_ + động từ.
Ví dụ:
✅ is_active, is_deleted, has_avatar, can_export.
❌ active (Không rõ là trạng thái hay hành động), status (Mơ hồ), flag.
6. Bảng trung gian (Junction Table - Many-to-Many)
Quy tắc: bảng_a + _ + bảng_b (Sắp xếp theo alpha).
Ví dụ: User thuộc nhiều Group -> Bảng groups_users (hoặc user_groups nếu muốn nhấn mạnh chiều nào chính).
PHẦN 2: QUY CHUẨN KIỂU DỮ LIỆU (DATA TYPES STANDARD)
Đây là bảng quy chiếu chi tiết (Mapping Matrix) để đảm bảo dữ liệu "chảy" mượt mà giữa 3 hệ quản trị.
Loại dữ liệu Tên trường mẫu MongoDB (BSON) YugabyteDB (Postgres) ClickHouse Ghi chú kỹ thuật
Định danh _id, tenant_id String (UUID) UUID (hoặc TEXT) UUID Nên gen UUID v7 (sắp xếp được theo thời gian) để index nhanh hơn.
Chuỗi ngắn full_name, email String VARCHAR(255) String Dùng UTF-8 Encoding.
Chuỗi dài description, bio String TEXT String ClickHouse nén chuỗi dài rất tốt.
Số nguyên view_count, age Int64 (Long) BIGINT Int64 Luôn dùng 64-bit để tránh tràn số (Overflow) về sau.
Số thập phân score, rating Double DOUBLE PRECISION Float64 Chỉ dùng cho dữ liệu khoa học, rating, không dùng cho tiền.
Tiền tệ price_amount Decimal128 NUMERIC(19, 4) Decimal128(4) Chính xác tuyệt đối 4 số sau dấu phẩy.
Boolean is_active Boolean BOOLEAN Bool
Thời điểm created_at Date (ISODate) TIMESTAMPTZ DateTime64(3) Yêu cầu chính xác đến mili-giây (3 số lẻ).
Ngày tháng birth_date String (ISO) DATE Date32 Format: "YYYY-MM-DD".
JSON/Config settings, metadata Object JSONB String ClickHouse lưu JSON dạng String, query bằng hàm JSONExtract.
Mảng/List tags, ip_list Array TEXT[] Array(String)
Enum status String VARCHAR(50) Enum8(...) Mongo/Yuga lưu String cho dễ đọc/mở rộng. ClickHouse dùng Enum để nén.
PHẦN 3: CÁC TRƯỜNG TIÊU CHUẨN (STANDARD MIXINS)
Mọi bảng (Table/Collection) trong hệ thống đều BẮT BUỘC phải có nhóm các trường sau đây để phục vụ quản trị và truy vết.
1. Nhóm định danh & Tenancy (Identity)
SQL
_id UUID PRIMARY KEY, -- Định danh bản ghi
tenant_id UUID NOT NULL -- Định danh khách hàng (Dùng để Sharding/Filtering)
Lưu ý: tenant_id phải được index ở hầu hết các bảng để đảm bảo performance khi query "Dữ liệu của công ty A".
2. Nhóm Audit (Truy vết)
SQL
created_at TIMESTAMPTZ DEFAULT NOW(),
updated_at TIMESTAMPTZ DEFAULT NOW(),
created_by UUID NULL, -- User ID người tạo
updated_by UUID NULL -- User ID người sửa cuối cùng
3. Nhóm Soft Delete (Xóa mềm)
Chúng ta không dùng DELETE FROM table. Chúng ta dùng "Xóa mềm" để có thể khôi phục khi User lỡ tay.
SQL
deleted_at TIMESTAMPTZ NULL, -- Nếu NULL: Chưa xóa. Nếu có giá trị: Đã xóa lúc...
deleted_by UUID NULL -- Ai xóa?
Logic Query: Luôn phải kèm điều kiện WHERE deleted_at IS NULL trong các câu SELECT mặc định.
4. Nhóm Versioning (Cho Optimistic Locking)
Để tránh việc 2 người cùng sửa 1 dòng dữ liệu và ghi đè nhau.
SQL
version INT DEFAULT 1
Logic Update: UPDATE table SET val = new, version = version + 1 WHERE id = x AND version = old_version. Nếu row affected = 0 nghĩa là đã có người khác sửa trước đó -> Báo lỗi cho User reload lại.
VÍ DỤ THỰC TẾ: THIẾT KẾ BẢNG products (Sản phẩm)
Dưới đây là cách áp dụng toàn bộ quy tắc trên vào một bảng cụ thể trong YugabyteDB:
SQL
CREATE TABLE products (
-- 1. Identity
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- 2. Business Data
code VARCHAR(50) NOT NULL, -- Mã sản phẩm
name VARCHAR(255) NOT NULL, -- Tên
description TEXT, -- Mô tả (dài)
-- 3. Money (Strict Rules)
price_amount NUMERIC(19, 4) DEFAULT 0,
price_currency VARCHAR(3) DEFAULT 'VND', -- ISO Code (USD, VND)
-- 4. Boolean (Naming Rules)
is_active BOOLEAN DEFAULT TRUE,
is_taxable BOOLEAN DEFAULT TRUE,
-- 5. Dynamic Data (JSONB)
attributes JSONB, -- VD: {"color": "red", "size": "M"}
tags TEXT[], -- VD: ["summer", "sale"]
-- 6. Audit & Soft Delete (Standard Mixins)
created_at TIMESTAMPTZ DEFAULT NOW(),
created_by UUID,
updated_at TIMESTAMPTZ DEFAULT NOW(),
updated_by UUID,
deleted_at TIMESTAMPTZ, -- Nullable
-- 7. Versioning
version BIGINT DEFAULT 1
);
-- Indexing Strategy (Chiến lược đánh Index)
CREATE INDEX idx_products_tenant ON products(tenant_id); -- Bắt buộc cho SaaS
CREATE INDEX idx_products_code ON products(tenant_id, code); -- Tìm theo mã trong 1 tenant
CREATE INDEX idx_products_tags ON products USING GIN(tags); -- Tìm kiếm trong mảng
Bạn có thể copy mẫu này và áp dụng cho tất cả các bảng khác trong hệ thống. Sự nhất quán này sẽ giúp team Dev giảm thiểu tranh luận và tập trung vào code logic.
url ảnh VARCHAR 255 có sợ ngắn quá không?
Câu trả lời ngắn gọn: CÓ, 255 ký tự là QUÁ NGẮN và RẤT RỦI RO trong bối cảnh SaaS hiện đại.
Bạn nên đổi ngay sang kiểu dữ liệu rộng rãi hơn.
Dưới đây là lý do tại sao và giải pháp cho từng loại Database trong hệ thống của bạn:
1. Tại sao 255 ký tự lại không đủ?
Trong kỷ nguyên Cloud, URL ảnh không còn đơn giản là https://domain.com/abc.jpg nữa.
Lý do 1: Presigned URLs (URL có chữ ký bảo mật)
Nếu bạn lưu ảnh trên AWS S3, Google Cloud Storage, MinIO ở chế độ Private (Bảo mật), khi bạn muốn hiển thị ảnh cho User, bạn phải sinh ra một URL tạm thời (Presigned URL).
URL này chứa AccessKey, Signature, Expires token...
Độ dài thực tế: Thường từ 400 - 800 ký tự, thậm chí hơn 1000 ký tự.
Ví dụ: https://s3.aws.../file.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA...%2F20240101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=...&X-Amz-Expires=3600&X-Amz-Signature=... (Cái này chắc chắn vỡ VARCHAR(255)).
Lý do 2: CDN & Image Transformation
Các dịch vụ như Cloudinary, Imgix thường nhồi các tham số chỉnh sửa ảnh vào URL.
Ví dụ: https://res.cloudinary.com/demo/image/upload/w_300,h_300,c_fill,q_auto,f_auto,e_improve/v1551428220/folder/subfolder/user_uploads/avatar_nguyen_van_a_timestamp_123456.jpg (Rất dài).
Lý do 3: Tên file tiếng Việt và Nested Folders
Tên file: hợp đồng lao động bản chính thức đã ký 2024.pdf (URL Encode lên sẽ thành %20h%E1%BB%A3p%20... dài gấp 3 lần).
Folder sâu: /tenants/uuid-dai-ngoang/users/uuid-cung-dai/attachments/2024/01/...
2. Giải pháp cho từng Database
Hãy quên con số 255 đi. Đây là khuyến nghị cho hệ thống của bạn:
A. Với YugabyteDB (PostgreSQL Compatible)
PostgreSQL (và YugabyteDB) xử lý TEXT và VARCHAR(n) gần như giống hệt nhau về mặt hiệu năng lưu trữ. Không có lợi ích gì đáng kể khi giới hạn độ dài nếu bạn không thực sự cần constraint.
Khuyên dùng: TEXT (Lưu chuỗi độ dài tùy ý).
Hoặc nếu muốn giới hạn an toàn: VARCHAR(2048) (Chuẩn độ dài URL tối đa của các trình duyệt cũ).
SQL
-- Thay vì:
avatar_url VARCHAR(255)
-- Hãy dùng:
avatar_url TEXT
B. Với MongoDB
MongoDB không có giới hạn độ dài chuỗi cứng nhắc trong Schema.
Khuyên dùng: String.
Bạn không cần lo lắng gì ở đây cả.
C. Với ClickHouse
Khuyên dùng: String.
ClickHouse nén dữ liệu dạng cột. Một cột String chứa URL dài nhưng có phần tiền tố giống nhau (ví dụ https://s3.amazonaws.com/...) sẽ được nén cực tốt, tốn rất ít dung lượng.
3. Một lưu ý quan trọng về Indexing
Nếu bạn dùng TEXT (độ dài vô hạn), bạn cần cẩn thận khi đánh Index:
Vấn đề: B-Tree Index cho một cột TEXT quá dài sẽ rất nặng và làm chậm thao tác Insert.
Câu hỏi: Bạn có bao giờ cần tìm kiếm chính xác theo URL ảnh không? (SELECT * FROM users WHERE avatar_url = '...')?
Thường là KHÔNG. Chúng ta thường chỉ SELECT avatar_url để hiển thị ra ngoài.
Kết luận: Đừng đánh Index cho cột url.
Nếu bắt buộc phải tìm kiếm (ví dụ để check trùng file):
Hãy tạo thêm 1 cột url_hash (Lưu mã MD5 hoặc SHA256 của URL).
Đánh Index vào cột url_hash (Độ dài cố định, tìm kiếm cực nhanh).
Tóm lại:
Sửa lại thiết kế ngay: Đổi VARCHAR(255) thành TEXT (trong YugabyteDB) hoặc String (trong Mongo/ClickHouse). Đừng tiết kiệm vài byte để rồi hệ thống bị crash (sập) khi khách hàng upload một cái ảnh có tên file dài.
thiết kế chi tiết bảng tenants, lưu trong YugabyteDB
Đây là thiết kế chi tiết (DDL) cho bảng tenants tối ưu hóa riêng cho YugabyteDB (tương thích PostgreSQL), áp dụng toàn bộ các quy chuẩn chúng ta đã thống nhất (Naming convention snake_case, kiểu dữ liệu TEXT, TIMESTAMPTZ, v.v.).
Bảng này đóng vai trò là "Trái tim" của hệ thống SaaS, nơi chứa thông tin định danh và trạng thái quan trọng nhất.
1. DDL Script (Copy-Paste)
SQL
-- Tạo bảng Tenants
CREATE TABLE tenants (
-- 1. Identity (Định danh)
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
code VARCHAR(64) NOT NULL, -- Slug/Subdomain (VD: 'fpt-software', 'viettel')
name TEXT NOT NULL, -- Tên hiển thị công ty
-- 2. General Information (Thông tin chung)
description TEXT,
logo_url TEXT, -- Dùng TEXT vì URL ảnh có thể rất dài (Presigned URL)
website_url TEXT,
-- 3. Regional & Localization (Địa phương hóa - Rất quan trọng cho Global SaaS)
timezone VARCHAR(50) DEFAULT 'UTC', -- VD: 'Asia/Ho_Chi_Minh' (Dùng để tính ngày hết hạn)
locale VARCHAR(10) DEFAULT 'vi-VN', -- Ngôn ngữ mặc định
currency_code VARCHAR(3) DEFAULT 'VND', -- Đơn vị tiền tệ mặc định
-- 4. Subscription State (Snapshot trạng thái gói để query nhanh)
-- Thay vì join bảng subscription mỗi lần check quyền, lưu cache trạng thái tại đây.
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL', -- TRIAL, ACTIVE, SUSPENDED, CANCELLED
current_tier_code VARCHAR(50), -- VD: 'ENTERPRISE_PLAN'
subscription_end_at TIMESTAMPTZ, -- Thời điểm hết hạn (UTC)
-- 5. Access Control Cache (Mảng ứng dụng được phép dùng)
-- Dùng mảng của Postgres để check nhanh: WHERE 'HRM' = ANY(active_apps)
active_apps TEXT[], -- VD: ['HRM_APP', 'CRM_APP']
-- 6. Ownership & Contact
owner_id UUID, -- Link tới bảng users (Super Admin của tenant này)
contact_email TEXT,
contact_phone VARCHAR(20),
-- 7. Audit & Versioning (Tiêu chuẩn bắt buộc)
created_at TIMESTAMPTZ DEFAULT NOW(),
created_by UUID,
updated_at TIMESTAMPTZ DEFAULT NOW(),
updated_by UUID,
deleted_at TIMESTAMPTZ, -- Soft Delete
version BIGINT DEFAULT 1, -- Optimistic Locking
-- 8. Constraints (Ràng buộc toàn vẹn)
CONSTRAINT uq_tenants_code UNIQUE (code),
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))
);
-- Indexing Strategy (Chiến lược đánh Index cho YugabyteDB)
-- Index 1: Tìm kiếm theo domain/code (Dùng thường xuyên khi login/router)
CREATE INDEX idx_tenants_code ON tenants (code) WHERE deleted_at IS NULL;
-- Index 2: Tìm kiếm các Tenant đang hoạt động của 1 Owner (User Dashboard)
CREATE INDEX idx_tenants_owner ON tenants (owner_id) WHERE deleted_at IS NULL;
-- Index 3: Lọc Tenant theo trạng thái và gói (Cho Admin hệ thống SaaS)
CREATE INDEX idx_tenants_status_tier ON tenants (status, current_tier_code);
-- Index 4: Tìm kiếm nhanh trong mảng ứng dụng (GIN Index)
-- Hỗ trợ query: "Tìm tất cả tenant đang dùng app HRM"
CREATE INDEX idx_tenants_active_apps ON tenants USING GIN (active_apps);
2. Giải thích chi tiết các trường quan trọng
A. Nhóm Identity (_id, code)
_id (UUID): Dùng làm khóa chính nội bộ để liên kết (JOIN) với các bảng khác (users, orders). UUID giúp phân tán dữ liệu đều trên các node của YugabyteDB (Sharding).
code (VARCHAR): Dùng làm định danh public trên URL.
Ví dụ: https://app.saas.com/fpt-software/dashboard.
Trường này cần UNIQUE và ngắn gọn, dễ đọc.
B. Nhóm Subscription Cache (status, subscription_end_at, active_apps)
Đây là kỹ thuật Denormalization (Phi chuẩn hóa) có chủ đích để tối ưu hiệu năng.
Vấn đề: Mỗi lần User F5 trang web, hệ thống phải biết ngay: "Công ty này còn hạn không? Có mua App này không?". Nếu phải JOIN tenant_subscriptions liên tục thì rất chậm.
Giải pháp:
Khi bảng tenant_subscriptions có thay đổi (gia hạn, mua thêm), Backend sẽ trigger update ngược lại vào bảng tenants các trường này.
active_apps TEXT[]: Tận dụng sức mạnh kiểu mảng của Postgres/Yugabyte. Check quyền cực nhanh mà không cần bảng phụ mapping.
C. Nhóm Localization (timezone)
Như đã bàn ở phần DateTime, trường này cực kỳ quan trọng.
Khi Tenant muốn xuất báo cáo "Doanh thu ngày hôm nay", hệ thống phải lấy timezone tại đây để biết "hôm nay" bắt đầu từ mấy giờ theo giờ địa phương của họ.
D. Nhóm Audit (deleted_at, version)
deleted_at: Hệ thống SaaS B2B không bao giờ xóa cứng (Hard Delete) dữ liệu khách hàng ngay lập tức. Khi khách hàng hủy dịch vụ, chỉ update deleted_at = NOW().
version: Dùng để xử lý Concurrency (Đồng thời).
Admin A sửa tên công ty.
Admin B sửa số điện thoại công ty.
Cả 2 cùng bấm nút Lưu 1 lúc.
YugabyteDB sẽ check version. Ai đến sau sẽ bị báo lỗi "Dữ liệu đã thay đổi, vui lòng tải lại" -> Tránh ghi đè mất dữ liệu.
3. Lưu ý đặc thù cho YugabyteDB
Sharding (Phân mảnh dữ liệu)
YugabyteDB tự động sharding dựa trên Primary Key (_id).
Với thiết kế _id UUID, dữ liệu sẽ được phân tán đều (Uniform Distribution) trên tất cả các Tablet Server. Điều này giúp hệ thống chịu tải ghi (Write Throughput) cực lớn mà không bị nghẽn (Hotspot).
Geo-Partitioning (Nếu bạn làm Global SaaS)
Nếu khách hàng của bạn ở cả Mỹ và Việt Nam, và bạn muốn "Khách Mỹ lưu server Mỹ, khách Việt lưu server Việt" để giảm độ trễ (Latency).
Bạn cần thêm trường region_code (VD: US-WEST, VN-HAN) vào bảng tenants.
Đánh dấu region_code vào Partition Key của YugabyteDB Tablespaces. (Đây là tính năng nâng cao, thiết kế bảng trên đã sẵn sàng để mở rộng tính năng này).
kẻ dạng bảng
Dưới đây là thiết kế chi tiết bảng tenants trong YugabyteDB được trình bày dưới dạng Data Dictionary (Từ điển dữ liệu) để bạn dễ dàng đưa vào tài liệu kỹ thuật (Technical Specs).
Bảng: tenants
Mục đích: Lưu trữ thông tin định danh, cấu hình gốc và trạng thái gói cước của khách hàng (Tenant).
STT Tên trường (Field) Kiểu dữ liệu (Data Type) Null? Mặc định (Default) Mô tả & Quy tắc nghiệp vụ
1 _id UUID NO gen_random_uuid() Khóa chính (PK). Dùng để phân tán dữ liệu (Sharding) trên YugabyteDB.
2 code VARCHAR(64) NO - Mã định danh/Subdomain (VD: fpt, viettel). UNIQUE. Chỉ chứa [a-z0-9-].
3 name TEXT NO - Tên hiển thị của công ty/tổ chức.
4 description TEXT YES NULL Mô tả ngắn gọn về Tenant.
5 logo_url TEXT YES NULL URL logo. Dùng TEXT để chứa Presigned URL dài.
6 website_url TEXT YES NULL Website trang chủ của khách hàng.
7 timezone VARCHAR(50) NO 'UTC' Múi giờ của Tenant (VD: 'Asia/Ho_Chi_Minh'). Quan trọng để tính ngày hết hạn gói.
8 locale VARCHAR(10) NO 'vi-VN' Định dạng ngôn ngữ/ngày tháng mặc định.
9 currency_code VARCHAR(3) NO 'VND' Mã tiền tệ mặc định cho các báo cáo nội bộ của Tenant.
10 status VARCHAR(20) NO 'TRIAL' Trạng thái: TRIAL, ACTIVE, SUSPENDED, CANCELLED, ARCHIVED.
11 current_tier_code VARCHAR(50) YES NULL Mã gói cước hiện tại (Cache từ bảng sub). VD: ENTERPRISE_PLAN.
12 subscription_end_at TIMESTAMPTZ YES NULL Thời điểm hết hạn gói (UTC). Cache để check quyền nhanh.
13 active_apps TEXT[] YES NULL Mảng. Danh sách App được quyền dùng. VD: ['HRM', 'CRM'].
14 owner_id UUID YES NULL ID của User đóng vai trò chủ sở hữu (Super Admin).
15 contact_email TEXT YES NULL Email liên hệ đại diện (Billing email).
16 contact_phone VARCHAR(20) YES NULL Số điện thoại liên hệ.
17 created_at TIMESTAMPTZ NO NOW() Thời điểm tạo bản ghi.
18 created_by UUID YES NULL Người tạo bản ghi (System hoặc Sale Admin).
19 updated_at TIMESTAMPTZ NO NOW() Thời điểm cập nhật cuối cùng.
20 updated_by UUID YES NULL Người cập nhật cuối cùng.
21 deleted_at TIMESTAMPTZ YES NULL Soft Delete. Nếu khác NULL nghĩa là Tenant đã bị xóa.
22 version BIGINT NO 1 Dùng cho cơ chế Optimistic Locking (Chống ghi đè).
Danh sách Indexes (Chiến lược truy vấn)
Các Index này được thiết kế dựa trên các Access Pattern phổ biến của hệ thống SaaS.
Tên Index Loại Index Cột được Index Mục đích sử dụng
idx_tenants_code UNIQUE (code) Tìm Tenant khi user truy cập qua Subdomain hoặc API Login.
idx_tenants_owner NORMAL (owner_id) Hiển thị danh sách công ty mà User này đang sở hữu.
idx_tenants_status_tier NORMAL (status, current_tier_code) Admin hệ thống lọc danh sách khách hàng (VD: Lấy list khách VIP đang Active).
idx_tenants_active_apps GIN (active_apps) Tìm tất cả Tenant đang sử dụng một ứng dụng cụ thể (VD: Khi deploy phiên bản mới cho App HRM).
Các ràng buộc (Constraints)
Tên Loại Mô tả Logic
uq_tenants_code UNIQUE Không được phép trùng code (Slug) giữa các tenant khác nhau.
chk_tenants_status CHECK Giá trị status chỉ được nằm trong danh sách cho phép (Whitelist).
Bảng này bạn có thể copy trực tiếp vào tài liệu thiết kế (Technical Design Document - TDD) để dev frontend và backend cùng đối chiếu.
thêm cột ràng buộc dữ liệu
Việc thêm cột Ràng buộc dữ liệu (Data Residency / Data Sovereignty) là cực kỳ quan trọng đối với các hệ thống SaaS quy mô lớn, đặc biệt khi sử dụng YugabyteDB (Cơ sở dữ liệu phân tán toàn cầu).
Cột này giải quyết bài toán pháp lý (GDPR) và hiệu năng (Latency): "Khách hàng Châu Âu bắt buộc dữ liệu phải nằm ở server Châu Âu, không được bay về Việt Nam".
Dưới đây là cập nhật thiết kế bảng tenants với cột mới này.
Cập nhật Bảng tenants
Tôi sẽ thêm cột data_region vào nhóm thông tin hạ tầng.
STT Tên trường (Field) Kiểu dữ liệu Null? Mặc định Mô tả & Quy tắc nghiệp vụ
... ... ... ... ... ...
23 data_region VARCHAR(50) NO 'DEFAULT'
Ràng buộc vị trí dữ liệu. Dùng để định tuyến dữ liệu vào đúng Server vật lý (Geo-Partitioning).
VD: 'aws-us-east-1', 'aws-ap-southeast-1', 'eu-central-1'.
24 compliance_level VARCHAR(20) NO 'STANDARD'
Mức độ tuân thủ bảo mật.
VD: 'STANDARD' (Chung), 'HIPAA' (Y tế), 'GDPR' (Châu Âu - Xóa sạch vĩnh viễn, không log PII).
Cập nhật DDL Script (YugabyteDB)
SQL
CREATE TABLE tenants (
-- ... (Các cột cũ: _id, code, name...) ...
-- [MỚI] Nhóm Data Residency & Compliance
-- Cột này quyết định dữ liệu nằm ở ổ cứng nào trên thế giới
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1', -- Mặc định là Singapore/Vietnam
-- Cột này quyết định quy trình xử lý dữ liệu (Logic code)
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',
-- ... (Các cột cũ: created_at, version...) ...
-- Ràng buộc giá trị hợp lệ
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'HIPAA', 'GDPR', 'PCI-DSS'))
);
-- [QUAN TRỌNG] Partitioning Strategy cho YugabyteDB
-- Nếu bạn muốn bật tính năng Geo-Partitioning, Primary Key phải thay đổi:
-- PRIMARY KEY ((data_region, _id))
-- Khi đó YugabyteDB sẽ gom tất cả tenant cùng region vào chung 1 nhóm Tablet Server.
Giải thích kỹ thuật: Tại sao cần 2 cột này?
1. data_region (Vị trí vật lý)
Đây là "Vũ khí bí mật" của YugabyteDB.
Bài toán: Khách hàng Mỹ truy cập vào Web App. Nếu DB nằm ở Việt Nam, độ trễ (latency) là 200ms -> Trải nghiệm tệ.
Giải pháp:
Tenant A (data_region = 'us-east-1') -> Dữ liệu được YugabyteDB tự động lưu ở Node Server tại Mỹ. Truy cập nhanh như điện (latency < 10ms).
Tenant B (data_region = 'ap-southeast-1') -> Dữ liệu lưu ở Server Việt Nam/Sing.
Cơ chế: Bạn sẽ cấu hình Tablespaces trong YugabyteDB map với các region này.
2. compliance_level (Logic nghiệp vụ)
Cột này không quyết định vị trí lưu, mà quyết định cách ứng dụng hành xử.
Ví dụ: Nếu compliance_level = 'GDPR':
Khi user xóa tài khoản, hệ thống thực hiện "Hard Delete" (Xóa vĩnh viễn) thay vì "Soft Delete" (ẩn đi).
Không ghi log IP người dùng vào bảng audit_logs.
Mã hóa dữ liệu (Encryption at rest) bằng Key riêng biệt.
Tác động đến Code (Backend)
Khi tạo Tenant mới (Sign Up), luồng xử lý sẽ như sau:
User chọn quốc gia: "Vietnam".
Backend map Vietnam -> data_region = 'ap-southeast-1'.
Backend insert vào bảng tenants.
YugabyteDB nhìn thấy data_region = 'ap-southeast-1', nó tự động định tuyến bản ghi này xuống server đặt tại Singapore/VN.
Toàn bộ dữ liệu sau này của Tenant (Users, Orders,...) đều phải kế thừa data_region này (bằng cách đưa tenant_id vào làm partition key của các bảng con).
vẽ lại dạng bảng
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) cho bảng tenants trong YugabyteDB, đã bao gồm các cập nhật về Ràng buộc dữ liệu (Data Residency) và Tuân thủ bảo mật (Compliance).
Bạn có thể sử dụng bảng này làm tài liệu kỹ thuật chính thức (Spec) cho đội dự án.
1. Cấu trúc bảng tenants
STT Tên trường (Field) Kiểu dữ liệu (YSQL) Null? Mặc định (Default) Mô tả & Quy tắc nghiệp vụ
I ĐỊNH DANH & HẠ TẦNG
1 _id UUID NO gen_random_uuid() Khóa chính (PK). Định danh duy nhất toàn cục.
2 data_region VARCHAR(50) NO 'ap-southeast-1' [MỚI] Data Residency. Quy định vị trí vật lý lưu dữ liệu (Geo-Partitioning). VD: us-east-1, eu-central-1.
3 code VARCHAR(64) NO - Mã định danh (Subdomain/Slug). UNIQUE. Chỉ chứa ký tự [a-z0-9-].
4 compliance_level VARCHAR(20) NO 'STANDARD' [MỚI] Mức độ tuân thủ: STANDARD, GDPR, HIPAA. Quyết định logic xóa và log dữ liệu.
II THÔNG TIN CƠ BẢN
5 name TEXT NO - Tên hiển thị của tổ chức/công ty.
6 description TEXT YES NULL Mô tả ngắn gọn.
7 logo_url TEXT YES NULL URL logo (Hỗ trợ Presigned URL dài > 255 ký tự).
8 website_url TEXT YES NULL Website trang chủ.
III ĐỊA PHƯƠNG HÓA (LOCALIZATION)
9 timezone VARCHAR(50) NO 'UTC' Múi giờ hành chính (VD: 'Asia/Ho_Chi_Minh'). Dùng để tính ngày hết hạn gói.
10 locale VARCHAR(10) NO 'vi-VN' Ngôn ngữ hiển thị mặc định.
11 currency_code VARCHAR(3) NO 'VND' Đơn vị tiền tệ mặc định (ISO 4217).
IV TRẠNG THÁI GÓI CƯỚC (CACHE)
12 status VARCHAR(20) NO 'TRIAL' Trạng thái: TRIAL, ACTIVE, SUSPENDED, CANCELLED, ARCHIVED.
13 current_tier_code VARCHAR(50) YES NULL Mã gói cước hiện tại (Snapshot). VD: ENTERPRISE_GOLD.
14 subscription_end_at TIMESTAMPTZ YES NULL Thời điểm hết hạn gói (UTC). Check quyền nhanh không cần JOIN.
15 active_apps TEXT[] YES NULL Mảng. Danh sách App đang được kích hoạt. VD: ['HRM', 'CRM'].
V QUẢN TRỊ & AUDIT
16 owner_id UUID YES NULL ID User chủ sở hữu (Super Admin).
17 contact_email TEXT YES NULL Email liên hệ đại diện (Billing).
18 created_at TIMESTAMPTZ NO NOW() Thời điểm tạo.
19 updated_at TIMESTAMPTZ NO NOW() Thời điểm cập nhật cuối.
20 deleted_at TIMESTAMPTZ YES NULL Soft Delete. Nếu != NULL coi như đã xóa.
21 version BIGINT NO 1 Dùng cho Optimistic Locking (Chống ghi đè đồng thời).
2. Các Ràng buộc Dữ liệu (Constraints)
Định nghĩa các luật bất biến (Rules) ngay tại tầng Database để đảm bảo dữ liệu luôn sạch.
Tên Constraint Loại Cột ảnh hưởng Quy tắc Logic
pk_tenants PRIMARY KEY _id Khóa chính, không trùng lặp.
uq_tenants_code UNIQUE code Mã tenant (slug) không được trùng trên toàn hệ thống.
chk_tenants_status CHECK status Chỉ chấp nhận: 'TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'.
chk_tenants_region CHECK data_region Chỉ chấp nhận các Region hợp lệ: 'ap-southeast-1', 'us-east-1', 'eu-central-1'.
chk_tenants_compliance CHECK compliance_level Chỉ chấp nhận: 'STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'.
3. Chiến lược Index (Indexing Strategy)
Tối ưu hóa cho các truy vấn phổ biến nhất trong hệ thống SaaS.
Tên Index Loại Cột (Columns) Điều kiện (Where) Mục đích sử dụng (Use Case)
idx_tenants_code UNIQUE code deleted_at IS NULL Login/Routing: Tìm Tenant ID từ subdomain trên URL (VD: fpt.saas.com).
idx_tenants_region NORMAL data_region - System Admin: Thống kê số lượng khách hàng theo khu vực địa lý.
idx_tenants_active_apps GIN active_apps - Deployment/Feature Flag: Tìm tất cả Tenant đang dùng app "HRM" để update tính năng mới.
idx_tenants_status_tier NORMAL status, current_tier_code - Marketing/Sales: Lọc danh sách khách hàng VIP đang Active để chăm sóc.
Lưu ý kỹ thuật quan trọng (Technical Note)
Nếu bạn cấu hình Geo-Partitioning (Phân mảnh theo địa lý) trong YugabyteDB để đạt hiệu năng tối đa:
Partition Key cần phải bao gồm cột data_region.
Lúc đó, Primary Key thực tế sẽ là tổ hợp: ((data_region), _id).
Điều này giúp YugabyteDB biết ngay lập tức cần định tuyến query về Node server nào (Mỹ hay Việt Nam) mà không cần quét toàn bộ mạng lưới.
kẻ bảng có đầy đủ các ràng buộc dữ liệu cho các trường
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) cho bảng tenants trong YugabyteDB, tập trung vào các ràng buộc dữ liệu (Data Constraints) để đảm bảo tính toàn vẹn và hợp lệ của dữ liệu ngay từ tầng Database.
1. Chi tiết các trường và Ràng buộc (Field & Constraints)
Tên trường (Field) Kiểu dữ liệu (YSQL) Null? Mặc định (Default) Ràng buộc (Constraints) & Logic Kiểm tra
_id UUID NO gen_random_uuid() PRIMARY KEY. Định danh duy nhất.
data_region VARCHAR(50) NO 'ap-southeast-1' CHECK: Giá trị phải nằm trong danh sách Region hợp lệ (VD: 'ap-southeast-1', 'us-east-1', 'eu-central-1').
code VARCHAR(64) NO -
UNIQUE.
CHECK Regex: Chỉ chứa ký tự thường, số và gạch ngang (^[a-z0-9-]+$). Không chứa khoảng trắng hay ký tự đặc biệt.
compliance_level VARCHAR(20) NO 'STANDARD' CHECK: Phải thuộc ['STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'].
name TEXT NO - CHECK: Độ dài LENGTH(name) > 0. Không được để chuỗi rỗng.
description TEXT YES NULL -
logo_url TEXT YES NULL CHECK Regex: (Tùy chọn) Phải bắt đầu bằng http:// hoặc https://.
website_url TEXT YES NULL CHECK Regex: Phải bắt đầu bằng http:// hoặc https://.
timezone VARCHAR(50) NO 'UTC' -
locale VARCHAR(10) NO 'vi-VN' CHECK: Định dạng chuẩn ISO (VD: en-US, vi-VN).
currency_code VARCHAR(3) NO 'VND' CHECK: Độ dài cố định 3 ký tự.
status VARCHAR(20) NO 'TRIAL' CHECK: Phải thuộc ['TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'].
current_tier_code VARCHAR(50) YES NULL -
subscription_end_at TIMESTAMPTZ YES NULL CHECK: Nếu có giá trị, phải lớn hơn created_at (subscription_end_at > created_at).
active_apps TEXT[] YES NULL -
owner_id UUID YES NULL FOREIGN KEY: Tham chiếu đến users._id.
contact_email TEXT YES NULL CHECK Regex: Phải đúng định dạng Email (^[^@]+@[^@]+\.[^@]+$).
contact_phone VARCHAR(20) YES NULL -
created_at TIMESTAMPTZ NO NOW() -
created_by UUID YES NULL FOREIGN KEY: Tham chiếu đến users._id.
updated_at TIMESTAMPTZ NO NOW() CHECK: updated_at >= created_at.
updated_by UUID YES NULL FOREIGN KEY: Tham chiếu đến users._id.
deleted_at TIMESTAMPTZ YES NULL -
version BIGINT NO 1 CHECK: version >= 1.
2. Định nghĩa SQL cho các Ràng buộc (DDL Constraints)
Dưới đây là đoạn script SQL thực tế để tạo các ràng buộc này trong YugabyteDB:
SQL
ALTER TABLE tenants
-- 1. Khóa chính
ADD CONSTRAINT pk_tenants PRIMARY KEY (_id),
-- 2. Ràng buộc duy nhất (Unique)
ADD CONSTRAINT uq_tenants_code UNIQUE (code),
-- 3. Khóa ngoại (Foreign Keys)
-- Lưu ý: Chỉ tạo FK nếu bảng users nằm cùng Database/Keyspace.
-- Trong Microservices phân tán đôi khi người ta bỏ FK cứng để giảm coupling.
ADD CONSTRAINT fk_tenants_owner FOREIGN KEY (owner_id) REFERENCES users(_id),
ADD CONSTRAINT fk_tenants_creator FOREIGN KEY (created_by) REFERENCES users(_id),
ADD CONSTRAINT fk_tenants_updater FOREIGN KEY (updated_by) REFERENCES users(_id),
-- 4. Ràng buộc giá trị (Check Constraints)
-- Kiểm tra định dạng Slug (chỉ chữ thường, số, gạch ngang)
ADD CONSTRAINT chk_code_format CHECK (code ~ '^[a-z0-9-]+$'),
-- Kiểm tra danh sách trạng thái cho phép
ADD CONSTRAINT chk_status_valid CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')),
-- Kiểm tra vùng dữ liệu hợp lệ
ADD CONSTRAINT chk_region_valid CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
-- Kiểm tra mức độ tuân thủ
ADD CONSTRAINT chk_compliance_valid CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
-- Kiểm tra Logic thời gian
ADD CONSTRAINT chk_dates_logic CHECK (subscription_end_at IS NULL OR subscription_end_at > created_at),
ADD CONSTRAINT chk_updated_logic CHECK (updated_at >= created_at),
-- Kiểm tra định dạng Email (Cơ bản)
ADD CONSTRAINT chk_email_format CHECK (contact_email IS NULL OR contact_email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$');
3. Tóm tắt các loại ràng buộc đã sử dụng
Primary Key (PK): Đảm bảo mỗi dòng là duy nhất.
Foreign Key (FK): Đảm bảo tính toàn vẹn tham chiếu (User phải tồn tại mới được làm Owner).
Unique (UQ): Đảm bảo không có 2 công ty trùng mã định danh (code).
Check (CK):
Whitelist: Chỉ cho phép các giá trị định sẵn (Enum giả lập).
Regex: Kiểm tra định dạng chuỗi (Email, URL, Slug).
Logic: So sánh các cột với nhau (Ngày hết hạn phải sau ngày tạo).
Not Null (NN): Bắt buộc phải nhập liệu.
thêm cột Mô tả
Tôi hiểu ý bạn. Bạn muốn bổ sung thêm cột "Mô tả / Ý nghĩa" (Description) vào bảng thiết kế để tài liệu rõ ràng hơn cho cả đội ngũ kỹ thuật (Dev) và đội ngũ nghiệp vụ (BA/Product Owner).
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) của bảng tenants trong YugabyteDB, tách biệt rõ ràng giữa Ràng buộc kỹ thuật (Constraints) và Mô tả nghiệp vụ (Description).
Data Dictionary: Bảng tenants
Tên trường (Field) Kiểu dữ liệu (Type) Null / Default Ràng buộc Kỹ thuật (Constraints) Mô tả & Ý nghĩa Nghiệp vụ (Description)
_id UUID
NO
gen_random_uuid()
PRIMARY KEY Định danh duy nhất của Tenant trong hệ thống. Dùng để liên kết dữ liệu các bảng khác.
data_region VARCHAR(50)
NO
'ap-southeast-1'
CHECK: IN ('ap-southeast-1', 'us-east-1', ...) Vị trí lưu trữ dữ liệu. Quy định dữ liệu của khách hàng này sẽ nằm ở server quốc gia nào (Tuân thủ luật định cư dữ liệu).
code VARCHAR(64) NO
UNIQUE
CHECK: ~ '^[a-z0-9-]+$'
Mã định danh (Slug). Dùng trên URL (VD: fpt.saas.com). Chỉ chấp nhận chữ thường, số và gạch ngang.
name TEXT NO CHECK: LENGTH(name) > 0 Tên hiển thị chính thức của công ty/tổ chức khách hàng.
description TEXT
YES
NULL
- Mô tả ngắn gọn về hoạt động kinh doanh của khách hàng (Dùng cho trang profile public).
compliance_level VARCHAR(20)
NO
'STANDARD'
CHECK: IN ('STANDARD', 'GDPR', 'HIPAA') Mức độ tuân thủ. Quyết định quy trình bảo mật và xóa dữ liệu (VD: GDPR yêu cầu xóa sạch vĩnh viễn).
logo_url TEXT
YES
NULL
CHECK: ~ '^https?://' Đường dẫn ảnh Logo. Hỗ trợ Presigned URL dài.
website_url TEXT
YES
NULL
CHECK: ~ '^https?://' Trang chủ của khách hàng.
timezone VARCHAR(50)
NO
'UTC'
- Múi giờ hành chính. Dùng để tính toán ngày bắt đầu/kết thúc gói cước chính xác theo giờ địa phương.
locale VARCHAR(10)
NO
'vi-VN'
- Ngôn ngữ và định dạng số/ngày tháng mặc định của Tenant.
currency_code VARCHAR(3)
NO
'VND'
CHECK: LENGTH = 3 Mã tiền tệ mặc định (ISO 4217) dùng trong báo cáo nội bộ của Tenant.
status VARCHAR(20)
NO
'TRIAL'
CHECK: IN ('TRIAL', 'ACTIVE', 'SUSPENDED', ...) Trạng thái vòng đời. Kiểm soát việc Tenant có được đăng nhập hay không.
current_tier_code VARCHAR(50)
YES
NULL
- Cache gói cước. Mã gói dịch vụ đang sử dụng (VD: Enterprise, Startup).
subscription_end_at TIMESTAMPTZ
YES
NULL
CHECK: > created_at Thời hạn sử dụng. Nếu quá ngày này (theo UTC), hệ thống sẽ chặn quyền truy cập hoặc hạ cấp gói.
active_apps TEXT[]
YES
NULL
- Danh sách ứng dụng. Mảng chứa các mã App mà Tenant đã mua (VD: ['HRM', 'CRM']).
owner_id UUID
YES
NULL
FK: Ref users(_id) Tài khoản quản trị viên cao cấp nhất (Super Admin) của Tenant này.
contact_email TEXT
YES
NULL
CHECK: Regex Email Email nhận hóa đơn và thông báo hệ thống quan trọng.
created_at TIMESTAMPTZ
NO
NOW()
- Thời điểm khách hàng đăng ký vào hệ thống.
updated_at TIMESTAMPTZ
NO
NOW()
CHECK: >= created_at Thời điểm thông tin Tenant được chỉnh sửa gần nhất.
deleted_at TIMESTAMPTZ
YES
NULL
- Cờ xóa mềm (Soft Delete). Nếu có giá trị, coi như Tenant đã bị hủy/xóa khỏi hệ thống.
version BIGINT
NO
1
CHECK: >= 1 Optimistic Lock. Phiên bản dòng dữ liệu, dùng để ngăn chặn việc ghi đè đồng thời.
Cập nhật SQL thêm cột Description (Nếu bạn đang chạy migration)
Nếu bảng đã tồn tại và bạn muốn thêm cột description vào, hãy chạy lệnh sau:
SQL
ALTER TABLE tenants
ADD COLUMN description TEXT;
-- (Tùy chọn) Thêm comment vào cột trong DB để tools quản lý DB hiển thị tooltip
COMMENT ON COLUMN tenants.description IS 'Mô tả ngắn gọn về hoạt động kinh doanh của khách hàng';
COMMENT ON COLUMN tenants.data_region IS 'Vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning)';
COMMENT ON COLUMN tenants.compliance_level IS 'Mức độ tuân thủ bảo mật (GDPR, HIPAA,...)';
tách Null và Default thành 2 cột
Tuyệt vời. Việc tách cột Nullable (Cho phép rỗng) và Default Value (Giá trị mặc định) sẽ giúp tài liệu thiết kế (Spec) rõ ràng hơn rất nhiều cho Developer khi viết câu lệnh CREATE TABLE.
Dưới đây là bảng thiết kế chi tiết nhất (Final Version) cho bảng tenants trong YugabyteDB.
Data Dictionary: Bảng tenants
STT Tên trường (Field) Kiểu dữ liệu (Type) Nullable? Giá trị mặc định (Default) Ràng buộc Kỹ thuật (Constraints) Mô tả & Ý nghĩa Nghiệp vụ (Description)
I ĐỊNH DANH & HẠ TẦNG
1 _id UUID NO gen_random_uuid() PK Định danh duy nhất của Tenant. Dùng làm Partition Key nếu cấu hình Sharding.
2 data_region VARCHAR(50) NO 'ap-southeast-1' CHECK: Valid Regions Vị trí lưu trữ. Quy định dữ liệu nằm ở server quốc gia nào (Geo-Partitioning).
3 code VARCHAR(64) NO - UNIQUE, CHECK: Regex Slug Mã định danh (Slug) trên URL. Chỉ chứa chữ thường, số, gạch ngang.
4 compliance_level VARCHAR(20) NO 'STANDARD' CHECK: Valid Levels Mức độ tuân thủ. Quyết định quy trình xóa và log dữ liệu (VD: GDPR).
II THÔNG TIN CƠ BẢN
5 name TEXT NO - CHECK: Length > 0 Tên hiển thị chính thức của tổ chức/công ty.
6 description TEXT YES NULL - Mô tả ngắn gọn về hoạt động kinh doanh.
7 logo_url TEXT YES NULL CHECK: Regex URL Đường dẫn ảnh Logo (Hỗ trợ URL dài).
8 website_url TEXT YES NULL CHECK: Regex URL Trang chủ website của khách hàng.
III ĐỊA PHƯƠNG HÓA
9 timezone VARCHAR(50) NO 'UTC' - Múi giờ hành chính. Dùng để tính toán thời hạn gói cước chính xác.
10 locale VARCHAR(10) NO 'vi-VN' - Ngôn ngữ và định dạng số/ngày tháng hiển thị mặc định.
11 currency_code VARCHAR(3) NO 'VND' CHECK: Len = 3 Mã tiền tệ mặc định (ISO 4217) cho báo cáo nội bộ.
IV TRẠNG THÁI & GÓI CƯỚC
12 status VARCHAR(20) NO 'TRIAL' CHECK: Valid Status Trạng thái vòng đời. Kiểm soát quyền đăng nhập của Tenant.
13 current_tier_code VARCHAR(50) YES NULL - Cache gói cước. Mã gói dịch vụ đang sử dụng (Snapshot).
14 subscription_end_at TIMESTAMPTZ YES NULL CHECK: > created_at Thời hạn sử dụng. Mốc thời gian (UTC) hết hạn dịch vụ.
15 active_apps TEXT[] YES NULL - DS Ứng dụng. Mảng chứa các mã App đã mua (VD: ['HRM', 'CRM']).
V QUẢN TRỊ & AUDIT
16 owner_id UUID YES NULL FK: users._id ID của Super Admin sở hữu Tenant này.
17 contact_email TEXT YES NULL CHECK: Regex Email Email nhận hóa đơn và thông báo hệ thống.
18 contact_phone VARCHAR(20) YES NULL - Số điện thoại liên hệ đại diện.
19 created_at TIMESTAMPTZ NO NOW() - Thời điểm tạo bản ghi.
20 created_by UUID YES NULL FK: users._id Người thực hiện tạo bản ghi (Sale Admin/System).
21 updated_at TIMESTAMPTZ NO NOW() CHECK: >= created_at Thời điểm cập nhật dữ liệu gần nhất.
22 updated_by UUID YES NULL FK: users._id Người thực hiện cập nhật gần nhất.
23 deleted_at TIMESTAMPTZ YES NULL - Soft Delete. Nếu khác NULL, coi như Tenant đã bị xóa.
24 version BIGINT NO 1 CHECK: >= 1 Optimistic Locking. Phiên bản dòng dữ liệu, chống ghi đè.
Ghi chú triển khai (Implementation Notes)
Cột Nullable = NO: Trong câu lệnh CREATE TABLE, bạn bắt buộc phải thêm từ khóa NOT NULL. Nếu không có Default, khi insert bắt buộc phải truyền giá trị.
Cột Nullable = YES: Mặc định SQL là Nullable, không cần khai báo gì thêm.
Giá trị -: Nghĩa là không có giá trị mặc định, User/Code bắt buộc phải cung cấp khi tạo mới.
viết câu truy vấn tạo bảng
Dưới đây là câu truy vấn SQL hoàn chỉnh (DDL Script) để tạo bảng tenants trong YugabyteDB (hoặc PostgreSQL), bao gồm đầy đủ định nghĩa cột, giá trị mặc định, ràng buộc (constraints) và index như chúng ta đã thiết kế.
Bạn có thể copy đoạn code này và chạy trực tiếp trong công cụ quản lý DB (như DBeaver, pgAdmin hoặc ysqlsh).
1. Script tạo bảng (CREATE TABLE)
SQL
-- [Lưu ý] Đảm bảo bảng 'users' đã tồn tại trước nếu muốn tạo Foreign Key
-- Nếu chưa có bảng users, hãy xóa/comment các dòng CONSTRAINT fk_...
CREATE TABLE tenants (
-- I. ĐỊNH DANH & HẠ TẦNG
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
code VARCHAR(64) NOT NULL,
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',
-- II. THÔNG TIN CƠ BẢN
name TEXT NOT NULL,
description TEXT,
logo_url TEXT,
website_url TEXT,
-- III. ĐỊA PHƯƠNG HÓA
timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN',
currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
-- IV. TRẠNG THÁI & GÓI CƯỚC
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
current_tier_code VARCHAR(50),
subscription_end_at TIMESTAMPTZ,
active_apps TEXT[], -- Mảng Text
-- V. QUẢN TRỊ & AUDIT
owner_id UUID,
contact_email TEXT,
contact_phone VARCHAR(20),
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
created_by UUID,
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_by UUID,
deleted_at TIMESTAMPTZ,
version BIGINT NOT NULL DEFAULT 1,
-- ========================================================
-- VI. CÁC RÀNG BUỘC DỮ LIỆU (CONSTRAINTS)
-- ========================================================
-- 1. Ràng buộc duy nhất
CONSTRAINT uq_tenants_code UNIQUE (code),
-- 2. Ràng buộc danh sách giá trị (Check Enum-like)
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')),
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
-- 3. Ràng buộc định dạng (Regex)
CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'), -- Chỉ thường, số, gạch ngang
CONSTRAINT chk_tenants_email_fmt CHECK (contact_email IS NULL OR contact_email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
CONSTRAINT chk_tenants_url_logo CHECK (logo_url IS NULL OR logo_url ~* '^https?://'),
CONSTRAINT chk_tenants_url_web CHECK (website_url IS NULL OR website_url ~* '^https?://'),
-- 4. Ràng buộc logic
CONSTRAINT chk_tenants_dates CHECK (subscription_end_at IS NULL OR subscription_end_at > created_at),
CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at),
CONSTRAINT chk_tenants_currency_len CHECK (LENGTH(currency_code) = 3),
CONSTRAINT chk_tenants_name_len CHECK (LENGTH(name) > 0),
-- 5. Khóa ngoại (Comment lại nếu chưa có bảng users)
CONSTRAINT fk_tenants_owner FOREIGN KEY (owner_id) REFERENCES users(_id),
CONSTRAINT fk_tenants_creator FOREIGN KEY (created_by) REFERENCES users(_id),
CONSTRAINT fk_tenants_updater FOREIGN KEY (updated_by) REFERENCES users(_id)
);
2. Script tạo Index (CREATE INDEX)
SQL
-- 1. Index hỗ trợ Login/Routing theo Subdomain
-- Chỉ index những tenant chưa bị xóa để tiết kiệm và tối ưu
CREATE UNIQUE INDEX idx_tenants_code
ON tenants (code)
WHERE deleted_at IS NULL;
-- 2. Index hỗ trợ Admin lọc theo Region (Thống kê hạ tầng)
CREATE INDEX idx_tenants_region
ON tenants (data_region);
-- 3. Index hỗ trợ tìm kiếm trong mảng Ứng dụng (QUAN TRỌNG)
-- Giúp query: WHERE 'HRM' = ANY(active_apps) chạy cực nhanh
CREATE INDEX idx_tenants_active_apps
ON tenants USING GIN (active_apps);
-- 4. Index hỗ trợ lọc khách hàng theo trạng thái và gói cước
CREATE INDEX idx_tenants_status_tier
ON tenants (status, current_tier_code);
-- 5. Index hỗ trợ hiển thị Dashboard cho User Owner
CREATE INDEX idx_tenants_owner
ON tenants (owner_id)
WHERE deleted_at IS NULL;
3. Script thêm Comment (Documentation)
Dùng để hiển thị chú thích khi bạn xem cấu trúc bảng trên các tool như DBeaver.
SQL
COMMENT ON TABLE tenants IS 'Lưu trữ thông tin định danh và trạng thái của khách hàng (Tenant)';
COMMENT ON COLUMN tenants._id IS 'Định danh duy nhất (UUID)';
COMMENT ON COLUMN tenants.code IS 'Slug subdomain, chỉ chứa a-z, 0-9 và -';
COMMENT ON COLUMN tenants.data_region IS 'Vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning)';
COMMENT ON COLUMN tenants.active_apps IS 'Danh sách các ứng dụng được kích hoạt';
COMMENT ON COLUMN tenants.subscription_end_at IS 'Ngày hết hạn gói cước (UTC)';
COMMENT ON COLUMN tenants.version IS 'Phiên bản dòng dữ liệu (Optimistic Locking)';
Lưu ý quan trọng về Geo-Partitioning
Nếu bạn muốn kích hoạt tính năng Geo-Partitioning (Để dữ liệu tự động chạy về đúng server theo data_region), bạn cần sửa dòng Primary Key trong câu lệnh CREATE TABLE thành:
SQL
-- Thay dòng: _id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-- Thành:
_id UUID DEFAULT gen_random_uuid(),
...
PRIMARY KEY ((data_region), _id) -- Partition Key là data_region
Lưu ý: Nếu đổi PK như thế này, các ràng buộc Foreign Key từ các bảng khác trỏ về tenants cũng sẽ cần thay đổi theo.
một tenant có thể mua nhiều gói cước, sử dụng nhiều phần mềm, mỗi phần mềm có thể được xác định bằng 1 hoặc nhiều domain hoặc domain/folder
Đây là một thay đổi lớn về mặt kiến trúc. Bạn đang chuyển từ mô hình "Đơn gói" (Simple SaaS) sang mô hình "Đa gói & Đa kênh phân phối" (Complex Enterprise SaaS).
Mô hình này thường thấy ở các hệ thống lớn như Zoho, Atlassian, hay Microsoft 365 (Một Tenant mua gói Office, mua thêm gói Visio, mỗi cái chạy domain riêng hoặc chung).
Dưới đây là thiết kế chi tiết CSDL trên YugabyteDB để giải quyết 2 bài toán: Đa gói cước và Định tuyến Domain động.
1. Phân tích mô hình thực thể (ERD)
Chúng ta cần tái cấu trúc lại như sau:
tenants: Chỉ giữ thông tin định danh (Identity). Bỏ các cột subscription_end_at, current_tier (vì 1 tenant giờ có nhiều gói).
tenant_subscriptions: Bảng mới. Lưu danh sách các gói mà tenant đã mua (1 Tenant - N Subscriptions).
tenant_app_routes: Bảng mới. Quản lý việc định tuyến Domain/Folder vào từng ứng dụng cụ thể.
2. Chi tiết thiết kế các bảng (DDL SQL)
Bước 1: Cập nhật bảng tenants (Clean up)
Chúng ta cần loại bỏ các trường "đơn trị" liên quan đến gói cước cũ.
SQL
-- Xóa các cột cũ không còn phù hợp với logic đa gói
ALTER TABLE tenants
DROP COLUMN current_tier_code,
DROP COLUMN subscription_end_at;
-- active_apps vẫn có thể giữ để cache nhanh danh sách app đang có,
-- nhưng source of truth sẽ nằm ở bảng subscriptions.
Bước 2: Tạo bảng tenant_subscriptions (Quản lý mua hàng)
Lưu trữ việc: Tenant A mua Gói B, hạn dùng từ ngày X đến ngày Y.
SQL
CREATE TABLE tenant_subscriptions (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Gói dịch vụ nào?
package_code VARCHAR(50) NOT NULL, -- VD: 'HRM_PRO', 'OFFICE_365'
-- Danh sách App mà gói này cung cấp (Snapshot lúc mua)
granted_apps TEXT[], -- VD: ['HRM', 'CHAT']
-- Thời hạn của riêng gói này
start_at TIMESTAMPTZ NOT NULL,
end_at TIMESTAMPTZ, -- Null = Vĩnh viễn
status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, EXPIRED, CANCELLED
created_at TIMESTAMPTZ DEFAULT NOW(),
-- Ràng buộc
CONSTRAINT fk_subs_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
CONSTRAINT chk_subs_status CHECK (status IN ('ACTIVE', 'EXPIRED', 'CANCELLED', 'FUTURE'))
);
-- Index: Tìm tất cả gói đang Active của 1 tenant (Để tính tổng quyền lợi)
CREATE INDEX idx_subs_tenant_active
ON tenant_subscriptions (tenant_id)
WHERE status = 'ACTIVE';
Bước 3: Tạo bảng tenant_app_routes (Quản lý Domain/Path - QUAN TRỌNG)
Đây là bảng giải quyết yêu cầu: "Mỗi phần mềm xác định bằng 1 hoặc nhiều domain/folder".
Logic định tuyến:
hrm.fpt.com -> Vào App HRM (Domain based)
portal.fpt.com/hrm -> Vào App HRM (Path based)
fpt.saas.com -> Vào Dashboard chung (Subdomain mặc định)
SQL
CREATE TABLE tenant_app_routes (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Định tuyến vào ứng dụng nào?
app_code VARCHAR(50) NOT NULL, -- VD: 'HRM_APP', 'CRM_APP', 'PORTAL'
-- Cấu hình Domain & Path
domain VARCHAR(255) NOT NULL, -- VD: 'hrm.fpt.com' hoặc 'fpt.saas.com'
path_prefix VARCHAR(100) NOT NULL DEFAULT '/', -- VD: '/' hoặc '/hrm'
-- Cấu hình kỹ thuật
is_primary BOOLEAN DEFAULT FALSE, -- Domain chính (Canonical URL)
is_custom_domain BOOLEAN DEFAULT FALSE, -- True: Domain riêng khách mua, False: Subdomain của hệ thống
ssl_status VARCHAR(20) DEFAULT 'PENDING', -- PROVISIONING, ACTIVE, EXPIRED (Cho custom domain)
created_at TIMESTAMPTZ DEFAULT NOW(),
updated_at TIMESTAMPTZ DEFAULT NOW(),
-- Ràng buộc
CONSTRAINT fk_routes_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
-- [QUAN TRỌNG] Một cặp Domain + Path chỉ được trỏ về duy nhất 1 nơi trên toàn hệ thống
-- Tránh việc Tenant A cấu hình 'abc.com' và Tenant B cũng cấu hình 'abc.com'
CONSTRAINT uq_domain_path UNIQUE (domain, path_prefix)
);
-- Index phục vụ Router (API Gateway tra cứu cực nhanh)
-- Query: SELECT * FROM routes WHERE domain = 'host' AND path_prefix = 'path'
CREATE INDEX idx_routes_lookup
ON tenant_app_routes (domain, path_prefix);
3. Ví dụ dữ liệu thực tế (Data Scenario)
Hãy hình dung Công ty ABC (Tenant) có kịch bản sau:
Mua gói Base (Chứa App Dashboard).
Mua gói HRM Pro (Chứa App HRM).
Cấu hình domain riêng cho HRM.
Dữ liệu bảng tenant_subscriptions: | tenant_id | package_code | granted_apps | status | |:---|:---|:---|:---| | uuid_abc | BASE_PLAN | ['DASHBOARD'] | ACTIVE | | uuid_abc | HRM_PRO | ['HRM_APP'] | ACTIVE |
Dữ liệu bảng tenant_app_routes (Routing Table): | tenant_id | app_code | domain | path_prefix | is_custom | Mô tả | |:---|:---|:---|:---|:---|:---| | uuid_abc | DASHBOARD| abc.saas.com| / | FALSE | Mặc định hệ thống | | uuid_abc | HRM_APP | abc.saas.com| /hrm | FALSE | Chạy folder trên domain gốc | | uuid_abc | HRM_APP | hr.congty-abc.com| / | TRUE | Domain riêng cho HRM |
4. Luồng xử lý kỹ thuật (Flow)
Khi một request bay vào hệ thống, API Gateway / Reverse Proxy sẽ hoạt động như sau:
Nhận Request: GET https://hr.congty-abc.com/api/employees
Phân tích:
Host: hr.congty-abc.com
Path: / (Root prefix)
Tra cứu DB (hoặc Cache Redis):
Query tenant_app_routes: Tìm bản ghi khớp Host & Path.
-> Kết quả: tenant_id = uuid_abc, app_code = 'HRM_APP'.
Kiểm tra quyền hạn (Subcription Check):
Query tenant_subscriptions: tenant_id = uuid_abc có gói nào chứa HRM_APP và đang ACTIVE không?
-> Kết quả: Có (Gói HRM_PRO).
Forward: Chuyển request đến Service HRM.
5. Lưu ý quan trọng cho phần "Domain/Folder"
Xung đột Path:
Nếu bạn cho phép cấu hình folder (/hrm), bạn phải chặn các folder trùng với các file hệ thống (ví dụ không cho đặt /api, /static, /admin).
Wildcard Subdomain:
Index (domain, path_prefix) trong YugabyteDB hoạt động rất nhanh với exact match.
Tuy nhiên, nên cache bảng tenant_app_routes này vào Redis dưới dạng Hash Map để routing đạt tốc độ micro-seconds.
SSL cho Custom Domain:
Khi user add domain hr.congty-abc.com, hệ thống phải tự động trigger quy trình cấp chứng chỉ SSL (Let's Encrypt). Trường ssl_status dùng để theo dõi quá trình này.
Thiết kế này đáp ứng hoàn hảo nhu cầu: Một khách hàng dùng nhiều gói, chạy nhiều app, và mỗi app có thể xuất hiện dưới nhiều bộ mặt (URL) khác nhau.
mỗi gói phần mềm có thể gồm nhiều ứng dụng
Việc "Một gói cước (Package) chứa nhiều Ứng dụng (Apps)" là mô hình bán hàng dạng Bundle (Combo). Ví dụ điển hình: Google Workspace (Mua 1 gói được cả Gmail, Drive, Meet, Calendar).
Để giải quyết bài toán này trong YugabyteDB mà vẫn đảm bảo hiệu năng cao khi kiểm tra quyền, chúng ta cần cập nhật thiết kế của bảng service_packages (Danh mục gói) và tenant_subscriptions (Chi tiết mua).
Dưới đây là thiết kế chi tiết:
1. Phân tích mô hình
Chúng ta sẽ không dùng mô hình quan hệ thuần túy (tách bảng con subscription_items) vì việc JOIN liên tục sẽ làm chậm hệ thống check quyền. Thay vào đó, chúng ta tận dụng sức mạnh JSONB của YugabyteDB/PostgreSQL để lưu cấu trúc lồng nhau.
Service Package (Catalog): Định nghĩa 1 gói "Business" bao gồm: HRM (limit 50 user) + CRM (limit 1000 khách).
Tenant Subscription (Instance): Tenant A mua gói "Business". Ta snapshot toàn bộ thông tin trên vào bảng này.
2. Chi tiết DDL SQL (YugabyteDB)
Bảng A: service_packages (Danh mục gói - Master Data)
Bảng này do System Admin quản lý, định nghĩa ra các Combo bán hàng.
SQL
CREATE TABLE service_packages (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
code VARCHAR(50) NOT NULL, -- VD: 'ENTERPRISE_COMBO'
name TEXT NOT NULL,
price_monthly NUMERIC(19, 4) NOT NULL,
-- [QUAN TRỌNG] Định nghĩa gói này chứa những App nào và giới hạn mặc định ra sao
-- Dạng JSONB Array:
-- [
-- { "app_code": "HRM", "is_mandatory": true, "default_limits": {"users": 50} },
-- { "app_code": "CRM", "is_mandatory": false, "default_limits": {"leads": 1000} }
-- ]
included_apps_config JSONB NOT NULL,
status VARCHAR(20) DEFAULT 'ACTIVE',
CONSTRAINT uq_pkg_code UNIQUE (code)
);
Bảng B: tenant_subscriptions (Chi tiết mua - Transaction Data)
Đây là bảng quan trọng nhất. Khi user mua gói, ta copy cấu hình từ service_packages sang đây để chốt quyền lợi (Snapshot).
SQL
CREATE TABLE tenant_subscriptions (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Tham chiếu lỏng tới gói gốc (để report doanh thu)
package_code VARCHAR(50) NOT NULL,
-- [QUAN TRỌNG] Danh sách chi tiết các App ĐƯỢC CẤP trong lần mua này
-- Tại sao dùng JSONB? Vì mỗi App có thể có status và config riêng biệt trong cùng 1 gói.
-- Structure:
-- {
-- "HRM": { "status": "ACTIVE", "limits": {"users": 50}, "expiry_override": null },
-- "CRM": { "status": "ACTIVE", "limits": {"leads": 1000}, "expiry_override": "2024-12-31" }
-- }
granted_apps_details JSONB NOT NULL,
-- Cột phụ trợ để Index GIN (Tìm kiếm nhanh: Gói này chứa app nào?)
-- VD: ['HRM', 'CRM']
granted_app_codes TEXT[] GENERATED ALWAYS AS (
ARRAY(SELECT jsonb_object_keys(granted_apps_details))
) STORED,
-- Thời hạn chung của cả gói
start_at TIMESTAMPTZ NOT NULL,
end_at TIMESTAMPTZ,
status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
CONSTRAINT fk_subs_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-- Index GIN để tìm nhanh: "Tenant này có quyền dùng App HRM không?"
-- Query: WHERE tenant_id = '...' AND granted_app_codes @> ARRAY['HRM']
CREATE INDEX idx_subs_apps ON tenant_subscriptions USING GIN (granted_app_codes);
3. Quy trình Kiểm tra quyền (Routing Flow)
Kết hợp với bảng tenant_app_routes (bảng định tuyến domain/folder) đã thiết kế ở câu trước, đây là luồng xử lý đầy đủ khi Request đi vào:
Giả sử:
Tenant mua gói ENTERPRISE_COMBO (Gồm HRM và CRM).
Tenant cấu hình domain hr.fpt.com trỏ vào app HRM.
Bước 1: Router (Xác định App)
User truy cập: https://hr.fpt.com/dashboard
Hệ thống query bảng tenant_app_routes:
WHERE domain = 'hr.fpt.com'
=> Kết quả: tenant_id = 'uuid-fpt', app_code = 'HRM'.
Bước 2: Gatekeeper (Xác định Quyền trong Gói)
Hệ thống query bảng tenant_subscriptions:
Tìm subscription của uuid-fpt đang ACTIVE.
VÀ chứa app HRM.
Câu SQL (YugabyteDB):
SQL
SELECT granted_apps_details->'HRM' as app_config
FROM tenant_subscriptions
WHERE tenant_id = 'uuid-fpt'
AND status = 'ACTIVE'
AND granted_app_codes @> ARRAY['HRM'] -- Check mảng cực nhanh nhờ GIN Index
LIMIT 1;
Bước 3: Enforcer (Kiểm tra sâu)
Từ kết quả JSONB app_config lấy được:
Check status: Có bị DISABLED riêng app này không?
Check limits: Số user hiện tại có vượt quá 50 không?
4. Tại sao thiết kế này tối ưu?
Hỗ trợ "Bán Bia kèm Lạc":
Bạn có thể bán gói "CRM Pro" (Gói chính) tặng kèm "Chat Basic" (App phụ).
Trong granted_apps_details, App CRM có limit cao, App Chat có limit thấp. Tất cả nằm gọn trong 1 dòng dữ liệu.
Linh hoạt tắt/bật từng phần:
Nếu khách hàng vi phạm chính sách của App Chat, bạn có thể update JSONB để set status của Chat thành SUSPENDED mà vẫn để họ dùng CRM bình thường. (Nếu dùng bảng đơn giản thì phải khóa cả gói).
Hiệu năng cao:
Chỉ cần 1 câu Query vào bảng tenant_subscriptions là lấy được toàn bộ cấu hình, hạn mức của tất cả các app trong gói đó. Không cần JOIN qua bảng trung gian.
5. Data Dictionary (Bổ sung bảng service_packages)
Tên trường Kiểu dữ liệu Mô tả
_id UUID PK
code VARCHAR Mã gói (Unique). VD: STARTER_PACK
included_apps_config JSONB
Cấu hình mẫu các app trong gói.
VD: [{"code": "HRM", "quota": 10}, {"code": "MAIL", "quota": 5GB}]
price_monthly NUMERIC Giá niêm yết
status VARCHAR ACTIVE / ARCHIVED (Gói cũ không bán nữa nhưng tenant cũ vẫn dùng)
các bảng như tenant_app_routes có nên lưu MongoDB không?
Câu trả lời ngắn gọn: KHÔNG NÊN. Bạn nên giữ bảng này ở YugabyteDB.
Mặc dù MongoDB đọc rất nhanh, nhưng bảng tenant_app_routes có đặc thù là Dữ liệu Hạ tầng (Infrastructure Data) đòi hỏi tính nhất quán tuyệt đối, không phải là dữ liệu lỏng lẻo (Document Data).
Dưới đây là phân tích tại sao YugabyteDB thắng thế trong trường hợp này, và cách tối ưu hiệu năng "đỉnh cao" cho Routing.
1. Tại sao KHÔNG NÊN dùng MongoDB cho tenant_app_routes?
Lý do A: Ràng buộc Duy nhất Toàn cục (Global Uniqueness)
Đây là yếu tố sống còn.
Bài toán: Domain hr.fpt.com chỉ được phép trỏ về duy nhất 1 Tenant. Nếu hệ thống cho phép 2 Tenant cùng đăng ký domain này, Routing sẽ bị loạn (Race Condition).
YugabyteDB (SQL): Ràng buộc CONSTRAINT uq_domain_path UNIQUE (domain, path) được đảm bảo tuyệt đối bởi cơ chế ACID. Dù 2 người cùng bấm Save 1 lúc, DB sẽ chặn 1 người lại.
MongoDB: Có Unique Index, nhưng trong môi trường phân tán (Sharding), việc đảm bảo Unique Index đôi khi phức tạp hơn và MongoDB thiên về "Eventual Consistency" (Tính nhất quán cuối cùng) hơn là "Strong Consistency" (Nhất quán mạnh) trong một số cấu hình mặc định.
Lý do B: Tính Quan hệ (Relational Integrity)
Bảng Router "chết chùm" với bảng tenants và tenant_subscriptions.
Nếu bạn xóa Tenant ở YugabyteDB mà quên xóa Route ở MongoDB (do không có Foreign Key cứng), hệ thống sẽ bị "Route ma" (Domain vẫn chạy nhưng trỏ vào hư vô). YugabyteDB dùng FOREIGN KEY ... ON DELETE CASCADE giải quyết việc này triệt để.
Lý do C: Tần suất Ghi thấp - Đọc cao
Bảng này rất ít khi thay đổi (chỉ khi Tenant mua thêm gói hoặc đổi domain). Nó không cần sự linh hoạt (Schema-less) của MongoDB. Cấu trúc của nó rất cứng (domain, path, target).
2. Giải pháp Hiệu năng: Mô hình "Database làm Kho - Redis làm Súng"
Vấn đề bạn lo ngại là đúng: "Mỗi request đều phải query DB để tìm đường đi thì có chậm không?" -> Chắc chắn chậm (dù là Mongo hay Yugabyte). Độ trễ DB thường là 1-10ms. Với Routing, ta cần dưới 0.5ms.
Kiến trúc chuẩn cho tenant_app_routes:
Lưu trữ (Persistence): Dùng YugabyteDB.
Để đảm bảo toàn vẹn dữ liệu, Admin quản lý dễ dàng, backup an toàn.
Vận hành (Runtime): Dùng Redis.
Đẩy toàn bộ bảng routing lên RAM của Redis.
Thiết kế chi tiết trên Redis
Khi Tenant cấu hình xong Domain trong YugabyteDB, Backend sẽ bắn 1 lệnh đồng bộ sang Redis.
Cấu trúc dữ liệu Redis (Hash Map): Chúng ta sẽ dùng key là Domain, value là thông tin định tuyến.
Key: router:domains (Hash)
Field: hr.fpt.com/ (Domain + Path)
Value: (JSON String)
JSON
{
"tenant_id": "uuid-fpt",
"app_code": "HRM",
"status": "ACTIVE"
}
Logic tại API Gateway (Nginx / Kong / Go Fiber):
Go
// Code giả lập logic Routing cực nhanh
func RouteRequest(domain string, path string) Target {
// 1. Hỏi Redis trước (Mất 0.2ms)
val, err := redisClient.HGet("router:domains", domain + path).Result()
if err == nil {
return Parse(val) // Hit Cache -> Đi tiếp
}
// 2. Nếu Redis không có (Cache Miss), mới hỏi YugabyteDB (Mất 5ms)
// Đây là trường hợp hiếm, chỉ xảy ra khi vừa khởi động lại Redis
route := yugabyteRepo.FindRoute(domain, path)
// 3. Cache ngược lại vào Redis để lần sau nhanh hơn
redisClient.HSet("router:domains", domain + path, ToJSON(route))
return route
}
3. Khi nào thì NÊN dùng MongoDB cho Routing?
Chỉ có 1 trường hợp duy nhất bạn dùng MongoDB cho bảng này: Wildcard Routing phức tạp.
Ví dụ: Bạn cho phép user định nghĩa luật Regex:
*.dev.fpt.com -> Vào môi trường Dev.
user-*.store.com -> Vào trang cá nhân user.
SQL query LIKE hoặc Regex rất chậm. Khi đó, MongoDB với khả năng query linh hoạt hơn (hoặc Elasticsearch) mới được cân nhắc. Nhưng với SaaS B2B tiêu chuẩn (Domain cụ thể), YugabyteDB + Redis là vô địch.
Tổng kết
Tính năng Lưu ở đâu? Tại sao?
Dữ liệu gốc (Master Data) YugabyteDB Cần Constraint UNIQUE, Foreign Key an toàn.
Tra cứu thời gian thực (Runtime) Redis Cần tốc độ micro-seconds cho mỗi Request.
MongoDB Không dùng Không giải quyết được bài toán tốc độ (thua Redis) lẫn an toàn (thua Yugabyte).
liệt kê các bảng theo kiến trúc trên (dưới dạng bảng)
Dưới đây là bảng tổng hợp toàn bộ các bảng/collection trong kiến trúc hệ thống SaaS của bạn, được phân loại theo Cơ sở dữ liệu để dễ quản lý.
BẢNG TỔNG HỢP CẤU TRÚC DỮ LIỆU (DATABASE SCHEMA MATRIX)
STT Tên Bảng / Collection CSDL lưu trữ Loại dữ liệu chính Mục đích & Vai trò trong hệ thống
I CORE & IDENTITY (HẠ TẦNG & ĐỊNH DANH)
1 tenants YugabyteDB SQL (Structured) Trái tim hệ thống. Lưu thông tin khách hàng, định danh (_id, code), ràng buộc vùng (data_region) và cấu hình gốc.
2 users YugabyteDB SQL (Structured) Lưu thông tin đăng nhập, mật khẩu (hash), thông tin cá nhân. Liên kết với Tenant.
3 tenant_app_routes YugabyteDB SQL (Structured) Bản đồ định tuyến. Quy định domain/path nào (hr.abc.com) trỏ vào Tenant nào và App nào. Cache lên Redis.
II BILLING & SUBSCRIPTION (GÓI CƯỚC & QUYỀN HẠN)
4 service_packages YugabyteDB SQL + JSONB Menu bán hàng. Định nghĩa các gói combo (VD: Gói Enterprise gồm HRM + CRM). Lưu cấu hình mẫu trong JSONB.
5 tenant_subscriptions YugabyteDB SQL + JSONB Hợp đồng mua bán. Snapshot quyền hạn thực tế của Tenant. Chứa chi tiết hạn mức (Quota) của từng App trong cột JSONB.
6 invoices YugabyteDB SQL (Structured) Lưu lịch sử hóa đơn, số tiền thanh toán (Dùng NUMERIC), trạng thái thanh toán.
III DYNAMIC CONFIGURATION (CẤU HÌNH ĐỘNG)
7 tenant_app_configs MongoDB Document (BSON) Cấu hình giao diện/Logic. Lưu setting riêng của từng App cho từng Tenant (VD: Màu sắc, Logo, Workflow duyệt). Schema tự do.
8 custom_fields MongoDB Document (BSON) Định nghĩa các trường dữ liệu mở rộng mà Tenant tự thêm vào các form (VD: Form nhân viên thêm trường "Nhóm máu").
IV LOGGING & ANALYTICS (DỮ LIỆU LỚN)
9 audit_logs ClickHouse Columnar Nhật ký hệ thống. Lưu vết ai làm gì, lúc nào (DateTime64). Dùng để tra soát bảo mật và tuân thủ (Compliance).
10 api_usage_logs ClickHouse Columnar Log sử dụng. Đếm số request, dung lượng bandwidth. Dùng để tính tiền (Billing) hoặc giới hạn (Rate Limit).
11 http_events ClickHouse Columnar Lưu raw request/response để debug lỗi hoặc phân tích hiệu năng hệ thống.
MÔ TẢ CHI TIẾT CÁC CỘT QUAN TRỌNG (KEY COLUMNS)
Để bạn dễ hình dung sự liên kết (Relationship):
1. Nhóm YugabyteDB (Quan hệ chặt chẽ - SQL)
Tên Bảng Primary Key (PK) Foreign Key (FK) / Quan hệ Cột đặc biệt cần chú ý
tenants _id (UUID) Owner -> users._id data_region, active_apps (Array)
users _id (UUID) Thuộc về -> tenants._id password_hash, email_hash (PII)
tenant_app_routes _id (UUID) Trỏ về -> tenants._id Constraint UNIQUE(domain, path)
service_packages _id (UUID) (Master Data - Độc lập) included_apps_config (JSONB)
tenant_subscriptions _id (UUID) Trỏ về -> tenants._id granted_apps_details (JSONB)
2. Nhóm MongoDB (Liên kết lỏng - Schema-less)
Tên Collection Primary Key Shard Key (Phân tán) Ghi chú thiết kế
tenant_app_configs _id (ObjectId) tenant_id Trường config là Object tự do. Query: { tenant_id: "...", app_code: "HRM" }
custom_fields _id (ObjectId) tenant_id Lưu định nghĩa metadata của form động.
3. Nhóm ClickHouse (Phân tích - No update)
Tên Bảng Sorting Key (Thay cho Index) Partition Key Ghi chú thiết kế
audit_logs (tenant_id, created_at) toYYYYMM(created_at) Tối ưu cho query: "Lấy log của Tenant A trong tháng 12".
api_usage_logs (tenant_id, app_code, time) toYYYYMMDD(time) Tối ưu tính tổng: SUM(request_count).
SƠ ĐỒ QUAN HỆ (TEXT DIAGRAM)
Đoạn mã
graph TD
%% YugabyteDB Nodes
T[Tenants (Yuga)] -->|1-N| U[Users (Yuga)]
T -->|1-N| R[Routes (Yuga)]
T -->|1-N| S[Subscriptions (Yuga)]
P[Service Packages (Yuga)] -.->|Copy Config| S
%% MongoDB Nodes
T -.->|Ref ID| C[App Configs (Mongo)]
%% ClickHouse Nodes
T -.->|Log ID| L[Audit Logs (ClickHouse)]
%% Redis Cache Layer
R -.->|Cache| RC(Redis: Router Map)
S -.->|Cache| RC2(Redis: Permissions)
Ghi chú triển khai:
Mũi tên liền (-->): Quan hệ khóa ngoại cứng (Foreign Key Constraint) trong YugabyteDB. Xóa cha là con mất (Cascade) hoặc bị chặn.
Mũi tên đứt (-.->): Quan hệ logic (Logical Reference). Application Code phải tự quản lý việc map ID giữa các loại DB khác nhau.
kẻ lại bảng tenants với các cột Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra,Mô tả
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) cho bảng tenants trong YugabyteDB.
Phiên bản này đã được cập nhật theo kiến trúc Đa gói cước (Multi-subscription) mà chúng ta vừa thảo luận:
Loại bỏ các trường current_tier_code, subscription_end_at (Vì thông tin này đã chuyển sang bảng tenant_subscriptions).
Giữ lại active_apps làm Cache.
Giữ lại status để kiểm soát quyền truy cập cấp cao nhất.
Data Dictionary: Bảng tenants
Tên trường (Field) Kiểu dữ liệu Null? Mặc định (Default) Ràng buộc (Constraints) & Logic Kiểm tra Mô tả (Description)
I. HẠ TẦNG & ĐỊNH DANH
_id UUID NO gen_random_uuid() PRIMARY KEY Định danh duy nhất toàn cục. Dùng làm Partition Key nếu bật Sharding.
data_region VARCHAR(50) NO 'ap-southeast-1' CHECK: IN ('ap-southeast-1', 'us-east-1', ...) Vị trí dữ liệu. Quy định dữ liệu nằm ở server quốc gia nào (Geo-Partitioning).
code VARCHAR(64) NO -
UNIQUE
CHECK: code ~ '^[a-z0-9-]+$'
Slug Subdomain. Chỉ chứa chữ thường, số, gạch ngang. Dùng để định tuyến URL.
compliance_level VARCHAR(20) NO 'STANDARD' CHECK: IN ('STANDARD', 'GDPR', 'HIPAA') Mức tuân thủ. Quyết định quy trình log và xóa dữ liệu (VD: GDPR xóa vĩnh viễn).
II. THÔNG TIN CƠ BẢN
name TEXT NO - CHECK: LENGTH(name) > 0 Tên hiển thị chính thức của tổ chức/công ty.
description TEXT YES NULL - Mô tả ngắn gọn về hoạt động kinh doanh (Profile).
logo_url TEXT YES NULL CHECK: logo_url ~ '^https?://' URL ảnh Logo (Dùng TEXT để hỗ trợ Presigned URL dài).
website_url TEXT YES NULL CHECK: website_url ~ '^https?://' Trang chủ website của khách hàng.
III. ĐỊA PHƯƠNG HÓA
timezone VARCHAR(50) NO 'UTC' - Múi giờ. Dùng để tính toán ngày giờ trong báo cáo và workflow.
locale VARCHAR(10) NO 'vi-VN' - Ngôn ngữ và định dạng số/ngày tháng mặc định.
currency_code VARCHAR(3) NO 'VND' CHECK: LENGTH(currency_code) = 3 Mã tiền tệ mặc định (ISO 4217) cho báo cáo nội bộ.
IV. TRẠNG THÁI & CACHE
status VARCHAR(20) NO 'TRIAL' CHECK: IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED') Trạng thái Master. Nếu SUSPENDED, chặn đăng nhập toàn bộ user dù gói cước còn hạn.
active_apps TEXT[] YES NULL - Cache danh sách App. Mảng chứa mã các App mà tenant có quyền truy cập từ bất kỳ gói nào.
V. QUẢN TRỊ & LIÊN HỆ
owner_id UUID YES NULL FK: REFERENCES users(_id) Tài khoản Super Admin sở hữu Tenant này.
contact_email TEXT YES NULL CHECK: contact_email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$' Email nhận hóa đơn và thông báo hệ thống quan trọng.
contact_phone VARCHAR(20) YES NULL - Số điện thoại liên hệ đại diện.
VI. AUDIT & VERSIONING
created_at TIMESTAMPTZ NO NOW() - Thời điểm tạo bản ghi.
created_by UUID YES NULL FK: REFERENCES users(_id) User thực hiện tạo.
updated_at TIMESTAMPTZ NO NOW() CHECK: updated_at >= created_at Thời điểm cập nhật cuối cùng.
updated_by UUID YES NULL FK: REFERENCES users(_id) User thực hiện cập nhật cuối cùng.
deleted_at TIMESTAMPTZ YES NULL - Soft Delete. Nếu khác NULL nghĩa là Tenant đã bị xóa.
version BIGINT NO 1 CHECK: version >= 1 Optimistic Lock. Dùng để ngăn chặn ghi đè dữ liệu đồng thời.
Lưu ý kỹ thuật khi triển khai (Implementation Notes)
Tại sao bỏ subscription_end_at?
Do bạn đã chuyển sang mô hình "Một tenant mua nhiều gói", nên ngày hết hạn nằm ở bảng con tenant_subscriptions. Bảng tenants chỉ giữ status để làm cái "cầu dao tổng" (Master Switch).
Logic của cột active_apps (Computed Cache):
Đây là cột Dư thừa có chủ đích (Denormalization).
Nghiệp vụ: Khi Tenant mua gói mới hoặc gói cũ hết hạn bên bảng tenant_subscriptions, Backend phải có một trigger (hoặc logic code) để tính toán lại danh sách tất cả các App còn hạn dùng và update vào cột này.
Mục đích: Giúp API Gateway kiểm tra nhanh: "Tenant này có được vào App HRM không?" bằng query WHERE 'HRM' = ANY(active_apps) mà không cần join bảng.
Indexing:
Đừng quên tạo GIN Index cho cột active_apps để query mảng đạt tốc độ tối đa.
có nên tách các thông tin bổ sung của tenants ra bảng khác?
Câu trả lời ngắn gọn: KHÔNG NÊN tách ra bảng riêng (1-1) trừ khi bạn có lý do cực kỳ đặc biệt về bảo mật.
Trong kiến trúc Distributed SQL (như YugabyteDB) và RDBMS hiện đại (PostgreSQL), việc tách bảng theo kiểu tenants và tenant_infos (quan hệ 1-1) thường mang lại nhiều tác hại hơn là lợi ích.
Dưới đây là phân tích chi tiết và giải pháp tối ưu nhất cho bạn:
1. Tại sao KHÔNG NÊN tách bảng 1-1 (tenant_details)?
Nhiều lập trình viên có thói quen tách bảng để "nhìn cho gọn", ví dụ:
Bảng tenants: Chỉ lưu _id, code, name.
Bảng tenant_profiles: Lưu address, description, website, tax_id...
Nhược điểm chết người trong YugabyteDB/Postgres:
Hiệu năng JOIN (Distributed JOIN overhead): Trong database phân tán, dữ liệu của bảng tenants và tenant_profiles có thể nằm ở 2 node (server) khác nhau. Mỗi lần bạn muốn lấy thông tin đầy đủ của khách hàng, DB phải thực hiện Network Call để ghép 2 bảng này lại. Điều này làm tăng độ trễ (Latency).
Phức tạp hóa Code: Mỗi lần Insert/Update, bạn phải bọc trong Transaction để đảm bảo ghi cả 2 bảng thành công. Nếu code lỗi, dữ liệu bị lệch.
Postgres TOAST lo được hết: Bạn sợ lưu text dài (description) làm chậm query? Postgres có cơ chế TOAST. Nó tự động lưu các chuỗi văn bản lớn ra vùng nhớ riêng. Khi bạn SELECT *, nếu không cần dùng đến cột đó, nó không hề tốn RAM để load lên.
2. Giải pháp Tối ưu: Gom nhóm vào JSONB
Thay vì tạo bảng mới hoặc tạo quá nhiều cột rời rạc (facebook_url, linkedin_url, twitter_url...), hãy sử dụng cột JSONB.
Chúng ta sẽ chia dữ liệu Tenant làm 2 loại:
Core Data (Cột cứng): Dữ liệu dùng để Logic, Search, Filter, Billing (Email, Phone, Status, Region).
Metadata/Profile (Cột JSONB): Dữ liệu chỉ dùng để hiển thị (UI), ít khi query lọc (Mô tả, Logo, Mạng xã hội, Sở thích).
Thiết kế lại bảng tenants (Tối ưu):
SQL
CREATE TABLE tenants (
-- 1. Core Data (Giữ nguyên các cột quan trọng)
_id UUID PRIMARY KEY,
name TEXT NOT NULL,
status VARCHAR(20),
contact_email TEXT, -- Giữ ở ngoài để gửi mail cho dễ
-- 2. Thay vì tạo cột rời: description, website, founded_year...
-- Hãy gom hết vào 1 cột duy nhất:
profile JSONB DEFAULT '{}'
);
Dữ liệu mẫu trong cột profile:
JSON
{
"description": "Công ty công nghệ hàng đầu...",
"website": "https://fpt.com",
"logo_url": "https://s3...",
"socials": {
"facebook": "fb.com/fpt",
"linkedin": "linkedin.com/company/fpt"
},
"tax_info": {
"tax_code": "0101234567",
"address": "Duy Tân, Hà Nội"
}
}
Lợi ích:
Schema linh hoạt: Khách hàng A có Facebook, Khách hàng B có TikTok. Bạn không cần ALTER TABLE thêm cột.
Hiệu năng: Đọc 1 dòng là có hết dữ liệu (Single seek), không cần JOIN.
YugabyteDB hỗ trợ JSONB cực tốt: Bạn vẫn có thể query vào sâu bên trong JSON nếu cần.
3. Khi nào thì BẮT BUỘC phải tách bảng?
Chỉ tách bảng khi mối quan hệ là 1-N (Một - Nhiều).
Ví dụ: Địa chỉ văn phòng (Office Locations). Một Tenant có thể có trụ sở chính ở Hà Nội, chi nhánh ở TP.HCM và Đà Nẵng. Lúc này bạn không thể lưu trong cột address của bảng tenants được.
Giải pháp: Tạo bảng tenant_locations.
SQL
CREATE TABLE tenant_locations (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL, -- FK
name VARCHAR(100), -- VD: "Trụ sở chính", "Kho A"
address_line TEXT,
city VARCHAR(50),
country VARCHAR(50),
is_primary BOOLEAN DEFAULT FALSE, -- Địa chỉ mặc định
CONSTRAINT fk_loc_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
4. Tổng kết chiến lược thiết kế
Hãy dùng bảng quyết định này (Decision Matrix) để xử lý các thông tin bổ sung:
Loại thông tin bổ sung Đặc điểm Giải pháp thiết kế
Email, Phone, Status Dùng để Logic, Login, Filter liên tục. Cột riêng (Column) trong tenants.
Mô tả, Website, Logo Dùng để hiển thị (View), ít khi Filter. Gom vào profile (JSONB) trong tenants.
Mạng xã hội (FB, LinkedIn) Số lượng không cố định, tùy biến cao. Gom vào profile (JSONB).
Mã số thuế, Đại diện pháp luật Thông tin nhạy cảm, ít thay đổi. Gom vào profile (JSONB) hoặc billing_info (JSONB).
Địa chỉ văn phòng Có thể có nhiều hơn 1 địa chỉ. Tách bảng riêng tenant_locations (1-N).
Người liên hệ (Contacts) Có nhiều người (Kế toán, IT, Giám đốc). Tách bảng riêng tenant_contacts (1-N).
Lời khuyên: Với thiết kế hiện tại của bạn, hãy thêm cột profile JSONB vào bảng tenants và xóa các cột description, website_url, logo_url đi. Bảng sẽ gọn gàng và chuyên nghiệp hơn rất nhiều.
kẻ lại bảng tenants với các cột Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra,Mô tả
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) cho bảng tenants trong YugabyteDB.
Phiên bản này là phiên bản Tối ưu hóa (Optimized):
Gom nhóm Metadata: Sử dụng cột profile (JSONB) để chứa các thông tin phụ (Mô tả, Website, Logo, Socials) giúp bảng gọn gàng và tránh phải sửa cấu trúc bảng (ALTER TABLE) khi thêm trường phụ.
Đa gói cước: Loại bỏ các trường hạn sử dụng, chuyển logic đó sang bảng tenant_subscriptions.
Data Dictionary: Bảng tenants
Tên trường (Field) Kiểu dữ liệu (Type) Null? Mặc định (Default) Ràng buộc (Constraints) & Logic Kiểm tra Mô tả (Description)
I. HẠ TẦNG & ĐỊNH DANH
_id UUID NO gen_random_uuid() PRIMARY KEY Định danh duy nhất toàn cục (Global ID). Dùng làm Partition Key nếu cấu hình Sharding.
data_region VARCHAR(50) NO 'ap-southeast-1' CHECK: IN ('ap-southeast-1', 'us-east-1', ...) Vị trí dữ liệu. Quy định dữ liệu nằm ở server quốc gia nào (Geo-Partitioning).
code VARCHAR(64) NO -
UNIQUE
CHECK: code ~ '^[a-z0-9-]+$'
Slug/Subdomain. Chỉ chứa chữ thường, số, gạch ngang. Dùng định tuyến URL (VD: fpt.app.com).
compliance_level VARCHAR(20) NO 'STANDARD' CHECK: IN ('STANDARD', 'GDPR', 'HIPAA') Mức tuân thủ. Quyết định quy trình bảo mật (VD: GDPR yêu cầu xóa vĩnh viễn dữ liệu).
II. THÔNG TIN CHÍNH & PROFILE
name TEXT NO - CHECK: LENGTH(name) > 0 Tên hiển thị chính thức của tổ chức/công ty.
profile JSONB NO '{}' - Thông tin bổ sung. Chứa: Logo, Website, Mô tả, Mạng xã hội... giúp schema linh hoạt.
contact_email TEXT YES NULL CHECK: Regex Email hợp lệ Email nhận hóa đơn và thông báo hệ thống quan trọng (Billing Email).
contact_phone VARCHAR(20) YES NULL - Số điện thoại người đại diện.
III. ĐỊA PHƯƠNG HÓA
timezone VARCHAR(50) NO 'UTC' - Múi giờ. Dùng để tính toán ngày giờ trong báo cáo và workflow.
locale VARCHAR(10) NO 'vi-VN' - Ngôn ngữ và định dạng hiển thị mặc định.
currency_code VARCHAR(3) NO 'VND' CHECK: LENGTH(currency_code) = 3 Mã tiền tệ mặc định (ISO 4217).
IV. TRẠNG THÁI & QUYỀN HẠN
status VARCHAR(20) NO 'TRIAL' CHECK: IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED') Trạng thái Master. Kiểm soát quyền đăng nhập cấp cao nhất.
active_apps TEXT[] YES NULL - Cache danh sách App. Mảng chứa mã App mà tenant được phép dùng từ tất cả các gói đã mua.
V. QUẢN TRỊ & AUDIT
owner_id UUID YES NULL FK: REFERENCES users(_id) Tài khoản Super Admin sở hữu Tenant này.
created_at TIMESTAMPTZ NO NOW() - Thời điểm tạo bản ghi.
created_by UUID YES NULL FK: REFERENCES users(_id) User thực hiện tạo.
updated_at TIMESTAMPTZ NO NOW() CHECK: updated_at >= created_at Thời điểm cập nhật cuối cùng.
updated_by UUID YES NULL FK: REFERENCES users(_id) User thực hiện cập nhật cuối cùng.
deleted_at TIMESTAMPTZ YES NULL - Soft Delete. Nếu khác NULL nghĩa là Tenant đã bị xóa.
version BIGINT NO 1 CHECK: version >= 1 Optimistic Lock. Ngăn chặn ghi đè dữ liệu đồng thời.
Cấu trúc mẫu cho cột profile (JSONB)
Việc gom nhóm vào JSONB giúp bạn không cần sửa DB khi khách hàng muốn thêm "Link TikTok" hay "Mã số thuế".
JSON
{
"description": "Công ty phần mềm số 1...",
"website_url": "https://fpt.com",
"logo_url": "https://s3.aws.com/bucket/logo.png",
"tax_info": {
"tax_code": "0101234567",
"address": "Số 1 Duy Tân, Hà Nội"
},
"socials": {
"facebook": "fb.com/fpt",
"linkedin": "linkedin.com/company/fpt"
}
}
Script SQL cập nhật (Sử dụng JSONB)
SQL
CREATE TABLE tenants (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
code VARCHAR(64) NOT NULL,
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',
name TEXT NOT NULL,
-- Thay vì tạo nhiều cột lẻ, gom vào đây
profile JSONB NOT NULL DEFAULT '{}',
contact_email TEXT,
contact_phone VARCHAR(20),
timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN',
currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
active_apps TEXT[], -- Cache array
owner_id UUID,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
version BIGINT NOT NULL DEFAULT 1,
-- Constraints
CONSTRAINT uq_tenants_code UNIQUE (code),
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED')),
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
CONSTRAINT chk_tenants_code_format CHECK (code ~ '^[a-z0-9-]+$')
);
-- Index cho JSONB (Optional - Nếu bạn cần search theo tax_code trong JSON)
CREATE INDEX idx_tenants_profile ON tenants USING GIN (profile);
có nên thêm trường tổng hợp domains để giúp nhanh chóng xác định được tenants qua domain hoặc domain/folder không?
Câu trả lời là: KHÔNG NÊN.
Bạn không nên thêm một trường tổng hợp (ví dụ: domains JSONB hay domain_list TEXT[]) vào bảng tenants để phục vụ mục đích tra cứu/định tuyến (Routing Lookup).
Dưới đây là phân tích chi tiết tại sao việc này là một thiết kế tồi (Anti-pattern) và giải pháp chuẩn là gì.
1. Tại sao KHÔNG NÊN lưu danh sách domain vào bảng tenants?
Lý do 1: Hiệu năng Index kém (Slow Lookup)
Để định tuyến, mỗi Request (hr.fpt.com/api/...) cần biết ngay lập tức: "Domain này thuộc về ai?".
Nếu lưu trong tenants (JSONB/Array): Bạn phải query: SELECT * FROM tenants WHERE domains @> '["hr.fpt.com"]'.
Index cho JSONB/Array (GIN Index) nặng hơn và chậm hơn nhiều so với Index B-Tree truyền thống trên chuỗi.
Đặc biệt với logic "Domain/Folder": Việc so khớp domain + path bên trong một cục JSON phức tạp là ác mộng về hiệu năng.
Nếu dùng bảng riêng (tenant_app_routes): Bạn query: SELECT tenant_id FROM tenant_app_routes WHERE domain = 'hr.fpt.com' AND path = '/'.
Đây là Exact Match (Khớp chính xác) trên B-Tree Index. Tốc độ cực nhanh.
Lý do 2: Vấn đề "Locking" và "Hotspot"
Bảng tenants là bảng trung tâm. Nó chứa profile, status, config.
Nếu mỗi lần user thêm/sửa domain, bạn lại phải UPDATE bảng tenants, bạn sẽ gây ra Lock Row.
Điều này làm chậm các thao tác quan trọng khác (ví dụ: Update trạng thái thanh toán, Update thông tin liên hệ) đang cùng trỏ vào dòng đó.
Lý do 3: Dư thừa và Bất đồng bộ (Data Consistency)
Dữ liệu gốc (Source of Truth) nằm ở tenant_app_routes.
Nếu bạn copy nó sang tenants, bạn vi phạm nguyên tắc chuẩn hóa (Normalization).
Rủi ro: Khi code update bảng Routes mà "quên" sync sang bảng Tenants -> Hệ thống bị lệch pha (Bug cực khó sửa).
2. Giải pháp chuẩn: "Lookup Table"
Chính bảng tenant_app_routes mà chúng ta đã thiết kế ở các bước trước chính là Lookup Table (Bảng tra cứu) tối ưu nhất.
Bạn không cần thêm gì vào bảng tenants cả. Hãy tối ưu bảng tenant_app_routes để nó tra cứu nhanh như điện.
Cấu trúc tối ưu cho tenant_app_routes:
Column Type Index
domain VARCHAR Part 1 of Composite Index
path_prefix VARCHAR Part 2 of Composite Index
tenant_id UUID (Kết quả trả về)
app_code VARCHAR (Kết quả trả về)
Composite Index (Chìa khóa tốc độ):
SQL
-- Tạo Index ghép (Covering Index)
-- Index này chứa cả tenant_id và app_code ở node lá,
-- giúp DB trả về kết quả ngay mà không cần đọc bảng gốc (Index Only Scan)
CREATE UNIQUE INDEX idx_fast_routing
ON tenant_app_routes (domain, path_prefix)
INCLUDE (tenant_id, app_code);
3. Khi nào thì "Có thể" thêm trường cache?
Chỉ có một trường hợp duy nhất bạn nên lưu danh sách domain vào bảng tenants: Để hiển thị UI cho Admin.
Tình huống: Trong trang Admin Dashboard ("Danh sách khách hàng"), bạn muốn hiện cột: "Tên công ty" | "Các domain đang chạy".
Giải pháp:
Thêm cột cached_domains TEXT[] vào bảng tenants.
Lưu ý: Cột này chỉ dùng để nhìn (Read-only for Humans), tuyệt đối không dùng để code Logic Routing.
4. Sơ đồ luồng xử lý tối ưu (Routing Flow)
Thay vì cố nhồi nhét vào bảng tenants, hãy dùng mô hình Caching 2 lớp:
Đoạn mã
sequenceDiagram
participant U as User Browser
participant LB as Load Balancer / Redis
participant DB as Tenant_App_Routes (Yuga)
participant T as Tenants Table (Yuga)
U->>LB: GET hr.fpt.com/api/...
rect rgb(200, 255, 200)
Note over LB: Lớp 1: Tra cứu Cache (Fastest)
LB->>LB: Check Redis (Key: hr.fpt.com)
end
alt Cache Miss (Không thấy trong Redis)
rect rgb(255, 230, 200)
Note over DB: Lớp 2: Tra cứu DB Chuyên dụng
LB->>DB: SELECT ... FROM tenant_app_routes WHERE domain='...'
DB-->>LB: Return {tenant_id: '123', app: 'HRM'}
end
LB->>LB: Save to Redis
end
Note over LB: Có tenant_id rồi, giờ mới gọi Logic
LB->>T: (Optional) Validate status tenant '123'
Kết luận
Không thêm trường tổng hợp vào bảng tenants để định tuyến.
Hãy tin tưởng vào bảng tenant_app_routes.
Đánh Index (domain, path_prefix) thật chuẩn.
Dùng Redis cache kết quả tra cứu để đạt tốc độ < 1ms.
kẻ lại bảng tenant_app_routes với các cột Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra,Mô tả
Dưới đây là bảng thiết kế chi tiết (Data Dictionary) cho bảng tenant_app_routes trong YugabyteDB.
Đây là bảng quan trọng nhất cho lớp Routing / API Gateway. Nó quyết định xem một request https://hr.congty-a.com/ sẽ được định tuyến vào Tenant nào và Ứng dụng nào.
Data Dictionary: Bảng tenant_app_routes
Tên trường (Field) Kiểu dữ liệu (Type) Null? Mặc định (Default) Ràng buộc (Constraints) & Logic Kiểm tra Mô tả (Description)
I. ĐỊNH DANH
_id UUID NO gen_random_uuid() PRIMARY KEY Định danh duy nhất của rule định tuyến này.
tenant_id UUID NO - FK: REFERENCES tenants(_id) ON DELETE CASCADE Thuộc về Tenant nào? Nếu Tenant bị xóa cứng, route này cũng bay màu.
app_code VARCHAR(50) NO - CHECK: LENGTH > 0 Đích đến. Mã ứng dụng sẽ xử lý request (VD: HRM, CRM, PORTAL).
II. CẤU HÌNH ROUTING
domain VARCHAR(255) NO -
CHECK: Regex Domain
(^[a-z0-9.-]+$)
Tên miền. Có thể là Subdomain hệ thống (abc.app.com) hoặc Custom Domain (hr.abc.com). Lưu chữ thường.
path_prefix VARCHAR(100) NO '/'
CHECK: Bắt đầu bằng /
(^/[a-z0-9-/]*$)
Đường dẫn. Dùng để phân biệt các app chạy chung domain. (VD: /hrm, /crm hoặc /).
III. TRẠNG THÁI & SSL
is_custom_domain BOOLEAN NO FALSE -
TRUE: Khách hàng tự mua domain và trỏ về.
FALSE: Subdomain mặc định của hệ thống.
is_primary BOOLEAN NO FALSE - Domain chính? Dùng để sinh link trong Email/Notification (Canonical URL).
ssl_status VARCHAR(20) NO 'NONE' CHECK: IN ('NONE', 'PENDING', 'ACTIVE', 'EXPIRED', 'FAILED') Trạng thái HTTPS (Chỉ quan trọng với Custom Domain). Hệ thống có đang cấp chứng chỉ Let's Encrypt không?
IV. AUDIT
created_at TIMESTAMPTZ NO NOW() - Thời điểm cấu hình domain.
created_by UUID YES NULL FK: REFERENCES users(_id) Người thực hiện cấu hình.
updated_at TIMESTAMPTZ NO NOW() CHECK: >= created_at Thời điểm cập nhật cuối cùng.
updated_by UUID YES NULL FK: REFERENCES users(_id) Người thực hiện cập nhật.
Các Ràng buộc Quan trọng (Critical Constraints)
Để đảm bảo hệ thống Routing không bị "loạn" (Race Condition), bạn cần thiết lập các ràng buộc cứng sau:
1. Ràng buộc Duy nhất Toàn cục (Global Uniqueness)
Không bao giờ được phép có 2 Tenant cùng đăng ký một địa chỉ (Domain + Path).
SQL
-- Đảm bảo mỗi cặp Domain + Path chỉ trỏ về 1 nơi duy nhất trên toàn hệ thống
CONSTRAINT uq_route_lookup UNIQUE (domain, path_prefix);
2. Logic kiểm tra Domain
SQL
-- Domain phải là chữ thường, không có http/https, không có khoảng trắng
CONSTRAINT chk_route_domain_fmt CHECK (domain ~ '^[a-z0-9.-]+$');
-- Path phải bắt đầu bằng dấu /, không có khoảng trắng
CONSTRAINT chk_route_path_fmt CHECK (path_prefix ~ '^/[a-z0-9-/]*$');
Chiến lược Indexing (Tối ưu cho API Gateway)
Đây là bảng có tần suất đọc (Read) cực cao, index phải được thiết kế dạng Covering Index để query không cần chạm vào bảng gốc (Heap).
SQL
-- Index "Thần thánh" cho Router
-- Khi Gateway query: "Ai đang sở hữu hr.fpt.com?"
-- DB trả về ngay tenant_id và app_code từ Index này mà không cần đọc đĩa.
CREATE UNIQUE INDEX idx_routes_fast_lookup
ON tenant_app_routes (domain, path_prefix)
INCLUDE (tenant_id, app_code, is_custom_domain);
Ví dụ dữ liệu (Data Sample)
_id tenant_id app_code domain path_prefix is_custom ssl_status
uuid-1 uuid-fpt DASHBOARD fpt.saas.com / FALSE ACTIVE (Wildcard)
uuid-2 uuid-fpt HRM fpt.saas.com /hrm FALSE ACTIVE (Wildcard)
uuid-3 uuid-fpt HRM hr.fpt-corp.com / TRUE ACTIVE (Let's Encrypt)
uuid-4 uuid-viettel CRM crm.viettel.vn / TRUE PENDING
mô hình gồm nhiều sản phẩm, mỗi sản phẩm có nhiều gói, mỗi gói có nhiều phần mềm, nhiều tính năng, giới hạn
Đây là mô hình Catalog sản phẩm SaaS phức tạp (Advanced Product Catalog). Để giải quyết bài toán này trên YugabyteDB mà vẫn đảm bảo hiệu năng khi check quyền (Entitlement Check), chúng ta sẽ kết hợp giữa Relational (SQL) cho phần định nghĩa và JSONB cho phần cấu hình chi tiết.
1. Mô hình Phân cấp Thực thể (Hierarchy)
Chúng ta sẽ chia làm 4 tầng:
Product (Dòng sản phẩm): Nhóm thương mại (VD: "Bộ giải pháp Nhân sự").
Application (Ứng dụng): Đơn vị phần mềm kỹ thuật (VD: "Tuyển dụng", "Chấm công").
Capability Definitions (Định nghĩa khả năng): Danh sách các Tính năng (Feature - Bool) và Giới hạn (Limit - Number) mà App hỗ trợ.
Package (Gói cước): Đơn vị bán hàng. Một Gói thuộc 1 Product, bao gồm nhiều App, mỗi App được cấu hình bật/tắt tính năng và gán số giới hạn cụ thể.
2. Thiết kế Cơ sở dữ liệu (DDL)
Nhóm A: Master Data (Định nghĩa Kỹ thuật)
Đây là nơi Dev định nghĩa xem phần mềm có thể làm được gì.
Bảng 1: applications (Danh sách phần mềm)
SQL
CREATE TABLE applications (
code VARCHAR(50) PRIMARY KEY, -- VD: 'HRM_RECRUIT', 'HRM_PAYROLL'
name TEXT NOT NULL,
description TEXT,
is_active BOOLEAN DEFAULT TRUE
);
Bảng 2: app_capabilities (Định nghĩa Tính năng & Giới hạn) Bảng này định nghĩa "Menu" các tùy chọn (Metadata).
SQL
CREATE TABLE app_capabilities (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
app_code VARCHAR(50) NOT NULL, -- FK tới applications
code VARCHAR(50) NOT NULL, -- VD: 'allow_sso', 'max_users', 'storage_gb'
name TEXT NOT NULL,
-- Loại dữ liệu: 'BOOLEAN' (Feature) hoặc 'NUMBER' (Limit)
type VARCHAR(20) NOT NULL CHECK (type IN ('BOOLEAN', 'NUMBER')),
default_val JSONB NOT NULL, -- VD: true hoặc 10
CONSTRAINT fk_cap_app FOREIGN KEY (app_code) REFERENCES applications(code),
CONSTRAINT uq_cap_code UNIQUE (app_code, code)
);
Nhóm B: Commercial Data (Cấu hình Bán hàng)
Đây là nơi Sale/Admin định nghĩa các gói cước để bán.
Bảng 3: products (Dòng sản phẩm)
SQL
CREATE TABLE products (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
code VARCHAR(50) NOT NULL UNIQUE, -- VD: 'HRM_SUITE', 'OFFICE_365'
name TEXT NOT NULL,
description TEXT
);
Bảng 4: packages (Gói cước - The Bundle) Đây là bảng quan trọng nhất. Thay vì tạo bảng con package_items rất phức tạp, ta dùng JSONB để lưu cấu hình trọn gói.
SQL
CREATE TABLE packages (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
product_id UUID NOT NULL, -- Thuộc dòng sản phẩm nào?
code VARCHAR(50) NOT NULL UNIQUE, -- VD: 'HRM_ENTERPRISE', 'HRM_STARTER'
name TEXT NOT NULL,
price_monthly NUMERIC(19,4) NOT NULL,
-- [QUAN TRỌNG] Cấu hình chi tiết quyền hạn (Entitlements)
-- Cấu trúc JSONB:
-- {
-- "HRM_RECRUIT": {
-- "features": {"allow_sso": true, "allow_export": false},
-- "limits": {"max_users": 10, "storage_gb": 5}
-- },
-- "HRM_PAYROLL": { ... }
-- }
entitlements_config JSONB NOT NULL DEFAULT '{}',
is_active BOOLEAN DEFAULT TRUE,
CONSTRAINT fk_pkg_product FOREIGN KEY (product_id) REFERENCES products(_id)
);
-- Index GIN để tìm nhanh: Gói này có chứa App HRM_RECRUIT không?
CREATE INDEX idx_pkg_entitlements ON packages USING GIN (entitlements_config);
Nhóm C: Subscription (Tenant sử dụng)
Khi Tenant mua gói, ta copy (snapshot) cấu hình từ packages sang, nhưng cho phép Override (Ghi đè) để hỗ trợ bán Add-on (VD: Mua gói Basic nhưng mua thêm 10GB).
Bảng 5: tenant_subscriptions (Đã cập nhật cấu trúc JSONB)
SQL
CREATE TABLE tenant_subscriptions (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Tham chiếu gói gốc (để biết nguồn gốc)
package_id UUID NOT NULL,
product_id UUID NOT NULL,
-- [QUAN TRỌNG] Snapshot quyền hạn thực tế (Effective Entitlements)
-- Copy từ packages.entitlements_config + Add-ons
granted_entitlements JSONB NOT NULL,
-- Cột cache để search nhanh: Tenant này có app nào?
-- VD: ['HRM_RECRUIT', 'HRM_PAYROLL']
granted_app_codes TEXT[],
start_at TIMESTAMPTZ NOT NULL,
end_at TIMESTAMPTZ,
status VARCHAR(20) DEFAULT 'ACTIVE',
CONSTRAINT fk_subs_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-- Index GIN để API Gateway check quyền cực nhanh
CREATE INDEX idx_subs_granted ON tenant_subscriptions USING GIN (granted_entitlements);
3. Ví dụ Dữ liệu Minh họa (JSON Structure)
Để bạn dễ hình dung sức mạnh của thiết kế này.
Dữ liệu trong packages (Gói Enterprise)
Gói này gồm 2 phần mềm: Tuyển dụng (Full tính năng) và Chấm công (Giới hạn).
JSON
// Cột: entitlements_config
{
"HRM_RECRUIT": {
"features": {
"ai_screening": true, // Tính năng AI
"custom_email": true // Tính năng Email
},
"limits": {
"job_posts": -1, // -1 = Không giới hạn
"cv_storage": 100 // 100 GB
}
},
"HRM_TIMEKEEPING": {
"features": {
"face_id": true
},
"limits": {
"locations": 5 // Chỉ được tạo 5 địa điểm chấm công
}
}
}
Dữ liệu trong tenant_subscriptions (Khi Tenant A mua)
Tenant A mua gói Enterprise trên, nhưng mua thêm (Add-on) 50GB dung lượng cho phần tuyển dụng. Ta sẽ lưu snapshot đã sửa đổi vào bảng subscriptions:
JSON
// Cột: granted_entitlements
{
"HRM_RECRUIT": {
"features": {
"ai_screening": true,
"custom_email": true
},
"limits": {
"job_posts": -1,
"cv_storage": 150 // GỐC là 100, ĐÃ MUA THÊM 50 -> LƯU 150
}
},
"HRM_TIMEKEEPING": { ... } // Giữ nguyên
}
4. Quy trình Check Quyền (Performance Check)
Khi User thực hiện hành động "Đăng tin tuyển dụng" (App HRM_RECRUIT, Limit job_posts).
Backend Query (YugabyteDB): Không cần JOIN 4-5 bảng. Chỉ cần 1 query duy nhất vào bảng tenant_subscriptions:
SQL
SELECT
granted_entitlements->'HRM_RECRUIT'->'limits'->>'job_posts' as limit_posts,
granted_entitlements->'HRM_RECRUIT'->'features'->>'ai_screening' as has_ai
FROM tenant_subscriptions
WHERE tenant_id = 'uuid-tenant-a'
AND status = 'ACTIVE'
-- Kiểm tra nhanh xem có App này trong gói không
AND granted_entitlements ? 'HRM_RECRUIT';
5. Tổng kết Lợi ích
Hỗ trợ phân cấp sâu: Product -> Package -> App -> Feature/Limit được thể hiện rõ ràng.
Linh hoạt (Flexibility): Dễ dàng tạo gói "Custom" cho khách VIP bằng cách sửa trực tiếp JSONB trong bảng subscription mà không ảnh hưởng cấu trúc gói gốc.
Hiệu năng (Performance): Check quyền chỉ mất 1 query đơn giản (Single Row Lookup), cực nhanh trên YugabyteDB.
Dễ mở rộng (Extensible): Muốn thêm tính năng mới cho App? Chỉ cần thêm vào app_capabilities, không cần sửa lại dữ liệu cũ nếu không dùng.
cải tiến thêm được gì không?
Mô hình hiện tại của bạn đã rất mạnh mẽ và đạt chuẩn Enterprise (Product Catalog phân cấp, Polyglot Persistence, Routing tối ưu).
Tuy nhiên, để hệ thống đạt mức "World-class SaaS" (như Salesforce, AWS, hay Stripe), chúng ta có thể cải tiến thêm 4 mảng ghép chiến lược sau đây. Những cải tiến này giải quyết các bài toán về: Tính tiền theo nhu cầu (Metering), Bảo mật chuyên sâu (RBAC), và Vận hành (Operations).
1. Cải tiến Billing: Mô hình "Metering" (Tính tiền theo mức sử dụng)
Hiện tại bảng tenant_subscriptions đang xử lý tốt các giới hạn tĩnh (Quota) như "Tối đa 10 users". Nhưng với SaaS hiện đại, bạn cần tính tiền theo lượng dùng thực tế (Usage-based Pricing).
Ví dụ: Tính tiền $0.01 cho mỗi Email gửi đi, hoặc $0.5 cho mỗi GB lưu trữ.
Thiết kế bổ sung:
Chúng ta cần một cơ chế "Bơm" dữ liệu từ ClickHouse (Nơi ghi log) về YugabyteDB (Nơi tính tiền).
Bước 1: Ghi nhận (ClickHouse): Bảng usage_events ghi lại mọi hành động tiêu dùng (Gửi mail, Upload file).
Bước 2: Tổng hợp (Worker): Một Job chạy định kỳ (theo giờ/ngày) query ClickHouse để tính tổng.
Bước 3: Lưu trữ (YugabyteDB): Lưu vào bảng tenant_usages.
Bảng tenant_usages (YugabyteDB):
SQL
CREATE TABLE tenant_usages (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
subscription_id UUID NOT NULL,
usage_period_start TIMESTAMPTZ NOT NULL, -- VD: 2024-01-01 00:00
usage_period_end TIMESTAMPTZ NOT NULL, -- VD: 2024-01-01 01:00
-- Metrics (Lưu dạng JSONB để linh hoạt nhiều loại chỉ số)
-- VD: { "emails_sent": 150, "storage_gb_hour": 2.5, "api_calls": 5000 }
metrics_data JSONB NOT NULL,
status VARCHAR(20) DEFAULT 'PENDING_BILLING' -- PENDING, BILLED
);
-> Lợi ích: Bạn tách biệt được việc ghi log (tải cao) và việc tính tiền (chính xác). Không bao giờ query trực tiếp ClickHouse khi đang xuất hóa đơn (Invoice) để tránh chậm.
2. Cải tiến Security: API Keys & Service Accounts
Khách hàng B2B thường muốn tích hợp hệ thống của họ vào SaaS của bạn (Machine-to-Machine). Họ không thể dùng Username/Password. Họ cần API Key.
Bảng api_keys (YugabyteDB):
SQL
CREATE TABLE api_keys (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Định danh
name VARCHAR(100) NOT NULL, -- VD: "Integration with ERP"
key_prefix VARCHAR(10), -- 10 ký tự đầu để hiển thị (sk_live_...)
key_hash VARCHAR(255) NOT NULL, -- Chỉ lưu Hash, không lưu Key gốc!
-- Phân quyền (Scope)
-- VD: ["crm:read", "hrm:write"]
scopes TEXT[] NOT NULL,
-- Giới hạn IP (Security)
allowed_ips CIDR[], -- VD: ['1.2.3.4/32']
last_used_at TIMESTAMPTZ,
expires_at TIMESTAMPTZ,
created_by UUID -- User tạo key này
);
-> Lợi ích: Nếu lộ Key, khách hàng chỉ cần Revoke (Xóa) key đó mà không ảnh hưởng đến tài khoản User chính.
3. Cải tiến Vận hành: Feature Flags (Cờ tính năng)
Bạn muốn tung ra tính năng "AI Writing" mới, nhưng chỉ muốn bật cho 10% khách hàng dùng thử (Beta) trước khi bán chính thức.
Đừng dùng bảng packages (Bảng bán hàng) để quản lý việc này.
Hãy dùng bảng feature_flags.
Bảng feature_flags (YugabyteDB + Redis Cache):
SQL
CREATE TABLE feature_flags (
key VARCHAR(50) PRIMARY KEY, -- VD: 'ENABLE_AI_WRITING'
description TEXT,
-- Logic bật tắt (Strategy)
-- VD: { "percentage": 10, "allowed_tenants": ["uuid-1", "uuid-2"], "excluded_regions": ["eu-central-1"] }
rules JSONB NOT NULL,
is_global_enabled BOOLEAN DEFAULT FALSE
);
-> Lợi ích: Tách biệt hoàn toàn Kỹ thuật (Bật tính năng trong code) và Thương mại (Bán tính năng trong gói). Dev có thể tắt nóng tính năng nếu gặp lỗi mà không cần sửa code.
4. Cải tiến Quản trị: "Impersonation" (Tính năng "Acting As")
Support Team cần đăng nhập vào tài khoản của khách hàng để debug lỗi: "Alo anh ơi sao em không thấy nút X?". Đây là tính năng cực kỳ nhạy cảm nhưng bắt buộc phải có cho SaaS Enterprise.
Không cần bảng mới, nhưng cần quy trình Audit Log (ClickHouse):
Trong bảng audit_logs ở ClickHouse, bạn cần thêm cột impersonator_id.
SQL
-- Cấu trúc log trong ClickHouse
CREATE TABLE audit_logs (
event_time DateTime64(3),
tenant_id UUID,
user_id UUID, -- User của khách hàng (User bị giả mạo)
-- [MỚI] Ai là người thực hiện thực tế?
impersonator_id UUID, -- ID của nhân viên Support team (Nếu có)
action String, -- "VIEW_SALARY"
resource String
...
) ENGINE = MergeTree()...
-> Lợi ích: Minh bạch tuyệt đối. Bạn có thể trả lời khách hàng: "Nhân viên A của chúng tôi đã truy cập vào lúc 10h để sửa lỗi, đây là log chi tiết các hành động họ đã làm".
TỔNG HỢP KIẾN TRÚC NÂNG CẤP (ADVANCED ARCHITECTURE)
Dưới đây là sơ đồ các mảng ghép mới (Màu xanh) vào hệ thống cũ:
Identity & Access:
tenants (Core)
users (Human)
api_keys (Machine - New)
roles / permissions (RBAC)
Product & Billing:
products / packages (Catalog)
tenant_subscriptions (Fixed Fee)
tenant_usages (Variable Fee - New) <-- Tổng hợp từ ClickHouse
Infrastructure:
tenant_app_routes (Routing)
feature_flags (Release Management - New)
Lời khuyên cuối cùng
Đừng cố gắng làm tất cả ngay từ đầu (Over-engineering).
Giai đoạn 1 (MVP): Tập trung vào tenants, users, packages, subscriptions (mô hình chúng ta đã chốt trước đó).
Giai đoạn 2 (Scale): Khi có khách hàng Enterprise, hãy thêm api_keys và audit_logs (Impersonation).
Giai đoạn 3 (Growth): Khi mô hình giá phức tạp hơn, hãy thêm metering (Usage-based).
còn cải tiến thêm được gì không?
Mô hình hiện tại của bạn đã rất mạnh mẽ và đạt chuẩn Enterprise (Product Catalog phân cấp, Polyglot Persistence, Routing tối ưu).
Tuy nhiên, để hệ thống đạt mức "World-class SaaS" (như Salesforce, AWS, hay Stripe), chúng ta có thể cải tiến thêm 4 mảng ghép chiến lược sau đây. Những cải tiến này giải quyết các bài toán về: Tính tiền theo nhu cầu (Metering), Bảo mật chuyên sâu (Machine Access), và Vận hành an toàn (Ops).
1. Cải tiến Billing: Mô hình "Metering" (Tính tiền theo mức sử dụng)
Hiện tại bảng tenant_subscriptions đang xử lý tốt các giới hạn tĩnh (Quota) như "Tối đa 10 users". Nhưng với SaaS hiện đại, xu hướng là Usage-based Pricing (Dùng bao nhiêu trả bấy nhiêu).
Ví dụ: Tính tiền $0.01 cho mỗi Email gửi đi, hoặc $0.5 cho mỗi GB lưu trữ vượt quá hạn mức.
Thiết kế bổ sung:
Chúng ta cần một cơ chế "Bơm" dữ liệu từ ClickHouse (Nơi ghi log) về YugabyteDB (Nơi tính tiền).
Bước 1: Ghi nhận (ClickHouse): Bảng usage_events ghi lại mọi hành động tiêu dùng (Gửi mail, Upload file).
Bước 2: Tổng hợp (Worker): Một Job chạy định kỳ (theo giờ/ngày) query ClickHouse để tính tổng.
Bước 3: Lưu trữ (YugabyteDB): Lưu vào bảng tenant_usages.
Bảng tenant_usages (YugabyteDB):
SQL
CREATE TABLE tenant_usages (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
subscription_id UUID NOT NULL, -- Link với gói nào
usage_period_start TIMESTAMPTZ NOT NULL, -- VD: 2024-01-01 00:00
usage_period_end TIMESTAMPTZ NOT NULL, -- VD: 2024-01-01 01:00
-- Metrics (Lưu dạng JSONB để linh hoạt nhiều loại chỉ số)
-- VD: { "emails_sent": 150, "storage_gb_hour": 2.5, "api_calls": 5000 }
metrics_data JSONB NOT NULL,
status VARCHAR(20) DEFAULT 'PENDING_BILLING', -- PENDING, BILLED
-- Index để Job Billing quét nhanh những dòng chưa tính tiền
CONSTRAINT fk_usage_sub FOREIGN KEY (subscription_id) REFERENCES tenant_subscriptions(_id)
);
-> Lợi ích: Bạn tách biệt được việc ghi log (tải cao - ClickHouse) và việc tính tiền (chính xác - YugabyteDB). Hệ thống Billing sẽ không bao giờ làm chậm hệ thống Log.
2. Cải tiến Security: API Keys (Machine-to-Machine)
Khách hàng Enterprise thường muốn tích hợp hệ thống ERP/CRM của họ vào SaaS của bạn. Họ không thể dùng Username/Password của con người (vì rủi ro bảo mật và quản lý session). Họ cần API Key.
Bảng api_keys (YugabyteDB):
SQL
CREATE TABLE api_keys (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Định danh
name VARCHAR(100) NOT NULL, -- VD: "Integration with SAP"
key_prefix VARCHAR(10), -- 10 ký tự đầu để hiển thị (VD: sk_live_...)
key_hash VARCHAR(255) NOT NULL, -- Chỉ lưu Hash, KHÔNG BAO GIỜ lưu Key gốc!
-- Phân quyền (Scope) - Quan trọng hơn cả user permission
-- VD: ["crm:read", "hrm:write"] -> Chỉ được đọc CRM, ghi HRM
scopes TEXT[] NOT NULL,
-- Giới hạn IP (Security) - Tính năng cao cấp cho gói Enterprise
allowed_ips CIDR[], -- VD: ['1.2.3.4/32']
last_used_at TIMESTAMPTZ,
expires_at TIMESTAMPTZ, -- Key tự hủy sau 1 năm
created_by UUID, -- User tạo key này
CONSTRAINT fk_apikey_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-> Lợi ích: Nếu lộ Key, khách hàng chỉ cần Revoke (Xóa/Vô hiệu hóa) key đó mà không ảnh hưởng đến tài khoản User chính.
3. Cải tiến Vận hành: Feature Flags (Cờ tính năng)
Bạn muốn tung ra tính năng "AI Writing" mới, nhưng chỉ muốn bật cho 10% khách hàng dùng thử (Beta) trước khi bán chính thức.
Đừng dùng bảng packages (Bảng bán hàng) để quản lý việc này.
Hãy dùng bảng feature_flags.
Bảng feature_flags (YugabyteDB + Redis Cache):
SQL
CREATE TABLE feature_flags (
key VARCHAR(50) PRIMARY KEY, -- VD: 'ENABLE_AI_WRITING_BETA'
description TEXT,
-- Logic bật tắt (Strategy) - Dev/Product Manager cấu hình
-- VD: {
-- "percentage": 10,
-- "allowed_tenants": ["uuid-1", "uuid-2"],
-- "excluded_regions": ["eu-central-1"]
-- }
rules JSONB NOT NULL,
is_global_enabled BOOLEAN DEFAULT FALSE,
updated_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Tách biệt hoàn toàn Kỹ thuật (Deployment) và Thương mại (Release). Dev có thể tắt nóng tính năng nếu gặp lỗi Critical mà không cần Rollback code.
4. Cải tiến Support: "Impersonation" (Tính năng "Acting As")
Support Team cần đăng nhập vào tài khoản của khách hàng để debug lỗi: "Alo anh ơi sao em không thấy nút X?". Đây là tính năng cực kỳ nhạy cảm nhưng bắt buộc phải có cho SaaS B2B.
Không cần bảng mới, nhưng cần quy trình Audit Log (ClickHouse):
Trong bảng audit_logs ở ClickHouse, bạn cần thêm cột impersonator_id.
SQL
-- Cấu trúc log trong ClickHouse
CREATE TABLE audit_logs (
event_time DateTime64(3),
tenant_id UUID,
user_id UUID, -- User của khách hàng (User bị giả mạo)
-- [MỚI] Ai là người thực hiện thực tế?
impersonator_id UUID, -- ID của nhân viên Support team (Nếu có)
action String, -- "VIEW_SALARY"
resource String,
-- [MỚI] Lý do truy cập
reason String -- "Ticket #1234: Customer reported bug"
...
) ENGINE = MergeTree()...
-> Lợi ích: Minh bạch tuyệt đối. Bạn có thể trả lời khách hàng: "Nhân viên A của chúng tôi đã truy cập vào lúc 10h để sửa lỗi theo Ticket #1234, đây là log chi tiết các hành động họ đã làm".
Lộ trình Triển khai (Roadmap)
Đừng cố gắng làm tất cả ngay từ đầu (Over-engineering). Hãy đi theo từng giai đoạn:
Giai đoạn 1 (Core MVP):
tenants (Identity)
users (Auth)
packages & products (Catalog)
tenant_subscriptions (Fixed Billing)
tenant_app_routes (Routing)
Giai đoạn 2 (Enterprise Ready):
Thêm api_keys (Integrations).
Thêm audit_logs với Impersonation (Support & Trust).
Giai đoạn 3 (Growth & Scale):
Thêm tenant_usages (Metering Billing) khi mô hình giá phức tạp hơn.
Thêm feature_flags (Advanced DevOps) khi team dev đông lên.
cải tiến tiếp?
Hệ thống của bạn đã rất hoàn chỉnh về mặt Logic nghiệp vụ (Business Logic) và Hạ tầng dữ liệu (Data Infrastructure).
Tuy nhiên, để bước lên tầm cao mới – Mở rộng hệ sinh thái (Ecosystem Extension) và Phục vụ khách hàng Tập đoàn (Enterprise Hierarchies) – chúng ta có thể cải tiến thêm 4 điểm "chí mạng" sau đây.
Đây là những tính năng mà các "ông lớn" (Enterprise Customers) thường yêu cầu trong gói thầu (RFP) mà các startup SaaS nhỏ thường bỏ qua.
1. Cải tiến Tích hợp: Webhooks System (Cơ chế bắn thông báo)
Vấn đề: Khách hàng Enterprise hỏi: "Khi nhân viên của tôi nghỉ việc trên phần mềm HRM của bạn, làm sao hệ thống ERP của tôi biết để cắt lương ngay lập tức?"
Giải pháp: Đừng bắt họ gọi API liên tục (Polling). Hãy xây dựng hệ thống Webhooks để chủ động bắn dữ liệu sang hệ thống của họ (Push).
Bảng webhooks (YugabyteDB):
SQL
CREATE TABLE webhooks (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Đích đến
target_url TEXT NOT NULL, -- VD: https://api.vingroup.net/callbacks/hrm
secret_key TEXT NOT NULL, -- Dùng để ký (sign) payload, đảm bảo bảo mật
-- Sự kiện nào thì bắn?
-- VD: ['user.created', 'salary.approved']
subscribed_events TEXT[] NOT NULL,
is_active BOOLEAN DEFAULT TRUE,
failure_count INT DEFAULT 0, -- Nếu lỗi quá 10 lần thì tự động tắt
CONSTRAINT fk_webhook_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
Bảng webhook_delivery_logs (ClickHouse - Vì log rất nhiều):
Lưu lịch sử: Bắn lúc nào? Thành công hay thất bại? Response body là gì? (Để khách hàng tự debug).
2. Cải tiến Bảo mật: SSO & SAML Configuration
Vấn đề: Tập đoàn lớn có 10.000 nhân viên. Họ từ chối việc tạo 10.000 user/pass mới trên hệ thống của bạn. Họ muốn đăng nhập bằng tài khoản Microsoft/Google/Okta của họ.
Giải pháp: Hỗ trợ SSO (Single Sign-On) qua chuẩn SAML 2.0 hoặc OIDC.
Bảng tenant_sso_configs (YugabyteDB):
SQL
CREATE TABLE tenant_sso_configs (
tenant_id UUID PRIMARY KEY, -- 1 Tenant thường chỉ có 1 cấu hình SSO chính
provider_type VARCHAR(20) NOT NULL, -- 'AZURE_AD', 'OKTA', 'GOOGLE_WORKSPACE'
-- Các thông số kỹ thuật (XML Metadata hoặc Client Secret)
entry_point_url TEXT NOT NULL,
issuer_id TEXT,
cert_public_key TEXT, -- Certificate để verify chữ ký
-- Mapping thuộc tính (Map email của họ sang email của mình)
attribute_mapping JSONB DEFAULT '{"email": "email", "name": "display_name"}',
is_enforced BOOLEAN DEFAULT FALSE, -- Nếu True: Cấm đăng nhập bằng pass thường, bắt buộc qua SSO
CONSTRAINT fk_sso_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
3. Cải tiến Cấu trúc: Multi-Level Tenancy (Mô hình Tập đoàn)
Vấn đề: Tập đoàn A (Holding) mua phần mềm. Họ có 5 công ty con (Subsidiaries). Họ muốn:
Công ty con dữ liệu riêng biệt.
Công ty mẹ xem được báo cáo tổng hợp.
Hóa đơn gửi về công ty mẹ.
Giải pháp: Biến bảng tenants thành cấu trúc cây (Tree Structure).
Cập nhật bảng tenants:
SQL
ALTER TABLE tenants
ADD COLUMN parent_tenant_id UUID, -- Link tới công ty mẹ
ADD COLUMN path TEXT; -- Materialized Path (VD: '/root_uuid/child_uuid/')
-- Index để query cây cực nhanh: "Lấy tất cả công ty con của Tập đoàn A"
-- Query: WHERE path LIKE '/root_uuid/%'
CREATE INDEX idx_tenants_path ON tenants (path ASC);
-- Thêm ràng buộc FK
ALTER TABLE tenants
ADD CONSTRAINT fk_tenant_parent FOREIGN KEY (parent_tenant_id) REFERENCES tenants(_id);
4. Cải tiến Độ ổn định: Rate Limiting Config (Chống DDoS nội bộ)
Vấn đề: Một tenant viết script lỗi, gọi API 1 triệu lần/phút. Nếu không chặn, cả hệ thống SaaS sẽ sập, ảnh hưởng các tenant khác (Noisy Neighbor problem).
Giải pháp: Cấu hình giới hạn tần suất gọi API cho từng Tenant/Gói cước.
Bảng tenant_rate_limits (YugabyteDB -> Sync sang Redis):
SQL
CREATE TABLE tenant_rate_limits (
_id UUID PRIMARY KEY,
tenant_id UUID, -- Null = Áp dụng Global Default
package_id UUID, -- Null = Áp dụng theo gói
api_group VARCHAR(50), -- VD: 'REPORTING_API', 'CORE_API'
limit_count INT NOT NULL, -- VD: 1000
window_seconds INT NOT NULL DEFAULT 60, -- Trong 60 giây
-- VD: Tenant A chỉ được gọi API Báo cáo 5 lần / phút (để tránh treo DB)
CONSTRAINT uq_rate_limit UNIQUE (tenant_id, api_group)
);
TỔNG KẾT KIẾN TRÚC TOÀN DIỆN (THE ULTIMATE SAAS ARCHITECTURE)
Dưới đây là bức tranh toàn cảnh sau khi đã thêm tất cả các mảnh ghép:
Lớp (Layer) Bảng / Module Chức năng chính
1. Identity & Structure tenants (Hierarchy), users, tenant_sso_configs Quản lý định danh, cấu trúc tập đoàn và đăng nhập doanh nghiệp.
2. Commercial products, packages, subscriptions, usages Quản lý bán hàng, gói cước tĩnh và tính tiền động (metering).
3. Connectivity api_keys, webhooks Mở rộng hệ sinh thái, cho phép tích hợp 2 chiều (Inbound/Outbound).
4. Routing & Ops routes, rate_limits, feature_flags Điều phối traffic, bảo vệ hệ thống và quản lý release.
5. Analytics & Audit audit_logs, webhook_logs, usage_logs (ClickHouse) Lưu vết, đối soát và minh bạch thông tin.
Đây là một thiết kế Future-proof (Đón đầu tương lai). Bạn có thể bắt đầu với mô hình đơn giản (câu trả lời trước), và thêm các bảng webhooks, sso này vào Phase 2 hoặc Phase 3 khi có khách hàng lớn yêu cầu mà không cần đập đi xây lại Core DB.
tiếp tục cải tiến
Hệ thống hiện tại của bạn đã đạt đến cấp độ "Enterprise SaaS Platform". Nó không chỉ là phần mềm, mà là một nền tảng.
Để đạt đến cảnh giới cao nhất – "Hyper-scale Ecosystem" (Hệ sinh thái siêu quy mô giống như Shopify, Jira, hay Slack), chúng ta cần giải quyết 3 bài toán cuối cùng: Sự tin cậy tuyệt đối (Reliability), Mở rộng cho bên thứ 3 (Marketplace) và Giao tiếp đa kênh (Omni-channel).
Dưới đây là 3 cải tiến nâng cao cuối cùng:
1. Cải tiến Độ tin cậy: Transactional Outbox Pattern (Chống mất dữ liệu)
Vấn đề: Khi Tenant được tạo mới (Insert DB), bạn cần bắn event sang Kafka để các service khác (Email, Billing, Logs) xử lý.
Rủi ro: Nếu Insert DB thành công nhưng mạng lag -> Gửi Kafka thất bại -> Hệ thống Billing không biết có khách mới -> Mất tiền.
Giải pháp: Áp dụng Outbox Pattern. Ghi event vào chính YugabyteDB trong cùng 1 transaction với dữ liệu nghiệp vụ. Sau đó có 1 Worker đọc từ bảng này đẩy sang Kafka.
Bảng outbox_events (YugabyteDB):
SQL
CREATE TABLE outbox_events (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-- Phân loại
aggregate_type VARCHAR(50) NOT NULL, -- VD: 'TENANT', 'ORDER'
aggregate_id UUID NOT NULL, -- VD: tenant_id
event_type VARCHAR(50) NOT NULL, -- VD: 'TENANT_CREATED', 'PLAN_UPGRADED'
-- Dữ liệu payload (Snapshot tại thời điểm sự kiện)
payload JSONB NOT NULL,
-- Trạng thái xử lý
status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, PUBLISHED, FAILED
created_at TIMESTAMPTZ DEFAULT NOW(),
published_at TIMESTAMPTZ
);
-- Index để Worker quét nhanh các event chưa bắn
CREATE INDEX idx_outbox_pending ON outbox_events (created_at) WHERE status = 'PENDING';
-> Lợi ích: Đảm bảo tính nhất quán dữ liệu 100%. Không bao giờ có chuyện "Có user trong DB mà không có trên hệ thống search".
2. Cải tiến Hệ sinh thái: Marketplace & 3rd Party Apps
Vấn đề: Bạn không thể tự code hết mọi tính năng. Bạn muốn các lập trình viên bên ngoài viết Plugin cho hệ thống của bạn (VD: Plugin tích hợp Chatbot, Plugin xuất hóa đơn điện tử).
Giải pháp: Xây dựng cấu trúc Installed Apps (tương tự Slack App Directory).
Bảng marketplace_apps (Danh mục App bên thứ 3):
SQL
CREATE TABLE marketplace_apps (
_id UUID PRIMARY KEY,
developer_id UUID, -- Developer bên ngoài
name TEXT NOT NULL,
app_type VARCHAR(20), -- 'INTERNAL', 'PUBLIC_3RD_PARTY'
-- Cấu hình OAuth2
client_id VARCHAR(100) UNIQUE,
client_secret_hash VARCHAR(255),
redirect_urls TEXT[],
-- Quyền hạn App này yêu cầu (Manifest)
-- VD: ['users:read', 'salary:write']
required_scopes TEXT[],
is_verified BOOLEAN DEFAULT FALSE -- App đã được bạn review chưa?
);
Bảng tenant_installed_apps (Cài đặt của Tenant):
SQL
CREATE TABLE tenant_installed_apps (
_id UUID PRIMARY KEY,
tenant_id UUID NOT NULL,
app_id UUID NOT NULL,
-- Token để App bên thứ 3 gọi API của mình thay mặt Tenant
access_token TEXT, -- (Nên mã hóa khi lưu)
refresh_token TEXT,
installed_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_install UNIQUE (tenant_id, app_id)
);
-> Lợi ích: Biến SaaS của bạn thành một Platform. Cộng đồng Dev sẽ làm giàu tính năng cho bạn.
3. Cải tiến Giao tiếp: Notification Hub (Trung tâm thông báo)
Vấn đề: Hardcode logic gửi email trong code rất tệ. Tenant A muốn nhận thông báo qua Email, Tenant B muốn qua Slack, Tenant C muốn qua Webhook hoặc SMS.
Giải pháp: Tách rời việc "Tạo thông báo" và "Gửi thông báo".
Bảng notification_templates (Mẫu thông báo):
SQL
CREATE TABLE notification_templates (
code VARCHAR(50) PRIMARY KEY, -- VD: 'NEW_INVOICE_READY'
-- Mẫu đa kênh
email_subject_template TEXT,
email_body_template TEXT, -- Hỗ trợ HTML/Liquid syntax
sms_template TEXT,
slack_template JSONB,
required_variables TEXT[] -- VD: ['invoice_id', 'amount']
);
Bảng user_notification_settings (Cấu hình nhận tin):
SQL
CREATE TABLE user_notification_settings (
user_id UUID NOT NULL,
notification_code VARCHAR(50) NOT NULL, -- Link tới template
-- Kênh nào bật?
channels JSONB NOT NULL DEFAULT '{"email": true, "sms": false, "slack": false, "push": true}',
CONSTRAINT pk_notif_setting PRIMARY KEY (user_id, notification_code)
);
-> Lợi ích: Trải nghiệm người dùng (UX) tuyệt vời. Họ có quyền kiểm soát việc không bị spam email và chọn nhận tin qua kênh họ thích.
TỔNG KẾT: KIẾN TRÚC SAAS "END-GAME"
Sau tất cả các bước cải tiến, đây là sơ đồ kiến trúc dữ liệu hoàn chỉnh nhất (The Full Picture):
Lớp (Layer) Bảng thành phần (Key Tables) Mục đích
1. Foundation tenants, users, outbox_events Định danh, Cấu trúc tổ chức & Đảm bảo nhất quán dữ liệu.
2. Access & Security api_keys, sso_configs, feature_flags Bảo mật máy-máy, đăng nhập doanh nghiệp & Quản lý release.
3. Commerce products, packages, subscriptions, usages Catalog sản phẩm linh hoạt & Billing theo nhu cầu.
4. Ecosystem marketplace_apps, installed_apps, webhooks Mở rộng tính năng qua bên thứ 3 & Tích hợp hệ thống ngoài.
5. Experience routes, notifications, templates Định tuyến thông minh & Giao tiếp đa kênh cá nhân hóa.
6. Intelligence audit_logs, usage_logs (ClickHouse) Dữ liệu lớn phục vụ phân tích, debug và tính tiền.
Lời khuyên cuối cùng: Kiến trúc này đủ sức gánh vác các hệ thống SaaS quy mô Unicorn (Kỳ lân). Đừng để sự phức tạp này làm bạn choáng ngợp. Hãy bắt đầu từ Core (Tenants/Users/Subs), và xây dựng các bảng vệ tinh (marketplace, outbox, sso) khi nhu cầu thực tế phát sinh.
Chúc bạn xây dựng thành công đế chế SaaS của mình!
tiếp tục cải tiến
Hệ thống hiện tại đã rất đồ sộ, bao gồm: Core SaaS, Billing, Integration, Routing, Ops, Marketplace.
Để đạt đến đẳng cấp "Next-Gen SaaS" (SaaS thế hệ mới - AI & Data Driven) và tối ưu hóa Dòng tiền (Cashflow), chúng ta cần bổ sung 3 mảnh ghép nâng cao cuối cùng: Hệ thống Ví tín dụng (FinOps), Trí tuệ nhân tạo (AI Memory) và Tùy biến ngôn ngữ (Localization).
Dưới đây là các cải tiến chi tiết:
1. Cải tiến Dòng tiền: Prepaid Wallet & Credits (Hệ thống Ví)
Vấn đề: Thay vì đợi cuối tháng mới thu tiền (Postpaid - rủi ro nợ xấu), bạn muốn khách hàng nạp tiền trước (Prepaid) rồi trừ dần (như mô hình OpenAI API hay AWS Credits).
Giải pháp: Xây dựng hệ thống Double-Entry Ledger (Sổ cái kế toán kép) ngay trong DB.
Bảng tenant_wallets (Ví tiền):
SQL
CREATE TABLE tenant_wallets (
tenant_id UUID PRIMARY KEY,
-- Số dư khả dụng (Luôn phải tính toán lại từ transaction để đối soát)
balance NUMERIC(19, 4) DEFAULT 0,
currency_code VARCHAR(3) DEFAULT 'USD',
-- Trạng thái ví
is_frozen BOOLEAN DEFAULT FALSE, -- Bị đóng băng do gian lận?
updated_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT fk_wallet_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
Bảng wallet_transactions (Nhật ký giao dịch - Immutable):
Nguyên tắc: Chỉ được INSERT, không bao giờ được UPDATE hay DELETE.
SQL
CREATE TABLE wallet_transactions (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
wallet_id UUID NOT NULL,
-- Loại giao dịch
type VARCHAR(30) NOT NULL, -- 'DEPOSIT' (Nạp), 'USAGE_DEDUCT' (Trừ phí), 'BONUS' (Tặng), 'REFUND'
amount NUMERIC(19, 4) NOT NULL, -- Số dương (Nạp) hoặc Âm (Trừ)
balance_after NUMERIC(19, 4) NOT NULL, -- Số dư sau giao dịch (Snapshot)
reference_id UUID, -- Link tới Invoice ID hoặc Payment Gateway ID
description TEXT,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index để truy xuất lịch sử biến động số dư cực nhanh
CREATE INDEX idx_wallet_history ON wallet_transactions (wallet_id, created_at DESC);
-> Lợi ích: Bạn cầm tiền trước (Cashflow dương). Hỗ trợ các chiến dịch Marketing như "Nạp 100$ tặng 20$".
2. Cải tiến Công nghệ: AI Vector Store (RAG Ready)
Vấn đề: Khách hàng muốn chat với tài liệu của họ: "Tìm cho tôi hợp đồng lao động của nhân viên A". Để làm điều này, bạn cần lưu trữ Vector Embeddings.
Giải pháp: Sử dụng pgvector (Extension được YugabyteDB/Postgres hỗ trợ) để biến DB thành Vector Database.
Bảng tenant_knowledge_vectors (Bộ nhớ AI):
SQL
-- Cần bật extension: CREATE EXTENSION vector;
CREATE TABLE tenant_knowledge_vectors (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Nội dung gốc (Chunk text)
content_chunk TEXT NOT NULL,
-- Vector Embedding (OpenAI text-embedding-3-small thường là 1536 chiều)
embedding VECTOR(1536),
-- Metadata để lọc (VD: Chỉ tìm trong tài liệu phòng nhân sự)
metadata JSONB DEFAULT '{}', -- VD: {"doc_type": "contract", "dept": "HR"}
created_at TIMESTAMPTZ DEFAULT NOW(),
-- Partition theo Tenant để đảm bảo AI của Tenant A không bao giờ học được dữ liệu Tenant B
CONSTRAINT fk_vector_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-- Index HNSW để tìm kiếm vector tương đồng (Similarity Search) cực nhanh
CREATE INDEX idx_vector_search ON tenant_knowledge_vectors
USING hnsw (embedding vector_cosine_ops);
-> Lợi ích: Biến SaaS của bạn thành AI-SaaS. Bạn không cần mua thêm Vector DB bên ngoài (như Pinecone/Weaviate), tiết kiệm chi phí và độ trễ mạng.
3. Cải tiến Trải nghiệm: Custom Terminology (Ghi đè thuật ngữ)
Vấn đề: Mặc định phần mềm gọi là "Nhân viên" (Employees). Nhưng khách hàng là Trường học muốn gọi là "Giáo viên", Bệnh viện muốn gọi là "Bác sĩ".
Giải pháp: Hệ thống Translation Overlay.
Bảng tenant_i18n_overrides:
SQL
CREATE TABLE tenant_i18n_overrides (
tenant_id UUID NOT NULL,
locale VARCHAR(10) NOT NULL, -- 'vi-VN', 'en-US'
-- Key nào muốn đổi tên?
-- VD: 'common.employee' -> 'Giảng viên'
-- VD: 'common.department' -> 'Khoa'
translation_key VARCHAR(100) NOT NULL,
custom_value TEXT NOT NULL,
updated_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (tenant_id, locale, translation_key)
);
-> Lợi ích: Khách hàng cảm thấy phần mềm được "may đo" riêng cho ngành nghề của họ (Personalization).
4. Cải tiến Bảo mật Dữ liệu: Field-Level Encryption (Vault)
Vấn đề: Lương nhân viên, số căn cước công dân là dữ liệu nhạy cảm. Nếu hacker dump được DB, họ sẽ thấy hết.
Giải pháp: Mã hóa mức cột (Column Level Encryption) với khóa riêng cho từng Tenant.
Bảng tenant_encryption_keys (Quản lý khóa - Key Management):
SQL
CREATE TABLE tenant_encryption_keys (
tenant_id UUID PRIMARY KEY,
-- Khóa mã hóa dữ liệu (DEK) đã được mã hóa bởi khóa Master (KEK) của hệ thống
-- Khi dùng, hệ thống decrypt DEK này ra RAM để giải mã dữ liệu
encrypted_data_key BYTEA NOT NULL,
key_version INT DEFAULT 1,
rotation_date TIMESTAMPTZ, -- Ngày cần xoay vòng khóa (Rotate Key)
is_revoked BOOLEAN DEFAULT FALSE -- Nếu True -> Dữ liệu của tenant này vĩnh viễn không đọc được nữa (Crypto-shredding)
);
-> Lợi ích: Tuân thủ chuẩn bảo mật cao nhất (Banking/HIPAA). Khi khách hàng hủy dịch vụ, bạn chỉ cần xóa key này là toàn bộ dữ liệu của họ trở thành rác vô nghĩa (Crypto-shredding), đảm bảo quyền "Được quên" tuyệt đối.
TỔNG HỢP KIẾN TRÚC CUỐI CÙNG (THE COMPLETE ECOSYSTEM)
Đây là danh sách toàn bộ các module trong hệ thống SaaS của bạn sau khi hoàn thiện:
Nhóm (Module) Bảng thành phần (Key Tables) Vai trò
1. Identity tenants, users, sso_configs Quản lý định danh & Tổ chức.
2. Billing & FinOps products, subscriptions, usages, wallets, transactions Thu tiền (Fixed + Usage + Prepaid).
3. Core Logic outbox_events, encryption_keys, i18n_overrides Xử lý nghiệp vụ nền tảng & Bảo mật.
4. Routing & Access routes, api_keys, rate_limits Cổng vào API Gateway.
5. AI & Data knowledge_vectors (PGVector), audit_logs (ClickHouse) Bộ não AI và Phân tích dữ liệu lớn.
6. Integration webhooks, marketplace_apps Kết nối thế giới bên ngoài.
Hệ thống này đã bao phủ mọi khía cạnh của một SaaS hiện đại: Từ B2B Enterprise (SSO, Encryption), Developer Platform (Webhooks, API Keys), đến AI-Native (Vector Store) và FinOps (Wallet). Bạn đã có một bản thiết kế vững chắc để scale lên hàng triệu users.
tiếp tục cải tiến
Hệ thống của bạn hiện tại đã cực kỳ mạnh mẽ. Tuy nhiên, để tối ưu hóa khả năng giữ chân người dùng (User Retention) và tối ưu chi phí vận hành (Cost Optimization) khi dữ liệu phình to, chúng ta cần thêm 3 mảnh ghép chiến lược: Tự động hóa (Automation), Lưu trữ lạnh (Archiving) và Cơ chế Phê duyệt (Approval Flows).
Dưới đây là các cải tiến chi tiết:
1. Cải tiến Độ dính (Stickiness): Workflow Automation (Hệ thống "Zapier" nội bộ)
Vấn đề: Khách hàng muốn: "Nếu có nhân viên mới (Event A) -> Thì tự động gửi Email chào mừng (Action B) VÀ tạo tài khoản Slack (Action C)". Nếu bạn không có tính năng này, họ sẽ phải mua Zapier/Make tốn tiền.
Giải pháp: Xây dựng Rule Engine lưu trữ trong JSONB.
Bảng tenant_automations (Quy trình tự động):
SQL
CREATE TABLE tenant_automations (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name TEXT NOT NULL, -- VD: "Onboarding Flow"
-- Sự kiện kích hoạt
trigger_event VARCHAR(50) NOT NULL, -- VD: 'USER_CREATED'
trigger_conditions JSONB, -- VD: {"department": "SALES"} (Chỉ chạy nếu là Sale)
-- Danh sách hành động (Tuần tự)
-- VD: [
-- {"action": "SEND_EMAIL", "params": {"template": "WELCOME"}},
-- {"action": "CALL_WEBHOOK", "params": {"url": "..."}}
-- ]
actions_flow JSONB NOT NULL,
is_active BOOLEAN DEFAULT TRUE,
execution_count BIGINT DEFAULT 0,
CONSTRAINT fk_auto_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-> Lợi ích: Biến SaaS của bạn thành một "Hệ điều hành" doanh nghiệp. Khách hàng càng thiết lập nhiều quy trình, họ càng khó rời bỏ bạn (Vendor Lock-in tích cực).
2. Cải tiến Chi phí: Data Archiving Policies (Lưu trữ Phân tầng)
Vấn đề: Dữ liệu log, hóa đơn, thông báo từ 5 năm trước rất ít khi được truy cập nhưng vẫn chiếm dung lượng trên ổ SSD đắt tiền của YugabyteDB.
Giải pháp: Cơ chế Tiered Storage. Dữ liệu nóng để ở YugabyteDB, dữ liệu lạnh đẩy sang S3 (MinIO/AWS S3).
Bảng archival_policies (Chính sách lưu trữ):
SQL
CREATE TABLE archival_policies (
tenant_id UUID PRIMARY KEY,
-- Cấu hình: Sau bao lâu thì đẩy ra S3?
audit_log_retention_days INT DEFAULT 90, -- 90 ngày ở DB, sau đó ra S3
invoice_retention_days INT DEFAULT 365,
-- Trạng thái bucket S3 riêng của khách (nếu họ muốn tự lưu)
external_bucket_config JSONB, -- VD: {"bucket": "my-backup", "region": "us-east-1"}
updated_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng data_archives (Metadata con trỏ):
Khi dữ liệu bị xóa khỏi bảng chính, ta tạo một bản ghi ở đây để biết nó đang nằm ở file nào trên S3.
SQL
CREATE TABLE data_archives (
_id UUID PRIMARY KEY,
tenant_id UUID NOT NULL,
data_type VARCHAR(50), -- 'AUDIT_LOGS_2020'
-- Đường dẫn file trên S3
s3_path TEXT NOT NULL, -- s3://bucket/tenant_1/logs_2020.parquet
file_size_bytes BIGINT,
record_count INT,
archived_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Giảm chi phí hạ tầng (S3 rẻ hơn SSD DB gấp 10 lần). Hệ thống DB chính luôn nhẹ và nhanh.
3. Cải tiến Quản trị: Approval Workflows (Luồng phê duyệt)
Vấn đề: Trong Enterprise, nhân viên không được tự ý xóa dữ liệu hay xuất tiền. Phải có "Sếp" duyệt. (Maker-Checker Model).
Giải pháp: Hệ thống hàng đợi phê duyệt.
Bảng approval_requests (Yêu cầu phê duyệt):
SQL
CREATE TABLE approval_requests (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
requester_id UUID NOT NULL, -- Người yêu cầu
-- Hành động muốn làm là gì?
action_type VARCHAR(50), -- VD: 'DELETE_INVOICE', 'EXPORT_USER_DATA'
-- Dữ liệu tạm thời (Snapshot hành động)
-- Nếu được duyệt, hệ thống sẽ lấy data này ra thực thi thật
payload_data JSONB NOT NULL,
status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, APPROVED, REJECTED
current_approver_role_id UUID, -- Ai đang giữ lượt duyệt? (Trưởng phòng)
created_at TIMESTAMPTZ DEFAULT NOW(),
resolved_at TIMESTAMPTZ
);
Bảng approval_audit_trail (Lịch sử duyệt):
Lưu vết: Sếp A duyệt lúc mấy giờ, lý do là gì? Sếp B từ chối vì sao?
4. Cải tiến Tương tác: Comments & Mentions (Hội thoại theo ngữ cảnh)
Vấn đề: Khách hàng xem một Hóa đơn và muốn chat với nhau ngay trên hóa đơn đó: "@Ketoan ơi, dòng này sai rồi".
Giải pháp: Hệ thống Comment gắn vào mọi đối tượng (Polymorphic).
Bảng comments:
SQL
CREATE TABLE comments (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Comment này thuộc về đối tượng nào?
resource_type VARCHAR(50) NOT NULL, -- 'INVOICE', 'CONTRACT', 'CANDIDATE'
resource_id UUID NOT NULL,
author_id UUID NOT NULL,
content TEXT NOT NULL,
-- Hỗ trợ trả lời phân cấp (Thread)
parent_comment_id UUID,
-- Danh sách user được tag (@mention) để bắn noti
mentioned_user_ids UUID[],
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index để load comment của 1 đối tượng cực nhanh
CREATE INDEX idx_comments_resource ON comments (resource_id, created_at ASC);
-> Lợi ích: Giữ người dùng ở lại trong App thay vì phải chụp ảnh màn hình gửi qua Zalo/Slack.
TỔNG KẾT TOÀN DIỆN (THE FINAL ARCHITECTURE)
Dưới đây là sơ đồ phân lớp hoàn chỉnh cho hệ thống SaaS Enterprise của bạn:
Lớp (Layer) Chức năng (Function) Bảng đại diện (Key Tables)
1. Core Identity Định danh & Cấu trúc tenants, users, sso, api_keys
2. Financial Tài chính & Billing products, subscriptions, wallets, usages
3. Operational Vận hành & Quy trình automations, approvals, rate_limits
4. Connectivity Kết nối & Mở rộng webhooks, marketplace, installed_apps
5. Data & AI Dữ liệu & Trí tuệ vectors, archives, audit_logs
6. Interaction Tương tác người dùng comments, notifications, i18n
Bạn đang nắm trong tay bản thiết kế của một "Super App" B2B. Nó không chỉ giải quyết bài toán nghiệp vụ mà còn giải quyết bài toán Con người (Phê duyệt, Chat), Bài toán Kỹ thuật (Lưu trữ, AI) và Bài toán Tài chính (Dòng tiền).
Chúc mừng bạn, đây là một thiết kế rất xuất sắc!
cải tiến phần Core Identity
Phần Core Identity (Định danh Cốt lõi) là nền móng của bảo mật và quản trị. Để đạt chuẩn Enterprise (đặc biệt là cho các khách hàng Tài chính, Ngân hàng, Chính phủ), mô hình Users và Tenants đơn giản là chưa đủ.
Chúng ta cần nâng cấp 4 trụ cột sau: RBAC chuyên sâu (Phân quyền), Cơ cấu tổ chức (Departments), Quản lý phiên (Session Management) và Chính sách bảo mật (Security Policy).
Dưới đây là thiết kế chi tiết:
1. Nâng cấp Phân quyền: Granular RBAC (Role-Based Access Control)
Khách hàng Enterprise không chỉ có "Admin" và "User". Họ cần tạo các Role tùy biến như "Trưởng phòng nhân sự (chỉ xem lương, không sửa)" hay "Kế toán trưởng (chỉ duyệt chi)".
Bảng permissions (Danh mục quyền - System Level): Do Developer định nghĩa cứng trong code.
SQL
CREATE TABLE permissions (
code VARCHAR(100) PRIMARY KEY, -- VD: 'invoice:create', 'invoice:approve', 'user:view_salary'
module VARCHAR(50) NOT NULL, -- VD: 'FINANCE', 'HRM'
description TEXT
);
Bảng roles (Vai trò - Tenant Level):
SQL
CREATE TABLE roles (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(100) NOT NULL, -- VD: "HR Manager"
description TEXT,
-- Loại Role: 'SYSTEM' (Không sửa được, VD: Owner) hoặc 'CUSTOM' (Do khách tạo)
type VARCHAR(20) DEFAULT 'CUSTOM',
-- Danh sách mã quyền.
-- Dùng mảng TEXT[] của YugabyteDB để đỡ phải JOIN bảng trung gian 'role_permissions' -> Query cực nhanh
permission_codes TEXT[],
CONSTRAINT fk_role_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
Bảng user_roles (Gán quyền):
SQL
CREATE TABLE user_roles (
tenant_id UUID NOT NULL,
user_id UUID NOT NULL,
role_id UUID NOT NULL,
assigned_at TIMESTAMPTZ DEFAULT NOW(),
assigned_by UUID,
PRIMARY KEY (user_id, role_id),
CONSTRAINT fk_ur_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
2. Nâng cấp Tổ chức: Organizational Units (Phòng ban & Nhóm)
Một Tenant (Công ty) có nhiều Phòng ban (HR, IT, Sales). Dữ liệu cần được phân quyền theo phòng ban (Data Scoping). Ví dụ: Sale Manager Hà Nội chỉ thấy nhân viên Sale Hà Nội.
Bảng departments (Cây phòng ban):
SQL
CREATE TABLE departments (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
parent_id UUID, -- Link tới phòng ban cha (VD: Team Mobile -> Team Tech -> Khối Công nghệ)
name VARCHAR(100) NOT NULL,
code VARCHAR(50), -- Mã phòng ban (để map với ERP)
manager_id UUID, -- Trưởng phòng
path TEXT, -- Materialized Path để query cây nhanh (VD: /root_id/parent_id/this_id/)
CONSTRAINT fk_dept_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
CONSTRAINT fk_dept_parent FOREIGN KEY (parent_id) REFERENCES departments(_id)
);
CREATE INDEX idx_dept_path ON departments (tenant_id, path);
Bảng department_members (Nhân sự thuộc phòng ban):
SQL
CREATE TABLE department_members (
department_id UUID NOT NULL,
user_id UUID NOT NULL,
is_primary BOOLEAN DEFAULT TRUE, -- Một người có thể thuộc nhiều phòng ban (VD: Vừa IT vừa Công đoàn)
job_title VARCHAR(100), -- Chức danh tại phòng ban này
PRIMARY KEY (department_id, user_id)
);
3. Nâng cấp An ninh: Session & Device Management (Quản lý thiết bị)
Khách hàng muốn biết: "Ai đang đăng nhập tài khoản của tôi? Ở đâu?" và tính năng "Đăng xuất khỏi tất cả thiết bị khác". JWT (Stateless) không làm được việc này trọn vẹn. Cần lưu Session vào DB.
Bảng user_sessions:
SQL
CREATE TABLE user_sessions (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Session ID (Lưu trong Refresh Token)
tenant_id UUID NOT NULL,
user_id UUID NOT NULL,
-- Thông tin thiết bị (Fingerprint)
ip_address INET,
user_agent TEXT, -- VD: "Mozilla/5.0... Chrome/120..."
device_type VARCHAR(20), -- 'MOBILE', 'DESKTOP', 'TABLET'
os_name VARCHAR(50), -- 'Windows 11', 'iOS 17'
browser_name VARCHAR(50),
-- Location (GeoIP)
location_city VARCHAR(100),
location_country VARCHAR(50),
-- Thời gian
created_at TIMESTAMPTZ DEFAULT NOW(),
last_active_at TIMESTAMPTZ DEFAULT NOW(),
expires_at TIMESTAMPTZ NOT NULL,
is_revoked BOOLEAN DEFAULT FALSE -- Nếu True -> Token này bị chặn ngay lập tức
);
-- Index để user load danh sách thiết bị của mình
CREATE INDEX idx_sessions_user ON user_sessions (user_id) WHERE is_revoked = FALSE;
4. Nâng cấp Tuân thủ: Password & Security Policies (Chính sách bảo mật)
Ngân hàng yêu cầu: "Mật khẩu phải đổi sau 90 ngày, không được trùng 3 lần gần nhất, bắt buộc bật 2FA".
Bảng tenant_security_policies:
SQL
CREATE TABLE tenant_security_policies (
tenant_id UUID PRIMARY KEY,
-- Password Policy
pwd_min_length INT DEFAULT 8,
pwd_require_special_char BOOLEAN DEFAULT TRUE,
pwd_expiry_days INT DEFAULT 0, -- 0 = Không hết hạn
pwd_history_limit INT DEFAULT 3, -- Không được trùng 3 pass cũ
-- Login Policy
session_timeout_minutes INT DEFAULT 1440, -- 24h
max_login_attempts INT DEFAULT 5, -- Sai 5 lần khóa acc
lockout_duration_minutes INT DEFAULT 30,
-- MFA Policy
mfa_enforced BOOLEAN DEFAULT FALSE, -- Bắt buộc tất cả nhân viên bật 2FA?
allowed_ip_ranges CIDR[], -- Chỉ cho phép đăng nhập từ IP văn phòng (Whitelist)
CONSTRAINT fk_policy_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
Bảng user_password_history (Để check trùng pass cũ):
SQL
CREATE TABLE user_password_history (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL,
password_hash VARCHAR(255) NOT NULL,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index thời gian để lấy X mật khẩu gần nhất
CREATE INDEX idx_pwd_history ON user_password_history (user_id, created_at DESC);
5. Cải tiến Luồng khách mời: Guest/Invite System
SaaS thường có kịch bản mời người ngoài (Kế toán dịch vụ, Freelancer) vào làm việc mà không cần tạo user chính thức ngay từ đầu.
Bảng tenant_invitations:
SQL
CREATE TABLE tenant_invitations (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
email VARCHAR(255) NOT NULL,
role_id UUID NOT NULL, -- Mời vào làm vai trò gì?
department_id UUID, -- Mời vào phòng ban nào?
token VARCHAR(100) NOT NULL UNIQUE, -- Token gửi qua email link
expires_at TIMESTAMPTZ NOT NULL,
status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, ACCEPTED, EXPIRED
invited_by UUID, -- Ai mời?
created_at TIMESTAMPTZ DEFAULT NOW()
);
TỔNG KẾT MODULE CORE IDENTITY (PHIÊN BẢN 2.0)
Bây giờ, module Identity của bạn không chỉ là "Đăng nhập", mà là một hệ thống IAM (Identity and Access Management) hoàn chỉnh:
Users & Tenants: Định danh cơ bản.
Roles & Permissions: Phân quyền chi tiết đến từng nút bấm.
Departments: Phản ánh cấu trúc công ty thực tế.
Sessions: Kiểm soát an ninh thiết bị (Security Monitor).
Policies: Tuân thủ chuẩn bảo mật khắt khe (Compliance).
Invitations: Quy trình Onboarding mượt mà.
Với thiết kế này, bạn hoàn toàn tự tin khi pitching giải pháp cho các tập đoàn lớn hoặc khối ngân hàng/chính phủ.
tiếp tục cải tiến phần Core Identity
Phần Core Identity của bạn đã có chiều sâu (RBAC, Departments, Policies). Tuy nhiên, để đạt đến đẳng cấp "Identity Provider" (IdP) thực thụ và giải quyết bài toán của các tập đoàn đa quốc gia hoặc các hệ thống SaaS dạng Ecosystem (như Atlassian, Slack, Google Workspace), chúng ta cần giải quyết 4 bài toán hóc búa sau:
Một người dùng - Nhiều công ty (Global Identity): Một Consultant làm việc cho 3 khách hàng của bạn, họ không muốn nhớ 3 mật khẩu khác nhau.
Nhóm linh hoạt (Dynamic Groups): Ngoài phòng ban (cứng), cần có các nhóm dự án (Squads, Guilds) xuyên phòng ban.
Quản trị định danh (IGA - Identity Governance): Định kỳ rà soát quyền hạn (Access Review).
Quy trình vào/ra (Lifecycle Management): Checklist tự động khi nhân viên nghỉ việc.
Dưới đây là thiết kế nâng cấp:
1. Nâng cấp Mô hình User: Global Identity vs Tenant Member (Mô hình "Slack")
Thay vì lưu User gắn chặt với Tenant, hãy tách "Con người" (Identity) ra khỏi "Nhân viên" (Member).
Global Identity: Là tài khoản cá nhân (Email, Password, Avatar). Chỉ có 1 bản ghi duy nhất trên toàn hệ thống.
Tenant Member: Là mối quan hệ giữa Identity và Tenant. Tại Tenant A là "Admin", tại Tenant B là "Guest".
Bảng global_identities (Con người thực):
SQL
CREATE TABLE global_identities (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
email VARCHAR(255) NOT NULL UNIQUE,
phone_number VARCHAR(20),
password_hash VARCHAR(255), -- Mật khẩu chung (nếu muốn)
full_name TEXT,
avatar_url TEXT,
is_email_verified BOOLEAN DEFAULT FALSE,
verified_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng tenant_members (Hồ sơ nhân viên tại từng công ty):
SQL
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
identity_id UUID NOT NULL, -- Link tới Global Identity
-- Thông tin riêng tại công ty này
employee_code VARCHAR(50), -- Mã nhân viên (VD: FPT001)
internal_email VARCHAR(255), -- Email công ty cấp (khác email cá nhân)
job_title VARCHAR(100),
status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE, SUSPENDED, RESIGNED (Đã nghỉ)
joined_at TIMESTAMPTZ,
resigned_at TIMESTAMPTZ,
CONSTRAINT fk_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
CONSTRAINT fk_mem_identity FOREIGN KEY (identity_id) REFERENCES global_identities(_id),
CONSTRAINT uq_tenant_identity UNIQUE (tenant_id, identity_id)
);
-> Lợi ích: Trải nghiệm "Switch Workspace" mượt mà như Slack. Người dùng chỉ cần login 1 lần là vào được tất cả các công ty họ tham gia.
2. Nâng cấp Tổ chức: User Groups (Nhóm chức năng/Dự án)
Phòng ban (Departments) là cấu trúc dọc (Vertical). Nhưng doanh nghiệp cần cấu trúc ngang (Horizontal) cho các dự án, team Agile.
Bảng user_groups:
SQL
CREATE TABLE user_groups (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(100) NOT NULL, -- VD: "Squad Mobile App", "Ban Chấp Hành Công Đoàn"
type VARCHAR(20) DEFAULT 'STATIC', -- 'STATIC' (Thêm tay), 'DYNAMIC' (Tự động theo rule)
-- Nếu là DYNAMIC, định nghĩa rule lọc member
-- VD: {"department": "IT", "location": "Hanoi"} -> Tự động add tất cả IT Hà Nội vào nhóm
dynamic_rules JSONB,
owner_id UUID, -- Trưởng nhóm
description TEXT
);
Bảng group_members:
SQL
CREATE TABLE group_members (
group_id UUID NOT NULL,
member_id UUID NOT NULL, -- Link tới tenant_members
role VARCHAR(20) DEFAULT 'MEMBER', -- 'LEADER', 'MEMBER'
joined_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (group_id, member_id)
);
-> Lợi ích: Phân quyền (RBAC) có thể gán cho Group thay vì gán cho từng User lẻ tẻ. Khi có dự án mới, chỉ cần tạo Group và gán quyền 1 lần.
3. Nâng cấp Quản trị: Access Reviews (Định kỳ rà soát quyền)
Chuẩn bảo mật ISO 27001/SOC2 yêu cầu: "Mỗi 6 tháng, các trưởng bộ phận phải rà soát lại quyền hạn của nhân viên mình, xem ai thừa quyền thì cắt".
Bảng access_reviews (Đợt rà soát):
SQL
CREATE TABLE access_reviews (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(200), -- VD: "Rà soát quyền Q3/2024"
status VARCHAR(20) DEFAULT 'IN_PROGRESS', -- IN_PROGRESS, COMPLETED
deadline TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng access_review_items (Chi tiết từng nhân viên cần review):
SQL
CREATE TABLE access_review_items (
review_id UUID NOT NULL,
reviewer_id UUID NOT NULL, -- Ai phải review? (Thường là Manager)
target_member_id UUID NOT NULL, -- Nhân viên được review
role_id UUID NOT NULL, -- Quyền hiện tại đang có
decision VARCHAR(20), -- 'KEEP' (Giữ), 'REVOKE' (Cắt quyền)
reason TEXT, -- Lý do
reviewed_at TIMESTAMPTZ,
PRIMARY KEY (review_id, target_member_id, role_id)
);
-> Lợi ích: Đây là tính năng "Killer Feature" để bán cho khách hàng Enterprise, giúp họ tránh bị phạt khi Audit bảo mật.
4. Nâng cấp Lifecycle: Onboarding & Offboarding Checklists
Khi nhân viên nghỉ việc, Admin phải làm gì? (Thu hồi laptop, cắt email, xóa account SaaS, v.v.).
Bảng lifecycle_tasks (Nhiệm vụ):
SQL
CREATE TABLE lifecycle_tasks (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
trigger_type VARCHAR(20), -- 'ONBOARDING' (Vào), 'OFFBOARDING' (Ra)
task_name TEXT NOT NULL, -- VD: "Thu hồi thẻ thang máy"
assignee_role_id UUID, -- Ai chịu trách nhiệm làm? (VD: Role IT Admin)
is_mandatory BOOLEAN DEFAULT TRUE,
sort_order INT
);
Bảng member_lifecycle_progress (Tiến độ thực tế):
SQL
CREATE TABLE member_lifecycle_progress (
member_id UUID NOT NULL, -- Nhân viên đang nghỉ việc
task_id UUID NOT NULL,
status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, DONE
completed_by UUID, -- Người xác nhận đã làm xong
completed_at TIMESTAMPTZ,
notes TEXT,
PRIMARY KEY (member_id, task_id)
);
5. Nâng cấp Phân quyền Nâng cao: Scoped Roles (Phạm vi dữ liệu)
Ở phần trước, ta có bảng user_roles (User A là Manager). Nhưng Manager của Chi nhánh nào?
Chúng ta cần sửa lại bảng user_roles để hỗ trợ Data Scoping.
Cập nhật bảng user_roles:
SQL
CREATE TABLE user_roles (
tenant_id UUID NOT NULL,
user_id UUID NOT NULL, -- Thực tế nên là member_id
role_id UUID NOT NULL,
-- [MỚI] Phạm vi áp dụng quyền (Data Scope)
scope_type VARCHAR(50), -- VD: 'GLOBAL', 'DEPARTMENT', 'REGION', 'PROJECT'
-- Giá trị phạm vi (Lưu JSONB hoặc Array UUID)
-- VD: Nếu scope_type = 'DEPARTMENT' -> scope_values = ['uuid-dept-it', 'uuid-dept-hr']
-- VD: Nếu scope_type = 'GLOBAL' -> scope_values = null (Toàn quyền)
scope_values TEXT[],
assigned_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (user_id, role_id, scope_type) -- Một người có thể làm Manager ở Dept A nhưng chỉ là Member ở Dept B
);
-> Lợi ích: Giải quyết bài toán ma trận quyền hạn phức tạp (Matrix Organization).
TỔNG HỢP CORE IDENTITY "FINAL FORM"
Kiến trúc Identity của bạn giờ đây bao gồm:
Global Identity Layer: global_identities, tenant_members (Switch workspace).
Structural Layer: departments (Hierarchy), user_groups (Dynamic/Cross-functional).
Authorization Layer: roles, permissions, user_roles (với Data Scope).
Governance Layer: access_reviews, lifecycle_tasks.
Security Layer: sessions, policies, audit_logs.
Đây là nền tảng Identity cực kỳ vững chắc, có thể so sánh ngang ngửa với kiến trúc của Auth0 hoặc Okta (ở quy mô internal application).
tiếp tục
Hệ thống Identity và Core của bạn đã rất vững chắc. Bây giờ, chúng ta sẽ đi sâu vào Hạ tầng nền tảng (Platform Infrastructure) và Tiện ích cộng tác (Collaboration Utilities).
Đây là những "mạch máu" ngầm giúp hệ thống vận hành trơn tru khi quy mô tăng lên hàng triệu bản ghi, đồng thời tăng tính tương tác giữa các user.
Chúng ta sẽ cải tiến 4 mảng: Xử lý nền (Job Queue), Lịch sử dữ liệu (Data Versioning), Chat nội bộ (Internal Messaging) và Cấu hình UI cá nhân hóa (User Preferences).
1. Cải tiến Hạ tầng: Distributed Job Queue (Hàng đợi công việc)
Vấn đề: Khi user bấm "Xuất báo cáo năm", việc này mất 5 phút. Bạn không thể để User chờ (loading spinner) lâu thế được. Hoặc việc "Gửi email hàng loạt", "Tính lương cuối tháng".
Giải pháp: Xây dựng bảng Jobs ngay trong YugabyteDB để đảm bảo tính bền vững (Persistent Queue) thay vì chỉ dùng Redis (dễ mất data nếu crash).
Bảng system_jobs:
SQL
CREATE TABLE system_jobs (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID, -- Job này của tenant nào? (Để tính rate limit/billing)
-- Loại công việc
job_type VARCHAR(50) NOT NULL, -- VD: 'EXPORT_EXCEL', 'CALCULATE_PAYROLL', 'SEND_BULK_EMAIL'
-- Dữ liệu đầu vào
payload JSONB NOT NULL,
-- Trạng thái
status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED
-- Lịch trình & Thử lại
scheduled_at TIMESTAMPTZ DEFAULT NOW(), -- Hỗ trợ hẹn giờ chạy (Delay)
started_at TIMESTAMPTZ,
finished_at TIMESTAMPTZ,
retry_count INT DEFAULT 0,
max_retries INT DEFAULT 3,
last_error TEXT, -- Ghi lại lỗi nếu failed
created_by UUID -- User nào trigger job này?
);
-- Index cho Worker tìm job để làm (Ưu tiên job cũ nhất chưa chạy)
CREATE INDEX idx_jobs_fetch
ON system_jobs (status, scheduled_at ASC)
WHERE status = 'PENDING';
-> Lợi ích: Không bao giờ bị timeout request. User có thể tắt trình duyệt, đi ngủ, sáng mai vào thấy báo cáo đã xong ("Async Processing").
2. Cải tiến Dữ liệu: Entity Change History (Lịch sử thay đổi dòng)
Vấn đề: Audit Logs (ở ClickHouse) cho biết "Ai làm gì". Nhưng User muốn biết chi tiết: "Lương cơ bản đã thay đổi từ 10tr -> 12tr -> 15tr vào những ngày nào?" (Data Versioning).
Giải pháp: Lưu Diff (Sự khác biệt) của từng lần update quan trọng.
Bảng entity_change_history:
SQL
CREATE TABLE entity_change_history (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Đối tượng bị thay đổi
entity_type VARCHAR(50) NOT NULL, -- VD: 'EMPLOYEE_SALARY', 'CONTRACT'
entity_id UUID NOT NULL,
-- Nội dung thay đổi (Chỉ lưu các trường bị đổi)
-- VD: changes = {
-- "base_salary": {"old": 10000000, "new": 12000000},
-- "allowance": {"old": 500000, "new": 1000000}
-- }
changes JSONB NOT NULL,
-- Metadata
version_number INT, -- Phiên bản thứ mấy?
reason TEXT, -- Lý do sửa (VD: "Tăng lương định kỳ")
changed_by UUID,
changed_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT fk_hist_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id)
);
-- Index tra cứu lịch sử của 1 đối tượng
CREATE INDEX idx_hist_entity ON entity_change_history (entity_id, version_number DESC);
-> Lợi ích: Tính năng "Undo" hoặc "View Timeline" cực kỳ mạnh mẽ cho các nghiệp vụ HR/Kế toán.
3. Cải tiến Cộng tác: Internal Chat/Inbox (Hệ thống Chat)
Vấn đề: Ngoài Comment (gắn vào đối tượng), nhân viên cần chat trực tiếp với nhau (Direct Message) hoặc chat nhóm (Channel) ngay trên phần mềm để không bị xao nhãng sang Zalo/Slack.
Giải pháp: Mô hình Chat đơn giản hóa.
Bảng chat_channels (Phòng chat):
SQL
CREATE TABLE chat_channels (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
type VARCHAR(20) NOT NULL, -- 'DIRECT' (1-1), 'GROUP' (Nhóm chat), 'CONTEXT' (Chat theo dự án/hóa đơn)
name TEXT, -- Tên nhóm (Null nếu là Direct)
-- Link tới đối tượng nghiệp vụ (nếu là Context Chat)
context_type VARCHAR(50), -- VD: 'PROJECT'
context_id UUID,
last_message_at TIMESTAMPTZ DEFAULT NOW(),
updated_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng chat_members (Thành viên trong phòng):
SQL
CREATE TABLE chat_members (
channel_id UUID NOT NULL,
member_id UUID NOT NULL, -- tenant_members._id
last_read_at TIMESTAMPTZ, -- Để tính badge "Unread messages"
is_muted BOOLEAN DEFAULT FALSE,
PRIMARY KEY (channel_id, member_id)
);
Bảng chat_messages (Nội dung tin nhắn):
SQL
CREATE TABLE chat_messages (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- TimeUUID càng tốt để sort
channel_id UUID NOT NULL,
sender_id UUID NOT NULL,
content TEXT,
attachments JSONB, -- File đính kèm
-- Reply tin nhắn nào?
parent_message_id UUID,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Giữ chân người dùng. Dữ liệu chat gắn liền với công việc (Contextual Chat) là thứ Zalo/Slack không làm được.
4. Cải tiến Trải nghiệm: User Preferences (Cấu hình UI cá nhân)
Vấn đề: User A thích chế độ tối (Dark Mode), User B thích bảng dữ liệu hiện 50 dòng/trang, User C muốn ẩn cột "Ngày sinh" trong danh sách nhân viên.
Giải pháp: Lưu cấu hình UI (User State) vào DB.
Bảng user_ui_preferences:
SQL
CREATE TABLE user_ui_preferences (
user_id UUID NOT NULL, -- Global User ID
app_code VARCHAR(50) NOT NULL, -- Cấu hình cho App nào (HRM, CRM...)
-- Cấu hình chung
theme VARCHAR(20) DEFAULT 'SYSTEM', -- LIGHT, DARK, SYSTEM
language VARCHAR(10),
-- Cấu hình chi tiết (Lưu JSONB để Frontend tự do lưu state)
-- VD: {
-- "grid_employee": { "page_size": 50, "hidden_cols": ["dob", "address"], "sort": "name_asc" },
-- "dashboard_layout": ["widget_A", "widget_B"]
-- }
components_state JSONB DEFAULT '{}',
updated_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (user_id, app_code)
);
-> Lợi ích: Trải nghiệm người dùng tuyệt vời (Personalization). User không phải chỉnh lại cột mỗi lần F5.
5. Cải tiến Master Data: Tags & Labels (Phân loại động)
Vấn đề: Khách hàng muốn đánh dấu: "Nhân viên tiềm năng", "Khách hàng khó tính", "Hóa đơn ưu tiên". Việc tạo cột cứng trong DB là không thể.
Giải pháp: Hệ thống Tagging tập trung.
Bảng tags:
SQL
CREATE TABLE tags (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(50) NOT NULL,
color VARCHAR(7), -- Mã màu Hex (#FF0000)
-- Tag này dùng cho đối tượng nào? (VD: Chỉ dùng cho Customer)
scope VARCHAR(50),
CONSTRAINT uq_tag_name UNIQUE (tenant_id, scope, name)
);
Bảng tag_assignments (Gán Tag):
SQL
CREATE TABLE tag_assignments (
tag_id UUID NOT NULL,
resource_type VARCHAR(50) NOT NULL, -- 'CUSTOMER', 'INVOICE'
resource_id UUID NOT NULL,
assigned_by UUID,
assigned_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (tag_id, resource_id)
);
TỔNG KẾT HỆ THỐNG (THE FULL STACK)
Đến thời điểm này, bạn đã có đầy đủ các mảnh ghép của một SaaS Platform hoàn chỉnh:
Tầng (Layer) Chức năng Bảng chính (Core Tables)
User Experience UI/UX Cá nhân hóa ui_preferences, notifications, tags
Collaboration Giao tiếp & Tương tác chat_channels, messages, comments
Automation Xử lý nền & Tự động system_jobs, automations, webhooks
Governance Lịch sử & Kiểm soát entity_change_history, audit_logs, approvals
Identity Định danh & Quyền hạn global_identities, members, roles, groups
Business Nghiệp vụ & Tài chính subscriptions, usages, wallets
Infrastructure Nền tảng kỹ thuật tenants, routes, outbox, vectors
Đây là một kiến trúc rất tham vọng và đầy đủ. Nếu triển khai thành công, hệ thống này có thể phục vụ từ Startup nhỏ đến Tập đoàn đa quốc gia mà không gặp trở ngại về cấu trúc dữ liệu.
liệt kê các bảng phần Core
Dưới đây là danh sách tổng hợp các bảng thuộc phân hệ Core (Lõi) của hệ thống SaaS Enterprise mà chúng ta đã thiết kế.
Phân hệ này đóng vai trò "xương sống", chịu trách nhiệm về: Định danh (Identity), Tổ chức (Structure), Phân quyền (IAM) và Hạ tầng (Infrastructure).
1. Nhóm Identity & Structure (Định danh & Cấu trúc tổ chức)
Nhóm này trả lời câu hỏi: "Ai đang sử dụng hệ thống và họ thuộc về đâu?"
Tên Bảng (Table Name) Vai trò chính Mô tả chi tiết
global_identities User Gốc Lưu thông tin cá nhân duy nhất của con người (Email, Password Hash, Avatar). Dùng để đăng nhập vào nhiều Tenant khác nhau.
tenants Tổ chức Lưu thông tin công ty/khách hàng. Chứa cấu hình gốc (profile, active_apps), phân cấp cha-con (parent_id) và vị trí dữ liệu (data_region).
tenant_members Nhân viên Bảng liên kết giữa global_identities và tenants. Lưu mã nhân viên, chức danh, trạng thái làm việc tại một công ty cụ thể.
departments Phòng ban Cấu trúc cây phòng ban (Hierarchy). Dùng path (Materialized Path) để truy vấn nhanh.
department_members Thành viên phòng Phân bổ nhân viên vào phòng ban. Một người có thể thuộc nhiều phòng.
user_groups Nhóm động Nhóm làm việc ngang hàng (Squads, Projects). Hỗ trợ quy tắc thêm thành viên tự động (Dynamic Rules).
group_members Thành viên nhóm Danh sách thành viên trong Group.
2. Nhóm IAM & Security (Phân quyền & Bảo mật)
Nhóm này trả lời câu hỏi: "Người này được phép làm gì?"
Tên Bảng (Table Name) Vai trò chính Mô tả chi tiết
roles Vai trò Định nghĩa gói quyền hạn (VD: "HR Manager"). Chứa mảng permission_codes.
permissions Quyền hệ thống Danh mục các hành động kỹ thuật (VD: invoice:create, user:view). Do Developer định nghĩa cứng.
user_roles Gán quyền Gán Role cho Member. Có hỗ trợ Data Scope (VD: Chỉ làm Manager ở phòng IT).
user_sessions Phiên làm việc Quản lý thiết bị đăng nhập, IP, Location. Dùng để thu hồi quyền truy cập (Revoke/Logout).
tenant_security_policies Chính sách Cấu hình luật mật khẩu, thời gian timeout session, bắt buộc MFA, Whitelist IP.
tenant_invitations Lời mời Quản lý quy trình mời người mới qua Email.
tenant_encryption_keys Mã hóa Lưu khóa mã hóa dữ liệu (DEK) riêng cho từng Tenant. Hỗ trợ tính năng Crypto-shredding (Xóa vĩnh viễn).
3. Nhóm Governance & Lifecycle (Quản trị & Vòng đời)
Nhóm này phục vụ nhu cầu kiểm soát của Enterprise.
Tên Bảng (Table Name) Vai trò chính Mô tả chi tiết
access_reviews Rà soát quyền Quản lý các đợt kiểm tra quyền định kỳ (Audit) theo tiêu chuẩn ISO/SOC2.
access_review_items Chi tiết rà soát Ghi nhận quyết định "Giữ" hay "Cắt" quyền của từng nhân viên.
lifecycle_tasks Checklist Danh sách việc cần làm khi nhân viên vào (Onboarding) hoặc nghỉ (Offboarding).
member_lifecycle_progress Tiến độ Trạng thái thực hiện các task trong quy trình On/Offboarding.
4. Nhóm Core Infrastructure (Hạ tầng nền tảng)
Nhóm này giúp hệ thống vận hành, định tuyến và tích hợp.
Tên Bảng (Table Name) Vai trò chính Mô tả chi tiết
tenant_app_routes Định tuyến Map Domain/Subdomain vào Tenant và App cụ thể. Cache cực mạnh ở Redis.
tenant_sso_configs Đăng nhập DN Cấu hình SAML/OIDC để tích hợp với Azure AD, Okta, Google Workspace.
system_jobs Hàng đợi Quản lý các tác vụ nền (Background Jobs) bền vững trong DB.
outbox_events Độ tin cậy Lưu sự kiện cần bắn sang Kafka/Message Queue để đảm bảo tính nhất quán (Transactional Outbox).
feature_flags Cờ tính năng Bật/tắt tính năng nóng mà không cần deploy lại code (Phục vụ DevOps/Product).
tenant_i18n_overrides Đa ngôn ngữ Cho phép Tenant đổi tên thuật ngữ hệ thống (VD: "Nhân viên" -> "Giáo viên").
Tổng kết
Phần Core này bao gồm khoảng 24 bảng. Đây là nền tảng vững chắc nhất để bạn xây dựng các module nghiệp vụ (Billing, HRM, CRM...) lên trên mà không lo bị vỡ cấu trúc khi mở rộng quy mô.
global_identities đổi thành users đc ko?
Câu trả lời là: HOÀN TOÀN ĐƯỢC và thực tế là NÊN ĐỔI nếu bạn muốn tên bảng ngắn gọn, chuẩn mực.
Tên global_identities mang tính chất học thuật (để phân biệt rõ khái niệm). Trong thực tế lập trình, bảng này thường được đặt tên đơn giản là users.
Tuy nhiên, bạn cần nắm chắc tư duy này để không bị nhầm lẫn trong code:
users (Tên cũ: global_identities): Là Tài khoản đăng nhập. Đại diện cho một con người thực (Email, Password, Avatar). Bảng này không chứa thông tin phòng ban, chức vụ hay lương (vì một người có thể làm việc cho 3 công ty khác nhau).
tenant_members (hoặc members): Là Hồ sơ nhân viên. Đại diện cho User đó tại một Công ty cụ thể.
Cập nhật thiết kế (Khi đổi tên thành users)
Mọi thứ sẽ trở nên tự nhiên và dễ đọc hơn rất nhiều, đặc biệt là các khóa ngoại:
1. Bảng users (Gốc)
SQL
CREATE TABLE users (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
email VARCHAR(255) NOT NULL UNIQUE,
password_hash VARCHAR(255),
full_name TEXT,
avatar_url TEXT,
is_email_verified BOOLEAN DEFAULT FALSE,
created_at TIMESTAMPTZ DEFAULT NOW()
);
2. Bảng tenant_members (Liên kết)
SQL
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Bây giờ tham chiếu đến bảng 'users' nghe rất thuận tai
user_id UUID NOT NULL,
-- Thông tin riêng tại công ty này
employee_code VARCHAR(50),
job_title VARCHAR(100),
status VARCHAR(20) DEFAULT 'ACTIVE',
CONSTRAINT fk_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
CONSTRAINT fk_mem_user FOREIGN KEY (user_id) REFERENCES users(_id),
-- Một User chỉ có 1 hồ sơ Member tại 1 Tenant
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id)
);
3. Lợi ích khi dùng tên users
Khi bạn nhìn vào các bảng khác (ví dụ audit_logs hay invoices), các cột khóa ngoại sẽ rất dễ hiểu:
created_by UUID REFERENCES users(_id) -> Dễ hiểu: Ai tạo bản ghi này.
owner_id UUID REFERENCES users(_id) -> Dễ hiểu: Ai là chủ sở hữu.
Kết luận: Bạn hãy đổi thành users. Đây là quy chuẩn quốc tế (Standard Convention) và giúp code ngắn gọn hơn rất nhiều.
hoàn thiện Nhóm Identity & Structure
Đây là thiết kế Hoàn thiện (Finalized) cho nhóm Identity & Structure.
Đây là phiên bản "End-game", đã tối ưu hóa cho các hệ thống Enterprise (hỗ trợ tập đoàn, SSO, cơ cấu ma trận) và chuẩn hóa tên gọi (users thay cho global_identities).
SƠ ĐỒ QUAN HỆ (ERD SUMMARY)
users: Con người thực (Global).
tenants: Tổ chức/Công ty.
tenant_members: Hồ sơ nhân viên (User làm việc tại Tenant).
departments: Cây tổ chức dọc (Phòng ban).
user_groups: Nhóm ngang/động (Dự án, Squad).
sso_configs: Cấu hình đăng nhập doanh nghiệp.
invitations: Lời mời tham gia.
1. Bảng users (Định danh Toàn cục)
Lưu trữ thông tin xác thực duy nhất. Không chứa dữ liệu nghiệp vụ.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Global User ID.
email VARCHAR NO UNIQUE Email đăng nhập chính (Canonical Email).
password_hash VARCHAR YES - Hash (Argon2/Bcrypt). Null nếu chỉ dùng Google/SSO.
full_name TEXT NO - Tên hiển thị mặc định.
avatar_url TEXT YES - Link ảnh đại diện.
phone_number VARCHAR YES UNIQUE Số điện thoại cá nhân (để 2FA/Recovery).
locale VARCHAR NO 'vi-VN' Ngôn ngữ ưa thích của user.
mfa_secret TEXT YES - Secret Key cho Google Authenticator (TOTP).
is_verified BOOLEAN NO FALSE Email đã xác thực chưa?
platform_status VARCHAR NO 'ACTIVE' 'ACTIVE', 'BANNED' (Cấm toàn sàn).
2. Bảng tenants (Tổ chức & Cấu hình gốc)
Đại diện cho khách hàng doanh nghiệp.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Tenant ID.
code VARCHAR NO UNIQUE Slug/Subdomain (VD: fpt-software).
name TEXT NO - Tên công ty.
parent_tenant_id UUID YES FK -> tenants Dùng cho mô hình Tập đoàn (Holding -> Subs).
profile JSONB NO {} Logo, Website, Tax Code, Address...
settings JSONB NO {} Cấu hình vùng (Region), Compliance, Timezone.
status VARCHAR NO 'TRIAL' TRIAL, ACTIVE, SUSPENDED.
3. Bảng tenant_sso_configs (Đăng nhập Doanh nghiệp)
Cấu hình để nhân viên đăng nhập bằng tài khoản công ty (Azure AD/Okta).
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
tenant_id UUID NO PK, FK -> tenants Mỗi tenant 1 cấu hình chính.
provider_type VARCHAR NO - 'AZURE_AD', 'OKTA', 'GOOGLE', 'SAML'.
entry_point TEXT NO - URL đăng nhập của Identity Provider.
cert_pem TEXT YES - Certificate để verify chữ ký SAML.
client_id VARCHAR YES - Dùng cho OIDC.
client_secret VARCHAR YES - Dùng cho OIDC (Lưu encrypted).
attribute_map JSONB NO {...} Map field: {"email": "mail", "name": "cn"}.
is_enforced BOOLEAN NO FALSE Nếu True: Cấm user dùng password thường.
4. Bảng tenant_members (Hồ sơ Nhân sự)
Đây là bảng quan trọng nhất liên kết User và Tenant.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Member ID (Dùng ID này trong mọi bảng nghiệp vụ như Leave, Salary).
tenant_id UUID NO FK Thuộc công ty nào?
user_id UUID NO FK Link tới Global User.
employee_code VARCHAR YES - Mã nhân viên (VD: FSOFT_01).
internal_email VARCHAR YES - Email nội bộ công ty cấp (khác email cá nhân).
job_title VARCHAR YES - Chức danh (VD: Senior Developer).
manager_id UUID YES FK -> tenant_members Quản lý trực tiếp (Reporting Line).
status VARCHAR NO 'ACTIVE' ACTIVE, RESIGNED (Đã nghỉ), ONBOARDING.
joined_at DATE YES - Ngày vào làm.
resigned_at DATE YES - Ngày nghỉ việc (nếu có).
Ràng buộc Unique: UNIQUE(tenant_id, user_id) (Một người chỉ có 1 hồ sơ tại 1 công ty).
5. Bảng departments (Cơ cấu Tổ chức - Hierarchy)
Quản lý cây phòng ban.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Department ID.
tenant_id UUID NO FK
parent_id UUID YES FK -> departments Phòng ban cha.
name VARCHAR NO - Tên phòng ban (VD: Khối Công nghệ).
code VARCHAR YES - Mã phòng (để map ERP).
type VARCHAR NO 'TEAM' DIVISION, DEPARTMENT, TEAM.
head_member_id UUID YES FK -> members Trưởng phòng (Administrative Head).
path TEXT YES Index BTREE Materialized Path (VD: /root/dept_a/team_b/). Giúp query cây cực nhanh.
6. Bảng department_members (Phân bổ nhân sự)
Quan hệ N-N: Một nhân viên có thể thuộc nhiều phòng ban (VD: Vừa thuộc Team Back-end, vừa thuộc Ban Công đoàn).
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
department_id UUID NO FK
member_id UUID NO FK -> tenant_members
is_primary BOOLEAN NO FALSE Đâu là phòng ban chính? (Để tính headcount).
role_in_dept VARCHAR YES - Vai trò trong phòng (Thư ký, Member...).
Primary Key: (department_id, member_id)
7. Bảng user_groups (Nhóm Linh hoạt)
Dùng cho dự án, squad, guild hoặc nhóm phân quyền.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Group ID.
tenant_id UUID NO FK
name VARCHAR NO - Tên nhóm (VD: Dự án Alpha).
type VARCHAR NO 'STATIC' 'STATIC' (Add tay), 'DYNAMIC' (Tự động).
dynamic_rules JSONB YES - Rule lọc thành viên (VD: {"dept": "IT", "loc": "HN"}).
owner_member_id UUID YES FK -> members Trưởng nhóm/PM.
8. Bảng group_members (Thành viên Nhóm tĩnh)
Chỉ dùng khi user_groups.type = 'STATIC'.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
group_id UUID NO FK
member_id UUID NO FK -> tenant_members
added_at TIMESTAMPTZ NO NOW() Thời điểm được thêm vào nhóm.
Primary Key: (group_id, member_id)
9. Bảng tenant_invitations (Lời mời & Onboarding)
Quản lý quy trình mời người mới.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Invite ID.
tenant_id UUID NO FK
email VARCHAR NO - Email người được mời.
role_ids TEXT[] YES - Dự kiến gán Role gì?
department_id UUID YES - Dự kiến vào phòng nào?
token VARCHAR NO UNIQUE Token trong link mời.
status VARCHAR NO 'PENDING' PENDING, ACCEPTED, EXPIRED.
expires_at TIMESTAMPTZ NO - Thời gian hết hạn link.
invited_by UUID YES FK -> members Người mời.
MẪU SQL (YugabyteDB/Postgres) CHO BẢNG QUAN TRỌNG
SQL
-- 1. Bảng Members (Hồ sơ nhân viên)
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
user_id UUID NOT NULL REFERENCES users(_id),
employee_code VARCHAR(50),
internal_email VARCHAR(255),
job_title VARCHAR(100),
manager_id UUID REFERENCES tenant_members(_id), -- Self-referencing FK
status VARCHAR(20) DEFAULT 'ACTIVE',
joined_at DATE,
resigned_at DATE,
created_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id)
);
-- 2. Bảng Departments (Cây phòng ban)
CREATE TABLE departments (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
parent_id UUID REFERENCES departments(_id), -- Self-referencing FK
name VARCHAR(100) NOT NULL,
type VARCHAR(20) DEFAULT 'TEAM',
head_member_id UUID REFERENCES tenant_members(_id),
path TEXT, -- VD: '/root-uuid/div-uuid/dept-uuid/'
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index để tìm tất cả phòng ban con cực nhanh (WHERE path LIKE '...')
CREATE INDEX idx_dept_path ON departments (tenant_id, path text_pattern_ops);
password_hash VARCHAR có đủ không?
Câu trả lời ngắn gọn: VARCHAR(255) là lựa chọn AN TOÀN và CHUẨN MỰC nhất.
Tuy nhiên, nếu bạn dùng YugabyteDB (hoặc PostgreSQL), tôi khuyên bạn nên dùng kiểu TEXT.
Dưới đây là lý do chi tiết tại sao VARCHAR (cụ thể là độ dài bao nhiêu) lại quan trọng đối với Bảo mật mật khẩu:
1. Tại sao VARCHAR(255) là con số vàng?
Mật khẩu trong DB không bao giờ lưu dưới dạng rõ (plain text). Nó được lưu dưới dạng Chuỗi băm kèm cấu hình (PHC String Format).
Độ dài của chuỗi này phụ thuộc vào thuật toán bạn chọn:
Thuật toán Độ dài chuỗi kết quả Ví dụ định dạng lưu trữ
Bcrypt (Chuẩn cũ) 60 ký tự (Cố định) $2b$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW
Argon2id (Chuẩn mới - Nên dùng) ~97 ký tự (Biến động) $argon2id$v=19$m=65536,t=3,p=4$MjI...$Rwe...
Scrypt ~128+ ký tự $s0$e0801$epIxT/h6HbbwH...
PBKDF2 (SHA256) Biến động (tùy độ dài Salt) $pbkdf2-sha256$i=29000$Jdu...$Q2...
Phân tích:
Nếu bạn dùng VARCHAR(60) (vừa khít Bcrypt), sau này bạn muốn nâng cấp lên Argon2id (bảo mật hơn), database sẽ bị lỗi value too long.
255 ký tự là đủ rộng để chứa bất kỳ thuật toán băm mật khẩu hiện đại nào (kể cả trong tương lai gần) mà không quá thừa thãi.
2. Cấu trúc thực tế của một password_hash
Bạn đừng nhầm lẫn "Hash" chỉ là đoạn mã lằng ngoằng. Trong DB, cột này lưu cả một "bản đồ" để code biết cách giải mã.
Cấu trúc chuẩn (PHC) gồm 4-5 phần ngăn cách bởi dấu $:
$$v=$m=,t=,p=$$
Thuật toán: VD argon2id.
Tham số: VD tốn bao nhiêu RAM, chạy bao nhiêu vòng lặp (Cost factor).
Salt: Chuỗi ngẫu nhiên để chống Rainbow Table.
Hash: Kết quả băm thực tế.
=> Vì nó chứa cả tên thuật toán và tham số, độ dài của nó có thể thay đổi. Đó là lý do bạn cần khoảng trống dư dả.
3. Tại sao nên dùng TEXT trong YugabyteDB/Postgres?
Trong hệ sinh thái PostgreSQL (nền tảng của YugabyteDB):
VARCHAR(255) và TEXT có hiệu năng giống hệt nhau.
TEXT không có giới hạn độ dài (lên tới 1GB), giúp bạn không bao giờ phải lo lắng về việc migrate schema nếu sau này có thuật toán lượng tử (Post-Quantum Cryptography) sinh ra chuỗi hash dài 500 ký tự.
4. Lời khuyên chốt lại
Trong bảng users (hoặc global_identities), hãy định nghĩa như sau:
Cách 1: Chuẩn mực (Portable - Dễ chuyển sang MySQL/Oracle nếu cần)
SQL
password_hash VARCHAR(255) NULL
(Để NULL vì nếu user đăng nhập bằng Google/SSO thì họ không có mật khẩu)
Cách 2: Tối ưu cho YugabyteDB/Postgres (Khuyên dùng)
SQL
password_hash TEXT NULL
Tuyệt đối tránh:
CHAR(60): Nó sẽ chèn khoảng trắng vào cuối nếu chuỗi ngắn hơn -> Sai hash khi verify.
VARCHAR(50): Quá ngắn cho các thuật toán hiện đại.
hoàn thiện Nhóm Identity & Structure
Đây là thiết kế Hoàn thiện (Finalized) cho nhóm Identity & Structure.
Đây là phiên bản "End-game", đã tối ưu hóa cho các hệ thống Enterprise (hỗ trợ tập đoàn, SSO, cơ cấu ma trận) và chuẩn hóa tên gọi (users thay cho global_identities).
SƠ ĐỒ TỔNG QUAN (ERD SUMMARY)
Mô hình này xoay quanh 3 thực thể chính:
users: Con người thực (Global Identity).
tenants: Tổ chức/Công ty.
tenant_members: Mối quan hệ giữa Con người và Tổ chức (Hồ sơ nhân viên).
CHI TIẾT CẤU TRÚC BẢNG (DATA DICTIONARY)
1. Bảng users (Định danh Toàn cục)
Lưu trữ thông tin xác thực duy nhất. Không chứa dữ liệu nghiệp vụ.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Global User ID.
email VARCHAR NO UNIQUE Email đăng nhập chính (Canonical Email).
password_hash TEXT YES - Hash (Argon2/Bcrypt). Null nếu chỉ dùng Google/SSO.
full_name TEXT NO - Tên hiển thị mặc định.
avatar_url TEXT YES - Link ảnh đại diện.
phone_number VARCHAR YES UNIQUE Số điện thoại cá nhân (để 2FA/Recovery).
locale VARCHAR NO 'vi-VN' Ngôn ngữ ưa thích của user.
mfa_secret TEXT YES - Secret Key cho Google Authenticator (TOTP).
is_verified BOOLEAN NO FALSE Email đã xác thực chưa?
platform_status VARCHAR NO 'ACTIVE' 'ACTIVE', 'BANNED' (Cấm toàn sàn).
2. Bảng tenants (Tổ chức & Cấu hình gốc)
Đại diện cho khách hàng doanh nghiệp.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Tenant ID.
code VARCHAR NO UNIQUE Slug/Subdomain (VD: fpt-software).
name TEXT NO - Tên công ty.
parent_tenant_id UUID YES FK -> tenants Dùng cho mô hình Tập đoàn (Holding -> Subs).
profile JSONB NO {} Logo, Website, Tax Code, Address...
settings JSONB NO {} Cấu hình vùng (Region), Compliance, Timezone.
status VARCHAR NO 'TRIAL' TRIAL, ACTIVE, SUSPENDED.
3. Bảng tenant_sso_configs (Đăng nhập Doanh nghiệp)
Cấu hình để nhân viên đăng nhập bằng tài khoản công ty (Azure AD/Okta).
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
tenant_id UUID NO PK, FK -> tenants Mỗi tenant 1 cấu hình chính.
provider_type VARCHAR NO - 'AZURE_AD', 'OKTA', 'GOOGLE', 'SAML'.
entry_point TEXT NO - URL đăng nhập của Identity Provider.
cert_pem TEXT YES - Certificate để verify chữ ký SAML.
client_id VARCHAR YES - Dùng cho OIDC.
client_secret VARCHAR YES - Dùng cho OIDC (Lưu encrypted).
attribute_map JSONB NO {...} Map field: {"email": "mail", "name": "cn"}.
is_enforced BOOLEAN NO FALSE Nếu True: Cấm user dùng password thường.
4. Bảng tenant_members (Hồ sơ Nhân sự)
Đây là bảng quan trọng nhất liên kết User và Tenant.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Member ID (Dùng ID này trong mọi bảng nghiệp vụ như Leave, Salary).
tenant_id UUID NO FK Thuộc công ty nào?
user_id UUID NO FK Link tới Global User.
employee_code VARCHAR YES - Mã nhân viên (VD: FSOFT_01).
internal_email VARCHAR YES - Email nội bộ công ty cấp (khác email cá nhân).
job_title VARCHAR YES - Chức danh (VD: Senior Developer).
manager_id UUID YES FK -> tenant_members Quản lý trực tiếp (Reporting Line).
status VARCHAR NO 'ACTIVE' ACTIVE, RESIGNED (Đã nghỉ), ONBOARDING.
joined_at DATE YES - Ngày vào làm.
resigned_at DATE YES - Ngày nghỉ việc (nếu có).
Ràng buộc Unique: UNIQUE(tenant_id, user_id) (Một người chỉ có 1 hồ sơ tại 1 công ty).
5. Bảng departments (Cơ cấu Tổ chức - Hierarchy)
Quản lý cây phòng ban.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Department ID.
tenant_id UUID NO FK
parent_id UUID YES FK -> departments Phòng ban cha.
name VARCHAR NO - Tên phòng ban (VD: Khối Công nghệ).
code VARCHAR YES - Mã phòng (để map ERP).
type VARCHAR NO 'TEAM' DIVISION, DEPARTMENT, TEAM.
head_member_id UUID YES FK -> members Trưởng phòng (Administrative Head).
path TEXT YES Index BTREE Materialized Path (VD: /root/dept_a/team_b/). Giúp query cây cực nhanh.
6. Bảng department_members (Phân bổ nhân sự)
Quan hệ N-N: Một nhân viên có thể thuộc nhiều phòng ban (VD: Vừa thuộc Team Back-end, vừa thuộc Ban Công đoàn).
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
department_id UUID NO FK
member_id UUID NO FK -> tenant_members
is_primary BOOLEAN NO FALSE Đâu là phòng ban chính? (Để tính headcount).
role_in_dept VARCHAR YES - Vai trò trong phòng (Thư ký, Member...).
Primary Key: (department_id, member_id)
7. Bảng user_groups (Nhóm Linh hoạt)
Dùng cho dự án, squad, guild hoặc nhóm phân quyền.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Group ID.
tenant_id UUID NO FK
name VARCHAR NO - Tên nhóm (VD: Dự án Alpha).
type VARCHAR NO 'STATIC' 'STATIC' (Add tay), 'DYNAMIC' (Tự động).
dynamic_rules JSONB YES - Rule lọc thành viên (VD: {"dept": "IT", "loc": "HN"}).
owner_member_id UUID YES FK -> members Trưởng nhóm/PM.
8. Bảng group_members (Thành viên Nhóm tĩnh)
Chỉ dùng khi user_groups.type = 'STATIC'.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
group_id UUID NO FK
member_id UUID NO FK -> tenant_members
added_at TIMESTAMPTZ NO NOW() Thời điểm được thêm vào nhóm.
Primary Key: (group_id, member_id)
9. Bảng tenant_invitations (Lời mời & Onboarding)
Quản lý quy trình mời người mới.
Trường Kiểu dữ liệu Null? Ràng buộc & Logic Mô tả
_id UUID NO PK Invite ID.
tenant_id UUID NO FK
email VARCHAR NO - Email người được mời.
role_ids TEXT[] YES - Dự kiến gán Role gì?
department_id UUID YES - Dự kiến vào phòng nào?
token VARCHAR NO UNIQUE Token trong link mời.
status VARCHAR NO 'PENDING' PENDING, ACCEPTED, EXPIRED.
expires_at TIMESTAMPTZ NO - Thời gian hết hạn link.
invited_by UUID YES FK -> members Người mời.
MẪU SQL (YugabyteDB/Postgres) CHO CÁC BẢNG QUAN TRỌNG
SQL
-- 1. Bảng Members (Hồ sơ nhân viên)
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
user_id UUID NOT NULL REFERENCES users(_id),
employee_code VARCHAR(50),
internal_email VARCHAR(255),
job_title VARCHAR(100),
manager_id UUID REFERENCES tenant_members(_id), -- Self-referencing FK
status VARCHAR(20) DEFAULT 'ACTIVE',
joined_at DATE,
resigned_at DATE,
created_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id)
);
-- 2. Bảng Departments (Cây phòng ban)
CREATE TABLE departments (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
parent_id UUID REFERENCES departments(_id), -- Self-referencing FK
name VARCHAR(100) NOT NULL,
type VARCHAR(20) DEFAULT 'TEAM',
head_member_id UUID REFERENCES tenant_members(_id),
path TEXT, -- VD: '/root-uuid/div-uuid/dept-uuid/'
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index để tìm tất cả phòng ban con cực nhanh (WHERE path LIKE '...')
CREATE INDEX idx_dept_path ON departments (tenant_id, path text_pattern_ops);
tiếp tục hoàn thiện Nhóm Identity & Structure
Để hoàn thiện mảnh ghép cuối cùng cho nhóm Identity & Structure, chúng ta cần giải quyết 3 bài toán chuyên sâu mà các hệ thống HRM/SaaS lớn (như Workday, BambooHR) đều có:
Vị trí địa lý (Physical Locations): Doanh nghiệp không chỉ có "Phòng ban" (Logic) mà còn có "Văn phòng/Chi nhánh" (Vật lý). Điều này ảnh hưởng đến chấm công, múi giờ làm việc và ngày nghỉ lễ vùng miền.
Cơ cấu chức danh (Job Architecture): Thay vì để chức danh là text tự do (job_title VARCHAR), Enterprise cần quản lý danh mục chức danh chuẩn (Job Catalog) để xếp ngạch lương.
Trường tùy chỉnh (Custom Fields): Khách hàng muốn lưu thêm "Size áo đồng phục", "Biển số xe", "Nhóm máu" mà không cần nhờ bạn sửa DB.
Dưới đây là thiết kế bổ sung:
1. Bảng locations (Văn phòng & Chi nhánh)
Quản lý các địa điểm vật lý của Tenant.
Trường Kiểu dữ liệu Null? Mô tả
_id UUID NO PK
tenant_id UUID NO FK
name VARCHAR NO Tên văn phòng (VD: "FPT Tower Hà Nội").
code VARCHAR YES Mã địa điểm (để map chấm công).
address JSONB NO { "street": "...", "city": "...", "country": "VN" }.
coordinates POINT YES Tọa độ (Lat/Long) để chấm công GPS.
radius_meters INT YES Bán kính cho phép chấm công (VD: 100m).
timezone VARCHAR NO 'Asia/Ho_Chi_Minh' (Quan trọng để tính ca kíp).
is_headquarter BOOLEAN NO FALSE.
2. Bảng job_titles (Danh mục Chức danh)
Chuyển từ Text tự do sang Master Data được quản lý.
Trường Kiểu dữ liệu Null? Mô tả
_id UUID NO PK
tenant_id UUID NO FK
name VARCHAR NO Tên chức danh (VD: "Senior Backend Engineer").
code VARCHAR YES Mã chức danh (VD: SE_L3).
job_level INT YES Cấp bậc/Ngạch (VD: 3). Dùng để map thang bảng lương.
description TEXT YES Mô tả công việc (Job Description).
department_id UUID YES (Optional) Nếu chức danh này chỉ thuộc 1 phòng ban.
3. Bảng custom_field_definitions (Định nghĩa trường động)
Cho phép Admin tự định nghĩa thêm trường dữ liệu cho hồ sơ nhân viên.
Trường Kiểu dữ liệu Null? Mô tả
_id UUID NO PK
tenant_id UUID NO FK
entity_type VARCHAR NO 'MEMBER' (Sau này có thể là 'PROJECT', 'CONTRACT').
key VARCHAR NO Key trong JSON (VD: t_shirt_size).
label VARCHAR NO Tên hiển thị (VD: "Kích cỡ áo").
data_type VARCHAR NO 'TEXT', 'NUMBER', 'DATE', 'SELECT', 'BOOLEAN'.
options JSONB YES Danh sách lựa chọn nếu là SELECT (VD: ['S', 'M', 'L']).
is_required BOOLEAN NO FALSE.
CẬP NHẬT LẠI: Bảng tenant_members (Phiên bản hoàn hảo)
Chúng ta sẽ update bảng tenant_members để liên kết với các bảng mới này.
SQL
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
user_id UUID NOT NULL REFERENCES users(_id),
-- 1. Định danh công việc (Job Identity)
employee_code VARCHAR(50),
-- [NÂNG CẤP] Thay vì job_title text, dùng FK.
-- Vẫn giữ cột text job_title_cached để hiển thị nhanh nếu cần, hoặc bỏ hẳn.
job_title_id UUID REFERENCES job_titles(_id),
department_id UUID, -- Phòng ban chính (Cache từ bảng department_members để query nhanh)
-- [NÂNG CẤP] Liên kết địa điểm vật lý
location_id UUID REFERENCES locations(_id),
manager_id UUID REFERENCES tenant_members(_id),
-- 2. Trạng thái & Thời gian
status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE, ONBOARDING, PROBATION (Thử việc), RESIGNED
type VARCHAR(20) DEFAULT 'FULL_TIME', -- FULL_TIME, CONTRACTOR, INTERN
joined_at DATE,
probation_end_at DATE, -- Ngày hết hạn thử việc
contract_end_at DATE, -- Ngày hết hạn hợp đồng
resigned_at DATE,
-- 3. Thông tin mở rộng (Extensibility)
-- Chứa dữ liệu của custom_field_definitions
-- VD: { "t_shirt_size": "L", "license_plate": "29A-12345" }
custom_data JSONB DEFAULT '{}',
created_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id)
);
-- Index GIN để tìm kiếm theo custom fields (VD: Tìm ai mặc áo size L)
CREATE INDEX idx_members_custom_data ON tenant_members USING GIN (custom_data);
TỔNG KẾT NHÓM IDENTITY & STRUCTURE
Như vậy, nhóm Identity & Structure của bạn đã bao phủ toàn diện các khía cạnh của một tổ chức lớn:
Con người: users (Global), tenant_members (Local).
Tổ chức Logic: tenants, departments (Hierarchy), user_groups (Matrix).
Tổ chức Vật lý: locations (Geo).
Chuyên môn: job_titles (Leveling).
Mở rộng: custom_field_definitions (Dynamic Schema).
Kết nối: invitations, sso_configs.
Đây là một nền tảng dữ liệu cực kỳ vững chắc (Solid Foundation). Các module khác như Timekeeping (Chấm công), Payroll (Lương), hay Assets (Tài sản) sẽ chỉ cần tham chiếu đến tenant_members và locations là có thể hoạt động mượt mà.
tiếp tục hoàn thiện Nhóm Identity & Structure
Để hoàn thiện tuyệt đối Nhóm Identity & Structure, biến nó thành một "Source of Truth" (Nguồn sự thật) cho toàn bộ doanh nghiệp, chúng ta cần giải quyết 3 mảnh ghép cuối cùng thường bị bỏ qua ở các hệ thống vừa và nhỏ, nhưng lại là yêu cầu bắt buộc của các tập đoàn lớn (Matrix Organization).
Đó là: Báo cáo đa chiều (Matrix Reporting), Hồ sơ pháp lý (Documents) và Thông tin liên hệ khẩn cấp.
1. Nâng cấp Quan hệ báo cáo: Matrix Reporting Lines
Ở mô hình cũ, bảng tenant_members chỉ có cột manager_id. Điều này chỉ đáp ứng mô hình quản lý 1-1 (Line Manager). Thực tế Enterprise phức tạp hơn: Một nhân viên có Line Manager (Sếp hành chính), Project Manager (Sếp dự án - Dotted line), và Mentor (Người hướng dẫn).
Bảng member_reporting_lines (Quan hệ báo cáo):
SQL
CREATE TABLE member_reporting_lines (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
subordinate_id UUID NOT NULL, -- Nhân viên cấp dưới (FK -> tenant_members)
manager_id UUID NOT NULL, -- Sếp (FK -> tenant_members)
-- Loại quan hệ
type VARCHAR(20) NOT NULL,
-- 'DIRECT': Quản lý trực tiếp (Line Manager) - Quyết định lương thưởng
-- 'DOTTED': Quản lý chức năng/Dự án (Project Lead) - Chỉ giao việc
-- 'MENTOR': Người hướng dẫn
is_primary BOOLEAN DEFAULT FALSE, -- Nếu True -> Đây là sếp chính (Fallback cho approval)
valid_from DATE DEFAULT CURRENT_DATE,
valid_to DATE, -- Null = Đang hiệu lực
CONSTRAINT fk_report_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
CONSTRAINT fk_report_sub FOREIGN KEY (subordinate_id) REFERENCES tenant_members(_id),
CONSTRAINT fk_report_mgr FOREIGN KEY (manager_id) REFERENCES tenant_members(_id)
);
-- Index để tìm "Sếp của ông A là ai?" và "Ông B đang quản lý những ai?"
CREATE INDEX idx_reporting_sub ON member_reporting_lines (subordinate_id) WHERE valid_to IS NULL;
CREATE INDEX idx_reporting_mgr ON member_reporting_lines (manager_id) WHERE valid_to IS NULL;
-> Giá trị: Hệ thống Approval (Phê duyệt) sẽ cực kỳ linh hoạt. Ví dụ: Xin nghỉ phép -> Gửi Direct Manager. Xin mua thiết bị dự án -> Gửi Dotted Manager.
2. Nâng cấp Hồ sơ: Documents & Compliance (Giấy tờ pháp lý)
Lưu trữ CMND/CCCD, Hộ chiếu, Bằng cấp, Hợp đồng lao động. Quan trọng nhất là theo dõi ngày hết hạn để nhắc nhở.
Bảng member_documents:
SQL
CREATE TABLE member_documents (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
member_id UUID NOT NULL,
-- Loại giấy tờ
document_type VARCHAR(50) NOT NULL, -- 'ID_CARD', 'PASSPORT', 'LABOR_CONTRACT', 'DEGREE'
document_number VARCHAR(100), -- Số CMT, Số HĐ
-- File đính kèm (Lưu đường dẫn S3)
file_url TEXT,
file_id UUID, -- Link sang bảng file master (nếu có)
-- Thời hạn
issue_date DATE,
expiry_date DATE, -- Quan trọng: Dùng để bắn noti "Sắp hết hạn hộ chiếu/hợp đồng"
issue_place TEXT,
-- Trạng thái xác minh (HR đã check bản gốc chưa?)
verification_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, VERIFIED, REJECTED
created_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT fk_doc_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id)
);
-- Index tìm các giấy tờ sắp hết hạn trong 30 ngày tới
CREATE INDEX idx_doc_expiry ON member_documents (tenant_id, expiry_date) WHERE expiry_date IS NOT NULL;
3. Nâng cấp An toàn: Emergency Contacts (Liên hệ khẩn cấp)
Khi nhân viên gặp tai nạn hoặc sự cố, HR cần biết gọi cho ai ngay lập tức.
Bảng member_emergency_contacts:
SQL
CREATE TABLE member_emergency_contacts (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
member_id UUID NOT NULL,
full_name VARCHAR(100) NOT NULL,
relationship VARCHAR(50) NOT NULL, -- 'FATHER', 'MOTHER', 'SPOUSE' (Vợ/Chồng)
phone_number VARCHAR(20) NOT NULL,
address TEXT,
is_primary BOOLEAN DEFAULT FALSE, -- Người ưu tiên gọi đầu tiên
CONSTRAINT fk_contact_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id)
);
4. Nâng cấp Tài chính: Cost Centers (Trung tâm chi phí)
Trong các tập đoàn, "Phòng ban" (Department) là cấu trúc quản lý con người, còn "Cost Center" là cấu trúc quản lý tiền. Một Team IT có thể tiêu tiền của ngân sách Marketing (nếu làm dự án cho Marketing).
Bảng cost_centers:
SQL
CREATE TABLE cost_centers (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
code VARCHAR(50) NOT NULL, -- VD: "CC_MKT_001"
name VARCHAR(100) NOT NULL,
budget_limit NUMERIC(19,4), -- Ngân sách năm
currency_code VARCHAR(3) DEFAULT 'VND',
manager_id UUID, -- Người chịu trách nhiệm giải trình chi phí (Budget Owner)
is_active BOOLEAN DEFAULT TRUE
);
Lưu ý: Bảng departments nên thêm cột default_cost_center_id để map mặc định.
TỔNG KẾT FINAL: NHÓM IDENTITY & STRUCTURE
Đây là danh sách đầy đủ các bảng sau khi đã hoàn thiện 100%:
Sub-module Các bảng thành phần Mục đích
Core Identity users (Global), sso_configs Quản lý định danh và đăng nhập tập trung.
Organization tenants, departments, locations, cost_centers Cấu trúc công ty: Logic, Vật lý và Tài chính.
Membership tenant_members Hồ sơ nhân viên trung tâm.
Relations member_reporting_lines, department_members, user_groups Ma trận báo cáo và làm việc nhóm.
Profile Detail member_documents, member_emergency_contacts, job_titles Thông tin chi tiết pháp lý và đời sống.
Extensibility custom_field_definitions Mở rộng dữ liệu động.
Onboarding invitations Quy trình đầu vào.
Với cấu trúc này, hệ thống của bạn đã sẵn sàng để làm nền tảng cho:
HRM: Chấm công, Tính lương (dựa trên Job Title, Location, Contract).
Approval: Quy trình phê duyệt động (dựa trên Reporting Lines, Cost Center Owner).
Asset Management: Cấp phát tài sản (dựa trên Location, Department).
Bạn đã hoàn thành xuất sắc thiết kế cho phần lõi quan trọng nhất của hệ thống!
các phần này thuộc phần mềm hrm rồi, chỉ tập trung cải tiến phần lõi của saas thôi
Bạn nói rất đúng. Tôi đã đi hơi sâu vào nghiệp vụ HRM.
Chúng ta cần quay lại đúng bản chất của SaaS Core (Phần lõi nền tảng). Nhiệm vụ của Core là cung cấp hạ tầng để mọi loại ứng dụng (HRM, CRM, ERP, POS...) đều chạy được trên đó, chứ không được chứa logic riêng của bất kỳ nghiệp vụ nào.
Để tinh gọn lại SaaS Core Identity & Structure chuẩn mực nhất, chúng ta sẽ loại bỏ các bảng nghiệp vụ HRM và chỉ giữ lại những gì thực sự cần thiết cho Quản trị hệ thống, Phân quyền và Tổ chức chung.
Dưới đây là thiết kế Core Identity đã được tinh giản (Refined) và cải tiến sâu vào khía cạnh kỹ thuật nền tảng:
1. Giữ lại và Tối ưu: tenant_members (Hồ sơ thành viên nền tảng)
Loại bỏ hết các trường HRM (job_title, probation_date, resigned_date...). Core chỉ quan tâm: User này có thuộc Tenant này không? Đang Active hay bị Block?
Cấu trúc tinh gọn:
SQL
CREATE TABLE tenant_members (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
user_id UUID NOT NULL REFERENCES users(_id),
-- Định danh hiển thị trong Tenant (Display Name)
-- VD: User tên "Nguyen Van A", nhưng trong Tenant FPT muốn hiện là "Anh A (IT)"
display_name VARCHAR(100),
-- Trạng thái truy cập (Quan trọng nhất của Core)
status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE, SUSPENDED (Bị admin khóa), INVITED
-- Metadata (Dùng cho mọi app: HRM, CRM đều cần biết ai là ai)
avatar_override_url TEXT, -- Avatar riêng tại tenant này (nếu khác avatar gốc)
joined_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id)
);
2. Cải tiến Core: Attributes Based Access Control (ABAC - Thay vì chỉ RBAC)
Thay vì tạo bảng departments (cứng nhắc kiểu HRM), Core SaaS nên hỗ trợ cơ chế Tag/Attributes linh hoạt hơn. CRM cần "Team Sale", HRM cần "Phòng nhân sự", Project Mgmt cần "Squad A". Core không nên định nghĩa "Phòng ban", mà nên định nghĩa "Nhóm".
Thay thế departments bằng member_groups (Nhóm thành viên):
SQL
CREATE TABLE member_groups (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(100) NOT NULL, -- VD: "Admin Group", "Sales Team", "Hanoi Branch"
code VARCHAR(50), -- Mã định danh (để code gọi: 'GRP_ADMIN')
-- Loại nhóm (Quan trọng để phân loại)
type VARCHAR(20) DEFAULT 'CUSTOM', -- 'SYSTEM' (Admin mặc định), 'ORG_UNIT' (Phòng ban), 'PROJECT_TEAM'
parent_id UUID, -- Hỗ trợ phân cấp (Hierarchy) nếu cần
path TEXT, -- Materialized Path để query cây
description TEXT
);
Bảng group_memberships (Quan hệ N-N):
SQL
CREATE TABLE group_memberships (
group_id UUID NOT NULL,
member_id UUID NOT NULL,
-- Vai trò trong nhóm (Optional)
-- VD: 'LEADER', 'MEMBER'
role_in_group VARCHAR(20) DEFAULT 'MEMBER',
added_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (group_id, member_id)
);
-> Tại sao tối ưu? CRM có thể dùng bảng này để tạo nhóm Sale. HRM dùng bảng này để tạo Phòng ban. Core cung cấp công cụ, App định nghĩa ý nghĩa.
3. Cải tiến Core: Service Accounts (Tài khoản máy)
SaaS Core không chỉ quản lý con người (users), mà còn phải quản lý các hệ thống khác kết nối vào (Bot, CI/CD, 3rd Party Integration).
Bảng service_accounts:
SQL
CREATE TABLE service_accounts (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
name VARCHAR(100) NOT NULL, -- VD: "Github Action Bot", "ERP Sync Service"
description TEXT,
client_id VARCHAR(64) UNIQUE NOT NULL, -- Định danh (thay vì email)
client_secret_hash VARCHAR(255) NOT NULL, -- Mật khẩu
-- Gán quyền cho Bot như một Member bình thường
member_id UUID, -- Link sang tenant_members (để Bot cũng có ID member, được gán quyền RBAC như người)
is_active BOOLEAN DEFAULT TRUE,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Logic: Khi tạo Service Account, hệ thống tự động tạo 1 dòng bên tenant_members (với user_id = null hoặc flag is_bot = true). Điều này giúp hệ thống phân quyền (RBAC) xử lý Bot và Người thống nhất như nhau.
4. Cải tiến Core: Resource Policies (Phân quyền mức Tài nguyên)
RBAC (Role) thường chỉ định nghĩa quyền chung chung (view_document). Nhưng SaaS Core cần hỗ trợ quyền chi tiết: "User A được xem Document X nhưng không được xem Document Y".
Bảng access_control_lists (ACL - Danh sách kiểm soát truy cập):
SQL
CREATE TABLE access_control_lists (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL,
-- Tài nguyên nào? (Generic Resource)
resource_type VARCHAR(50) NOT NULL, -- 'DASHBOARD', 'REPORT', 'FOLDER'
resource_id UUID NOT NULL,
-- Ai được quyền? (Subject)
subject_type VARCHAR(20) NOT NULL, -- 'MEMBER', 'GROUP', 'ROLE'
subject_id UUID NOT NULL, -- ID của Member/Group/Role
-- Quyền gì?
action VARCHAR(50) NOT NULL, -- 'READ', 'WRITE', 'DELETE', 'SHARE'
is_allowed BOOLEAN DEFAULT TRUE, -- TRUE = Allow, FALSE = Deny (Block cụ thể)
CONSTRAINT uq_acl_entry UNIQUE (resource_type, resource_id, subject_type, subject_id, action)
);
-> Giá trị: Đây là tính năng cốt lõi của Google Drive hay Dropbox. Bất kỳ App nào (HRM, CRM) muốn tính năng "Chia sẻ (Share)", "Phân quyền dữ liệu" đều sẽ gọi vào bảng Core này.
5. Cải tiến Core: Audit Trail (Nhật ký truy cập nền tảng)
Lưu ý: Đây không phải Log nghiệp vụ (Ai sửa lương), mà là Log an ninh truy cập (Ai đăng nhập, ai đổi mật khẩu, ai gán quyền Admin).
Bảng security_audit_logs (Core Level):
SQL
CREATE TABLE security_audit_logs (
_id UUID, -- Dùng TimeUUID
tenant_id UUID NOT NULL,
actor_id UUID, -- User/Member thực hiện
ip_address INET,
user_agent TEXT,
event_category VARCHAR(50), -- 'AUTH', 'IAM', 'BILLING'
event_action VARCHAR(50), -- 'LOGIN_FAILED', 'ROLE_ASSIGNED', 'API_KEY_CREATED'
-- Chi tiết (Snapshot)
target_id UUID, -- Đối tượng bị tác động (VD: User ID bị khóa)
details JSONB, -- { "reason": "Too many attempts" }
created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at); -- Partition theo tháng
TỔNG KẾT: SAAS CORE IDENTITY (TINH GỌN)
Đây là danh sách các bảng Core Identity thuần túy, không lẫn tạp chất HRM:
Tên Bảng Chức năng Lõi
users Quản lý tài khoản đăng nhập (Global).
tenants Quản lý khách hàng/tổ chức.
tenant_members Quản lý danh sách thành viên trong tổ chức (Active/Suspend).
service_accounts Quản lý Bot/Integration (Non-human users).
member_groups Cấu trúc nhóm đa dụng (Dùng làm Phòng ban, Team dự án, Group quyền).
group_memberships Phân bổ thành viên vào nhóm.
roles Định nghĩa vai trò (Admin, Editor, Viewer).
permissions Danh mục quyền hệ thống.
member_roles Gán vai trò cho Member (hoặc gán cho Group).
access_control_lists Phân quyền mức tài nguyên (Sharing/Permissions).
sso_configs Cấu hình đăng nhập doanh nghiệp.
Luồng dữ liệu chuẩn:
Core: Quản lý User A là "Thành viên" của Tenant FPT.
App HRM: Tự tạo bảng hrm_employees liên kết 1-1 với core.tenant_members để lưu lương, hợp đồng.
App CRM: Tự tạo bảng crm_sales_agents liên kết 1-1 với core.tenant_members để lưu doanh số, KPI.
Thiết kế này đảm bảo nguyên tắc Separation of Concerns (Phân tách mối quan tâm). Core nhẹ, ổn định và bảo mật.
member_groups đổi tên thành groups được không?
Câu trả lời là: Về mặt kỹ thuật là ĐƯỢC, nhưng KHÔNG KHUYẾN KHÍCH.
Bạn nên dùng tên user_groups (hoặc giữ nguyên member_groups) sẽ an toàn và chuyên nghiệp hơn.
Dưới đây là 3 lý do tại sao tên bảng groups (đứng một mình) là một "cái bẫy":
1. Xung đột từ khóa SQL (Reserved Keywords)
Trong SQL chuẩn, GROUP là một từ khóa đặc biệt (dùng trong câu lệnh GROUP BY).
Trong PostgreSQL (và YugabyteDB), từ phiên bản 11 trở lên, GROUPS (số nhiều) cũng là một từ khóa (dùng trong Window Functions: ROWS BETWEEN ... GROUPS BETWEEN).
Hậu quả: Mặc dù DB vẫn cho phép bạn tạo bảng tên là groups, nhưng khi viết query, một số tool/ORM có thể bị nhầm lẫn hoặc bắt buộc bạn phải dùng dấu ngoặc kép liên tục (SELECT * FROM "groups"), gây phiền toái cho Dev.
2. Thiếu ngữ cảnh (Ambiguity)
Trong một hệ thống SaaS lớn, từ "Group" quá chung chung:
Là nhóm người dùng (User Groups)?
Hay nhóm quyền (Permission Groups)?
Hay nhóm máy chủ (Server Groups)?
Hay nhóm sản phẩm (Product Groups)?
Đặt tên user_groups (hoặc member_groups) giúp người đọc hiểu ngay lập tức: "À, đây là bảng gom nhóm con người".
3. Khó khăn khi Join bảng
Khi bạn join bảng này với bảng khác, tên cột group_id cũng rất chung chung.
user_groups.id -> user_group_id (Rất rõ ràng).
groups.id -> group_id (Dễ nhầm lẫn nếu hệ thống có nhiều loại group).
ĐỀ XUẤT THIẾT KẾ (CHUẨN HÓA)
Tôi khuyên bạn nên dùng tên user_groups. Đây là quy chuẩn mà AWS IAM, Linux, Atlassian đều sử dụng.
Dưới đây là SQL tinh chỉnh cho phần này:
1. Bảng user_groups (Nhóm người dùng) Thay thế cho departments và member_groups.
SQL
CREATE TABLE user_groups (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
name VARCHAR(100) NOT NULL, -- VD: "Dev Team", "HR Dept"
code VARCHAR(50), -- VD: "GRP_DEV_01"
-- Phân loại nhóm để App biết cách xử lý hiển thị
type VARCHAR(20) DEFAULT 'CUSTOM',
-- 'ORG_UNIT' (Phòng ban - Có trong sơ đồ tổ chức)
-- 'PROJECT' (Dự án - Có ngày bắt đầu/kết thúc)
-- 'PERMISSION' (Nhóm chỉ để gán quyền)
-- 'CUSTOM' (Nhóm user tự tạo để chat/tag)
parent_id UUID REFERENCES user_groups(_id), -- Hỗ trợ cây phân cấp
path TEXT, -- Materialized Path (VD: /root-id/child-id/)
description TEXT,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index tìm kiếm nhanh
CREATE INDEX idx_groups_tenant ON user_groups (tenant_id);
CREATE INDEX idx_groups_path ON user_groups (tenant_id, path text_pattern_ops);
2. Bảng group_memberships (Phân bổ thành viên) Liên kết N-N giữa Member và Group.
SQL
CREATE TABLE group_memberships (
group_id UUID NOT NULL REFERENCES user_groups(_id) ON DELETE CASCADE,
member_id UUID NOT NULL REFERENCES tenant_members(_id) ON DELETE CASCADE,
-- Vai trò trong nhóm này (Không phải System Role)
-- VD: 'LEADER' (Trưởng phòng/PM), 'MEMBER', 'SECRETARY'
role_in_group VARCHAR(20) DEFAULT 'MEMBER',
is_primary BOOLEAN DEFAULT FALSE, -- Nếu user thuộc nhiều phòng, phòng nào là chính?
joined_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (group_id, member_id)
);
Tóm lại:
Hãy đổi thành user_groups. Nó chỉ dài hơn 5 ký tự nhưng giúp bạn tránh được hàng tá rắc rối về cú pháp SQL và ngữ nghĩa sau này.
một số bảng có sợ xung đột với phần mềm CRM hay POS hay Ecommerce về sau không?
Câu hỏi của bạn rất chính xác và mang tầm nhìn xa. Đây là vấn đề kinh điển trong thiết kế SaaS: Sự nhầm lẫn giữa "Dữ liệu của Nền tảng" (Platform Data) và "Dữ liệu của Tenant" (Tenant Data).
Nếu không quy hoạch kỹ, chắc chắn bạn sẽ gặp xung đột về tên gọi (Naming Collision) và logic.
Dưới đây là phân tích các điểm "nóng" dễ xung đột và giải pháp kiến trúc để tách biệt hoàn toàn.
1. Nguyên tắc cốt lõi: "Platform vs Business"
Bạn phải phân biệt rõ 2 thế giới này:
World 1: Platform (SaaS Core)
Đối tượng: Là Nhân viên của công ty Tenant, là Gói cước phần mềm, là Hóa đơn tiền thuê phần mềm.
Mục đích: Quản lý việc vận hành SaaS.
World 2: Business Apps (CRM, POS, Ecommerce)
Đối tượng: Là Khách hàng của Tenant (người mua hàng), là Hàng hóa (áo, quần), là Hóa đơn bán lẻ.
Mục đích: Quản lý việc kinh doanh của Tenant.
2. Các bảng "Nguy hiểm" dễ xung đột và Cách xử lý
Dưới đây là danh sách các bảng trong Core có tên trùng với nghiệp vụ CRM/POS và cách đổi tên để tránh hậu họa:
Tên bảng ở Core (Hiện tại) Xung đột với App nào? Tại sao xung đột? Tên mới đề xuất cho Core
products POS, Ecommerce Core lưu "Gói phần mềm". App lưu "Hàng hóa" (Quần áo, Đồ ăn). -> saas_products hoặc service_packages
invoices Accounting, POS Core lưu "Hóa đơn cước". App lưu "Hóa đơn bán hàng". -> subscription_invoices
orders Ecommerce Core lưu "Lệnh mua gói". App lưu "Đơn hàng Shopee/Web". -> subscription_orders
customers CRM Core đôi khi gọi Tenant là Customer. App lưu Khách hàng của Tenant. -> Giữ là tenants (Tuyệt đối không dùng từ Customer ở Core)
users Ecommerce (B2C) Core lưu nhân viên. Ecom lưu người mua hàng (End-user). -> Giữ là users (nhưng hiểu là Staff). App Ecom nên dùng bảng riêng ecom_customers.
inventory Warehouse Core không dùng, nhưng cẩn thận nếu định lưu kho thẻ cào/license key. -> license_inventory
3. Giải pháp Kiến trúc: PostgreSQL Schemas (Namespaces)
Thay vì cố gắng đặt tên bảng dài dòng (crm_products, core_products), YugabyteDB/PostgreSQL cung cấp một vũ khí cực mạnh là SCHEMA (tương tự như Folder chứa bảng).
Bạn nên chia Database thành các "Khoang" (Schemas) riêng biệt:
Schema 1: platform_core (Chứa Identity & Structure)
Bảng: users, tenants, tenant_members, user_groups...
Đây là hạ tầng chung, các App khác chỉ được phép READ (tham chiếu), không được sửa.
Schema 2: platform_billing (Chứa tiền nong của SaaS)
Bảng: saas_packages, subscriptions, saas_invoices, wallets.
Tách biệt hẳn để không lẫn với hóa đơn bán hàng của Tenant.
Schema 3: app_crm (Nghiệp vụ CRM)
Bảng: contacts (Khách hàng), deals, leads, activities.
Lưu ý: Bảng crm.activities sẽ có cột created_by trỏ về platform_core.users.
Schema 4: app_ecommerce (Nghiệp vụ Bán hàng)
Bảng: products (Hàng hóa), orders, categories, customers (Người mua).
4. Ví dụ minh họa xung đột thực tế
Hãy tưởng tượng kịch bản: "User A tạo Order B cho Product C".
Trong bối cảnh SaaS Core:
Ông chủ Tenant (User A) mua gói Enterprise (Product C) và hệ thống tạo phiếu thu (Order B).
Trong bối cảnh Ecommerce:
Khách mua hàng (User A - end user) mua cái áo thun (Product C) và tạo đơn hàng (Order B).
Cách viết SQL khi dùng Schema (Rất trong sáng):
SQL
-- 1. Lấy thông tin gói cước (SaaS)
SELECT * FROM platform_billing.packages WHERE code = 'ENTERPRISE';
-- 2. Lấy thông tin hàng hóa bán lẻ (Ecommerce)
SELECT * FROM app_ecommerce.products WHERE sku = 'TSHIRT-RED-L';
-- 3. CRM lấy thông tin nhân viên sale (Join xuyên schema)
SELECT
l.lead_name,
u.full_name as sale_person_name
FROM app_crm.leads l
JOIN platform_core.users u ON l.assigned_to_user_id = u._id;
5. Kết luận cho phần Core Identity
Với thiết kế users, tenants, tenant_members, user_groups mà chúng ta vừa chốt:
Không xung đột với CRM:
CRM quản lý contacts (Người ngoài).
Core quản lý users (Người nhà - Nhân viên).
Hai đối tượng này khác hẳn nhau.
Không xung đột với POS/HRM:
HRM sẽ mở rộng bảng tenant_members bằng cách tạo bảng hrm_profiles (1-1).
POS sẽ dùng users để đăng nhập vào máy tính tiền.
Lời khuyên:
Đổi tên các bảng liên quan đến tiền nong/gói cước trong Core thêm tiền tố hoặc đặt vào schema riêng (VD: billing_invoices thay vì invoices).
Giữ nguyên nhóm Identity (users, tenants) vì nó là chuẩn mực, các App khác sẽ xoay quanh nó chứ không xung đột.
tiếp tục cải tiến Core Identity
Để phần Core Identity đạt đến độ hoàn thiện cao nhất, sẵn sàng cho các yêu cầu khắt khe về Bảo mật (Zero Trust), Tuân thủ pháp lý (Legal/GDPR) và Quản trị Shadow IT, chúng ta cần bổ sung 4 mảnh ghép nâng cao sau.
Đây là những tính năng giúp bạn bán được sản phẩm cho các tập đoàn lớn (Enterprise Grade).
1. Quản lý Tên miền & Shadow IT (Domain Verification)
Vấn đề:
Công ty FPT sử dụng SaaS của bạn. Nhưng nhân viên FPT lại tự lấy email công ty (nhanvien@fpt.com) đăng ký các tài khoản rời rạc (Shadow IT).
Admin FPT muốn: "Bất kỳ ai đăng ký bằng đuôi @fpt.com phải tự động thuộc về Tenant của tôi, hoặc bị bắt buộc đăng nhập qua SSO của tôi".
Bảng tenant_domains (Tên miền đã xác thực):
SQL
CREATE TABLE tenant_domains (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
domain VARCHAR(255) NOT NULL, -- VD: "fpt.com"
-- Trạng thái xác thực (Admin phải chứng minh mình sở hữu domain này)
verification_status VARCHAR(20) DEFAULT 'PENDING', -- PENDING, VERIFIED
verification_method VARCHAR(20), -- 'DNS_TXT', 'HTML_FILE'
verification_token VARCHAR(100), -- Token để khách điền vào DNS
-- Chính sách áp dụng cho domain này
-- 'NONE': Không làm gì
-- 'CAPTURE': Tự động mời vào Tenant khi user đăng ký mới
-- 'ENFORCE_SSO': Bắt buộc phải login bằng SSO, không được dùng password
policy VARCHAR(20) DEFAULT 'NONE',
verified_at TIMESTAMPTZ,
CONSTRAINT uq_domain UNIQUE (domain) -- Một domain chỉ thuộc về 1 Tenant duy nhất trên toàn hệ thống
);
2. Đa phương thức đăng nhập (Multi-Identity Linking)
Vấn đề:
Bảng users hiện tại có password_hash. Nhưng xu hướng hiện đại là Passwordless hoặc Social Login.
Một User muốn link cả Google, GitHub và Password vào cùng 1 tài khoản _id.
Giải pháp: Tách mật khẩu ra khỏi bảng users. Bảng users chỉ chứa Profile. Tạo bảng mới quản lý các nguồn định danh.
Bảng user_linked_identities:
SQL
CREATE TABLE user_linked_identities (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id),
-- Nguồn định danh
provider VARCHAR(20) NOT NULL, -- 'LOCAL' (Password), 'GOOGLE', 'GITHUB', 'MICROSOFT'
-- ID định danh tại nguồn (Subject ID)
provider_id VARCHAR(255) NOT NULL, -- Nếu là LOCAL thì là email, nếu là Google thì là Google User ID (số dài)
-- Dữ liệu đi kèm (Tokens, Metadata)
-- VD: { "access_token": "...", "refresh_token": "...", "profile_url": "..." }
data JSONB,
last_login_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_provider_id UNIQUE (provider, provider_id) -- 1 Google ID chỉ gắn với 1 User
);
-- Index để tìm user nhanh khi login: "Tìm user nào có Google ID là 12345?"
CREATE INDEX idx_identity_lookup ON user_linked_identities (provider, provider_id);
-> Lưu ý: Lúc này cột password_hash ở bảng users nên chuyển sang bảng này (với provider = 'LOCAL') hoặc giữ lại nếu muốn đơn giản hóa. Mô hình chuẩn là chuyển sang đây.
3. Tuân thủ Pháp lý (Legal Compliance & Terms)
Vấn đề:
Khi bạn cập nhật "Điều khoản sử dụng" (Terms of Service), bạn phải bắt buộc user đồng ý lại (Re-consent).
Nếu có kiện tụng, bạn phải chứng minh được: "User A đã bấm đồng ý điều khoản phiên bản 2.0 vào ngày X".
Bảng legal_documents (Các văn bản pháp lý):
SQL
CREATE TABLE legal_documents (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
type VARCHAR(50) NOT NULL, -- 'TERMS_OF_SERVICE', 'PRIVACY_POLICY'
version VARCHAR(20) NOT NULL, -- '1.0', '2.0', '2024-JAN'
content_url TEXT NOT NULL, -- Link tới nội dung PDF/HTML
is_active BOOLEAN DEFAULT FALSE, -- Phiên bản hiện hành
published_at TIMESTAMPTZ DEFAULT NOW(),
CONSTRAINT uq_doc_version UNIQUE (type, version)
);
Bảng user_consents (Lịch sử đồng ý):
SQL
CREATE TABLE user_consents (
user_id UUID NOT NULL REFERENCES users(_id),
document_id UUID NOT NULL REFERENCES legal_documents(_id),
agreed_at TIMESTAMPTZ DEFAULT NOW(),
ip_address INET, -- Bằng chứng kỹ thuật
user_agent TEXT,
PRIMARY KEY (user_id, document_id)
);
4. Kiểm soát thiết bị tin cậy (Trusted Devices)
Vấn đề:
Ngân hàng hoặc công ty Fintech yêu cầu: "Chỉ cho phép đăng nhập trên Laptop công ty cấp".
Nếu phát hiện đăng nhập lạ -> Yêu cầu OTP hoặc Block.
Bảng user_devices (Quản lý thiết bị đã biết):
SQL
CREATE TABLE user_devices (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id),
-- Fingerprint (Tạo từ Browser + OS + Hardware)
device_fingerprint VARCHAR(255) NOT NULL,
name VARCHAR(100), -- VD: "Macbook Pro của An"
user_agent_parsed JSONB, -- { "os": "MacOS", "browser": "Chrome" }
-- Trạng thái tin cậy
trust_status VARCHAR(20) DEFAULT 'UNTRUSTED', -- UNTRUSTED, TRUSTED, BLOCKED
last_ip INET,
last_active_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Khi login, hệ thống check:
-- 1. Fingerprint này đã có trong DB chưa?
-- 2. Nếu chưa -> Gửi cảnh báo "New Device Login".
-- 3. Nếu status = BLOCKED -> Chặn ngay.
TỔNG HỢP KIẾN TRÚC IDENTITY 3.0 (FINAL)
Dưới đây là sơ đồ đầy đủ cho phần Core Identity sau khi đã bổ sung các tính năng cao cấp:
Danh sách bảng (Theo nhóm chức năng):
Authentication (Xác thực):
users: Hồ sơ gốc.
user_linked_identities: Mật khẩu, Google, GitHub...
tenant_sso_configs: Cấu hình SAML/OIDC doanh nghiệp.
Organization (Tổ chức):
tenants: Khách hàng.
tenant_domains: Quản lý tên miền (fpt.com) & Shadow IT.
tenant_members: Nhân viên.
Security & Risk (An ninh):
user_sessions: Phiên làm việc (Live).
user_devices: Thiết bị tin cậy (Persistent).
security_audit_logs: Nhật ký an ninh.
Authorization (Quyền hạn - Đã chốt trước đó):
user_groups (Nhóm), roles (Vai trò), permissions (Quyền).
access_control_lists (Chia sẻ tài nguyên).
Compliance (Tuân thủ):
legal_documents: Điều khoản.
user_consents: Chấp thuận của người dùng.
Với bộ khung này, Core Identity của bạn đã vượt xa các phần mềm quản lý nội bộ thông thường và đạt chuẩn của một Identity-as-a-Service (IDaaS) thu nhỏ.
tiếp tục
Hệ thống Core Identity của bạn đã rất hoàn chỉnh về mặt Quản trị (Governance) và Bảo mật (Security).
Để bước sang giai đoạn Sẵn sàng cho Hệ sinh thái (Ecosystem Ready) và Tối ưu trải nghiệm người dùng (UX), chúng ta cần bổ sung 4 mảnh ghép cuối cùng liên quan đến: Tích hợp cho Developer (DevEx), Hồ sơ mở rộng, Cấu hình thông báo và Lịch sử đăng nhập.
Dưới đây là chi tiết:
1. Personal Access Tokens (PATs) - Cho Developer/Scripts
Vấn đề:
Nhân viên IT của khách hàng muốn viết script Python để tự động thêm user từ file Excel, hoặc sync dữ liệu ra Google Sheets.
Họ không thể dùng Username/Password (vì có 2FA), và không nên dùng Session Cookie (vì ngắn hạn).
Họ cần một API Token giống như GitHub Personal Access Token.
Bảng personal_access_tokens:
SQL
CREATE TABLE personal_access_tokens (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id),
tenant_id UUID, -- Optional: Nếu token này chỉ giới hạn trong 1 tenant
name VARCHAR(100) NOT NULL, -- VD: "Script Sync Excel"
-- Token Prefix (để hiển thị user biết token nào)
token_prefix VARCHAR(10), -- VD: "pat_live_..."
-- Token Hash (Chỉ lưu Hash, KHÔNG lưu token gốc)
token_hash VARCHAR(255) NOT NULL,
-- Phạm vi quyền hạn (Scopes) - Cực kỳ quan trọng
-- VD: ['user:read', 'report:export'] -> Chỉ được đọc user, không được xóa
scopes TEXT[] NOT NULL,
last_used_at TIMESTAMPTZ,
expires_at TIMESTAMPTZ, -- Có thể Null (Vĩnh viễn) hoặc có hạn
is_active BOOLEAN DEFAULT TRUE,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Biến SaaS của bạn thành một "Open Platform". Khách hàng tự do tích hợp mà không cần chờ bạn code tính năng Import/Export.
2. User Profiles (Hồ sơ mở rộng)
Vấn đề:
Bảng users chỉ nên chứa thông tin "cứng" để login (Email, Phone).
Các thông tin "mềm" (Bio, Social Links, Sở thích) nên tách ra để bảng users nhẹ (Login nhanh).
Bảng user_profiles (Tách 1-1 với Users):
SQL
CREATE TABLE user_profiles (
user_id UUID PRIMARY KEY REFERENCES users(_id),
-- Thông tin cá nhân
bio TEXT,
date_of_birth DATE,
gender VARCHAR(20),
-- Mạng xã hội & Link
-- VD: {"linkedin": "...", "github": "...", "website": "..."}
social_links JSONB DEFAULT '{}',
-- Cấu hình hiển thị
-- VD: {"theme": "dark", "compact_mode": true}
preferences JSONB DEFAULT '{}',
updated_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Hiệu năng. Khi xác thực (AuthN), hệ thống chỉ cần đọc bảng users (rất nhỏ). Khi hiển thị trang cá nhân, mới load bảng user_profiles.
3. Notification Settings (Cấu hình nhận tin chi tiết)
Vấn đề:
Mặc định hệ thống bắn email cho mọi sự kiện -> User thấy phiền -> Mark Spam -> Email Domain của bạn bị hỏng (Low Reputation).
User cần quyền kiểm soát: "Chỉ gửi email khi có lỗi, còn thông báo thường thì đẩy qua App".
Bảng notification_categories (Danh mục - System Defined):
SQL
CREATE TABLE notification_categories (
code VARCHAR(50) PRIMARY KEY, -- VD: 'SECURITY_ALERT', 'BILLING', 'TASK_ASSIGNMENT'
name VARCHAR(100),
default_channels JSONB -- VD: {"email": true, "push": false}
);
Bảng user_notification_settings (Cấu hình User):
SQL
CREATE TABLE user_notification_settings (
user_id UUID NOT NULL REFERENCES users(_id),
category_code VARCHAR(50) NOT NULL REFERENCES notification_categories(code),
-- User override
-- VD: {"email": false, "push": true, "sms": false}
channels JSONB NOT NULL,
updated_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (user_id, category_code)
);
4. Login History (Lịch sử đăng nhập - Audit)
Vấn đề:
Bảng user_sessions chỉ lưu các phiên đang hoạt động.
Bạn cần lưu lại cả các lần đăng nhập thất bại (để phát hiện Brute-force attack) và lịch sử đăng nhập cũ (để user review).
Bảng auth_logs:
SQL
CREATE TABLE auth_logs (
_id UUID, -- TimeUUID (Tối ưu cho ghi log tuần tự)
user_id UUID, -- Có thể Null nếu login sai email
email_attempted VARCHAR(255), -- Email người dùng nhập vào
ip_address INET,
user_agent TEXT,
-- Kết quả
is_success BOOLEAN NOT NULL,
failure_reason VARCHAR(50), -- 'WRONG_PASSWORD', 'MFA_FAILED', 'USER_LOCKED'
-- Context
login_method VARCHAR(20), -- 'PASSWORD', 'GOOGLE', 'SSO'
tenant_id UUID, -- Nếu login vào tenant cụ thể
created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at); -- Partition theo tháng để dễ xóa log cũ
TỔNG KẾT FINAL: HỆ THỐNG CORE IDENTITY HOÀN CHỈNH
Sau khi thêm 4 bảng trên, cấu trúc Core Identity của bạn đã hoàn thiện 100%. Đây là danh sách tổng hợp để bạn dễ quản lý:
Nhóm 1: Xác thực & Định danh (Authentication)
users: Tài khoản gốc.
user_linked_identities: Liên kết Google/Github/Password.
user_profiles: Thông tin phụ (Bio, Link).
personal_access_tokens: API Key cho Developer.
tenant_sso_configs: Cấu hình SSO Doanh nghiệp.
Nhóm 2: Tổ chức & Thành viên (Organization)
tenants: Công ty/Tổ chức.
tenant_domains: Tên miền & Shadow IT.
tenant_members: Nhân viên (Liên kết User-Tenant).
member_groups: Nhóm/Phòng ban.
group_memberships: Phân bổ nhóm.
tenant_invitations: Lời mời.
Nhóm 3: Phân quyền (Authorization)
roles: Định nghĩa vai trò.
permissions: Định nghĩa quyền (System).
member_roles: Gán quyền.
access_control_lists: Chia sẻ tài nguyên cụ thể.
Nhóm 4: Bảo mật & Kiểm soát (Security & Audit)
user_sessions: Phiên làm việc (Live).
user_devices: Thiết bị tin cậy.
auth_logs: Lịch sử đăng nhập (Success/Fail).
security_audit_logs: Nhật ký hành động nhạy cảm.
legal_documents & user_consents: Pháp lý.
Nhóm 5: Cấu hình (Preferences)
user_notification_settings: Cấu hình nhận tin.
Đây là một bộ khung cơ sở dữ liệu chuẩn mực quốc tế, đủ sức gánh vác các hệ thống SaaS từ startup đến Unicorn. Bạn có thể tự tin bắt tay vào code!
user_profiles có nên lưu ở mongodb không?
Câu trả lời ngắn gọn là: KHÔNG NÊN.
Trong bối cảnh hệ thống Core Identity mà chúng ta đang xây dựng (sử dụng YugabyteDB/PostgreSQL làm chính), việc tách riêng user_profiles sang MongoDB là một quyết định Over-engineering (Làm quá vấn đề) và sẽ mang lại nhiều rắc rối hơn là lợi ích.
Dưới đây là phân tích chi tiết tại sao bạn nên giữ nó trong YugabyteDB (PostgreSQL) sử dụng cột JSONB.
1. Tại sao không nên dùng MongoDB cho trường hợp này?
A. Gánh nặng hạ tầng (Infrastructure Overhead)
Vấn đề: Nếu bạn chỉ dùng MongoDB để lưu user_profiles, bạn phải cài đặt, quản lý, backup, monitor và vá lỗi bảo mật cho cả một cụm Database mới.
Chi phí: Tốn RAM, CPU và quan trọng nhất là thời gian của DevOps. Trừ khi bạn đã có sẵn cụm Mongo cho việc khác, còn không thì không đáng "nuôi" cả một con khủng long chỉ để giữ vài cái Profile.
B. Mất tính toàn vẹn dữ liệu (Referential Integrity)
Vấn đề: Trong SQL, khi bạn xóa User (DELETE FROM users WHERE id = 1), ràng buộc khóa ngoại (ON DELETE CASCADE) sẽ tự động xóa Profile tương ứng.
Rủi ro: Nếu dùng MongoDB, bạn phải code logic xóa ở tầng Application (Code):
Xóa trong SQL.
Gọi sang Mongo xóa tiếp.
Nếu bước 2 lỗi (mạng lag, Mongo chết)? -> Dữ liệu rác (Orphaned Data). Đây là ác mộng khi Audit hoặc tuân thủ GDPR (Quyền được quên).
C. Độ trễ mạng (Network Latency)
Mỗi lần load trang User, bạn phải mở 2 kết nối đến 2 DB khác nhau. Dù nhanh đến mấy thì việc query 1 DB vẫn luôn tối ưu hơn.
2. Giải pháp thay thế: PostgreSQL JSONB
YugabyteDB (dựa trên Postgres) hỗ trợ kiểu dữ liệu JSONB. Nó mạnh mẽ không kém gì MongoDB: Lưu cấu trúc động, Index được từng key trong JSON, Query cực nhanh.
Đây là cách bạn thiết kế bảng user_profiles trong YugabyteDB để có sự linh hoạt của NoSQL:
SQL
CREATE TABLE user_profiles (
user_id UUID PRIMARY KEY REFERENCES users(_id) ON DELETE CASCADE,
-- Các trường cố định (Nên có để query nhanh và chuẩn hóa)
first_name TEXT,
last_name TEXT,
date_of_birth DATE,
-- Các trường linh hoạt (NoSQL-like)
-- Chứa: social_links, preferences, custom_attributes...
-- VD: {
-- "social": {"facebook": "...", "linkedin": "..."},
-- "theme": "dark",
-- "hobbies": ["coding", "reading"]
-- }
attributes JSONB DEFAULT '{}',
updated_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index thẳng vào trong JSON (Tính năng MongoDB có, Postgres cũng có)
-- Tìm user nào thích "coding"?
CREATE INDEX idx_profile_hobbies ON user_profiles USING GIN ((attributes->'hobbies'));
Query JSONB trong SQL:
SQL
-- Tìm tất cả user có theme là 'dark'
SELECT * FROM user_profiles
WHERE attributes->>'theme' = 'dark';
3. Khi nào thì MỚI NÊN dùng MongoDB?
Bạn chỉ nên tách sang MongoDB (hoặc Cassandra/DynamoDB) trong các trường hợp sau:
Dữ liệu Activity Logs khổng lồ: Lưu nhật ký hoạt động (User A bấm nút B) với tần suất ghi hàng nghìn dòng/giây. (Nhưng ClickHouse làm việc này tốt hơn Mongo).
Dữ liệu phi cấu trúc hoàn toàn: Ví dụ lưu nội dung Crawl được từ hàng triệu trang web khác nhau, mỗi trang một cấu trúc HTML khác nhau.
High-velocity IoT Data: Dữ liệu cảm biến gửi về liên tục.
Kết luận: Với user_profiles (tần suất đọc nhiều, ghi ít, cấu trúc tương đối gọn), hãy dùng JSONB trên YugabyteDB/Postgres. Nó giúp hệ thống của bạn:
Đồng bộ (Atomic).
Dễ backup (1 lệnh pg_dump là xong).
Đỡ tốn tiền server.
tiếp tục nâng cấp phần xác thực và định danh
Bạn đang muốn nâng cấp hệ thống lên mức độ bảo mật Defense-in-Depth (Phòng thủ chiều sâu) và đón đầu xu hướng Passwordless (Không mật khẩu).
Hiện tại, chúng ta đã có nền tảng cơ bản (users, identities). Để đạt chuẩn NIST Digital Identity Guidelines (Chuẩn bảo mật định danh của Mỹ) và hỗ trợ Passkeys (FIDO2), chúng ta cần bổ sung 3 phân hệ quan trọng: MFA nâng cao, WebAuthn (Passkeys) và Cơ chế xác thực ngắn hạn (OTP/Magic Link).
Dưới đây là thiết kế chi tiết:
1. Nâng cấp MFA: Đa phương thức & Mã dự phòng (Backup Codes)
Thay vì chỉ lưu một chuỗi mfa_secret duy nhất trong bảng users, chúng ta cần hỗ trợ người dùng thêm nhiều thiết bị 2FA (Ví dụ: 1 cái trên điện thoại chính, 1 cái trên iPad). Đồng thời phải có Mã dự phòng (Recovery Codes) khi mất điện thoại.
Bảng user_mfa_methods (Phương thức xác thực bước 2):
SQL
CREATE TABLE user_mfa_methods (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id) ON DELETE CASCADE,
-- Loại xác thực
type VARCHAR(20) NOT NULL, -- 'TOTP' (Google Auth), 'SMS', 'EMAIL'
name VARCHAR(50), -- VD: "iPhone 14 của An"
-- Secret Key (BẮT BUỘC PHẢI MÃ HÓA KHI LƯU)
-- Dùng khóa DEK trong bảng encryption_keys để mã hóa cột này
encrypted_secret TEXT NOT NULL,
is_default BOOLEAN DEFAULT FALSE,
last_used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng user_backup_codes (Mã khôi phục):
SQL
CREATE TABLE user_backup_codes (
user_id UUID NOT NULL REFERENCES users(_id) ON DELETE CASCADE,
code_hash VARCHAR(255) NOT NULL, -- Chỉ lưu Hash (như password), không lưu mã gốc
is_used BOOLEAN DEFAULT FALSE,
used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (user_id, code_hash) -- Composite Key
);
-> Logic: Khi user bật 2FA, hệ thống sinh 10 mã (VD: 1234-5678), user lưu lại. Server hash 10 mã này lưu vào DB. Khi user nhập, server hash và so sánh.
2. Nâng cấp Hiện đại: WebAuthn / Passkeys (FIDO2)
Đây là tiêu chuẩn đăng nhập bằng Vân tay, FaceID hoặc YubiKey trực tiếp trên trình duyệt mà không cần cài App. Đây là xu hướng bắt buộc của các SaaS hiện đại (Github, Google đã áp dụng).
Bảng user_webauthn_credentials:
SQL
CREATE TABLE user_webauthn_credentials (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id) ON DELETE CASCADE,
-- Tên thiết bị (VD: "MacBook Pro TouchID")
name VARCHAR(100),
-- Dữ liệu kỹ thuật FIDO2 (Lưu Base64)
credential_id TEXT NOT NULL UNIQUE, -- ID của credential trên thiết bị vật lý
public_key TEXT NOT NULL, -- Khóa công khai để verify chữ ký
-- Chống tấn công Replay (Thiết bị sẽ gửi counter tăng dần)
sign_count INT DEFAULT 0,
-- Transports (USB, NFC, BLE, INTERNAL)
transports TEXT[],
last_used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Lợi ích: Trải nghiệm người dùng cực đỉnh (chạm tay là đăng nhập). An toàn hơn Password gấp nhiều lần vì chống được Phishing (Web giả mạo không thể fake domain để lừa trình duyệt).
3. Nâng cấp Xác thực ngắn hạn: OTP & Magic Links
Dùng cho luồng: Quên mật khẩu, Xác thực Email, Đăng nhập không cần pass (gửi link về mail).
Bảng auth_verification_codes:
SQL
CREATE TABLE auth_verification_codes (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-- Định danh người nhận (Có thể là User ID hoặc Email/Phone chưa đăng ký)
identifier VARCHAR(255) NOT NULL, -- "an@gmail.com" hoặc "+8490..."
-- Loại mã
type VARCHAR(20) NOT NULL,
-- 'EMAIL_VERIFICATION' (Đăng ký mới)
-- 'PASSWORD_RESET' (Quên mật khẩu)
-- 'LOGIN_OTP' (Đăng nhập SMS)
-- 'MAGIC_LINK' (Link đăng nhập 1 lần)
-- Mã bí mật (Hash)
code_hash VARCHAR(255) NOT NULL,
expires_at TIMESTAMPTZ NOT NULL, -- Thường ngắn (5-15 phút)
-- Bảo mật chống Spam/Brute-force
attempt_count INT DEFAULT 0, -- Sai quá 3 lần -> Hủy
metadata JSONB, -- VD: {"redirect_url": "/dashboard"}
created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Index tự động xóa dòng cũ (TTL) - Tính năng của YugabyteDB/Postgres
-- Hoặc dùng Job xóa định kỳ.
CREATE INDEX idx_auth_codes_expiry ON auth_verification_codes (expires_at);
4. Nâng cấp Bảo mật Session: Refresh Token Rotation (Chống trộm Token)
Mô hình JWT thông thường có rủi ro: Nếu hacker trộm được Refresh Token, hắn có thể duy trì đăng nhập mãi mãi. Giải pháp: Rotation (Xoay vòng). Mỗi lần dùng Refresh Token cũ để lấy Access Token mới, server sẽ hủy Refresh Token cũ và cấp Refresh Token mới.
Cần nâng cấp bảng user_sessions thêm khái niệm Family.
Cập nhật bảng user_sessions:
SQL
ALTER TABLE user_sessions
ADD COLUMN refresh_token_hash VARCHAR(255), -- Hash của token hiện tại
ADD COLUMN family_id UUID, -- Định danh chuỗi token (Family)
ADD COLUMN rotation_counter INT DEFAULT 0; -- Đếm số lần xoay vòng
-- Logic bảo mật (Reuse Detection):
-- 1. Nếu Hacker dùng lại Refresh Token cũ (đã bị xoay vòng).
-- 2. Hệ thống phát hiện Token này thuộc family_id X nhưng counter thấp hơn hiện tại.
-- 3. => Kết luận: Token bị trộm. HỦY TOÀN BỘ Session thuộc Family X (Đá cả Hacker và User ra).
TỔNG HỢP: IDENTITY STACK 4.0
Hệ thống xác thực của bạn bây giờ bao gồm các lớp phòng thủ (Layers of Defense):
Lớp 1 - Knowledge (Những gì bạn biết):
users (Password), user_linked_identities (Social).
Lớp 2 - Possession (Những gì bạn có):
user_mfa_methods (Điện thoại/App TOTP).
user_webauthn_credentials (Yubikey/Thiết bị).
auth_verification_codes (Quyền truy cập Email/SMS).
Lớp 3 - Recovery (Cứu cánh):
user_backup_codes.
Lớp 4 - Session Integrity (Toàn vẹn phiên):
user_sessions với cơ chế Rotation & Family ID.
Với cấu trúc này, bạn hoàn toàn tự tin tích hợp các thư viện xác thực hiện đại như Passage, SimpleWebAuthn hay xây dựng cơ chế giống Auth0 ngay trong Core của mình.
tiếp tục
Hệ thống Core Identity của bạn đã bao gồm: Xác thực (AuthN), Phân quyền (AuthZ), Tổ chức (Tenants), Bảo mật (Security) và Tích hợp (Integration).
Để hoàn tất bức tranh "Global SaaS Platform" (SaaS toàn cầu), chúng ta cần giải quyết 3 bài toán vĩ mô cuối cùng: Định vị dữ liệu (Data Residency), Quản lý License (Seat Management) và Giao tiếp hệ thống (System Broadcasts).
1. Data Residency (Định vị dữ liệu & Sharding)
Vấn đề:
Khách hàng Châu Âu (GDPR) yêu cầu dữ liệu của họ phải nằm ở server Frankfurt (Đức).
Khách hàng Việt Nam (Luật An Ninh Mạng) yêu cầu dữ liệu ở Hà Nội.
Bạn không thể dồn tất cả vào 1 database duy nhất ở Mỹ được.
Giải pháp: Mô hình Global Directory + Regional Shards.
Global Directory: Chỉ chứa bảng users, tenants (metadata nhẹ).
Regional Shard: Chứa dữ liệu nghiệp vụ (tenant_members, groups, logs...).
Cập nhật bảng tenants (Global):
SQL
ALTER TABLE tenants
ADD COLUMN data_region VARCHAR(20) NOT NULL DEFAULT 'US_EAST';
-- VD: 'EU_CENTRAL', 'VN_NORTH', 'SG_SOUTH'
-- Cột này định tuyến kết nối DB.
-- App sẽ đọc cột này -> Chọn Connection String tương ứng để connect vào DB vùng đó.
Bảng region_configs (Cấu hình vùng - Global):
SQL
CREATE TABLE region_configs (
code VARCHAR(20) PRIMARY KEY, -- 'VN_NORTH'
name VARCHAR(100), -- 'Vietnam (Hanoi)'
-- Connection String của Shard này (Mã hóa)
db_connection_secret TEXT NOT NULL,
-- API Endpoint của vùng này
api_endpoint_url TEXT NOT NULL, -- 'https://vn-api.saas.com'
is_active BOOLEAN DEFAULT TRUE
);
-> Lợi ích: Bạn bán được hàng cho Chính phủ và Ngân hàng nhờ tuân thủ luật định vị dữ liệu.
2. License Enforcement (Quản lý "Ghế" sử dụng)
Vấn đề:
Khách hàng mua gói "10 Users". Nhưng họ mời vào 15 người.
Hệ thống cần phân biệt: Ai là người "ngồi ghế" (Billable), ai là khách dự thính (Guest/Free).
Nếu không quản lý kỹ ở Core, bạn sẽ bị thất thoát doanh thu khổng lồ.
Cập nhật bảng tenant_members:
SQL
ALTER TABLE tenant_members
ADD COLUMN license_type VARCHAR(20) DEFAULT 'BILLABLE';
-- 'BILLABLE' (Tính tiền), 'GUEST' (Miễn phí hạn chế), 'READ_ONLY'
-- Logic đếm ghế:
-- SELECT COUNT(*) FROM tenant_members WHERE tenant_id = X AND license_type = 'BILLABLE';
Bảng license_allocations (Phân bổ giấy phép):
SQL
CREATE TABLE license_allocations (
tenant_id UUID NOT NULL REFERENCES tenants(_id),
-- Loại ghế mua
product_code VARCHAR(50) NOT NULL, -- 'SEAT_ENTERPRISE'
purchased_quantity INT NOT NULL DEFAULT 0, -- Mua 100 ghế
assigned_quantity INT NOT NULL DEFAULT 0, -- Đã gán 90 ghế
expires_at TIMESTAMPTZ, -- Hạn dùng
PRIMARY KEY (tenant_id, product_code)
);
-> Lợi ích: Ngăn chặn việc lạm dụng. Khi Admin mời người thứ 101, hệ thống Core sẽ chặn ngay: "Vui lòng nâng cấp gói cước để mời thêm".
3. System Broadcasts (Thông báo hệ thống toàn sàn)
Vấn đề:
Bạn cần bảo trì server vào 2h sáng -> Cần báo cho toàn bộ 1 triệu user.
Hoặc user bị âm tiền -> Cần hiện một cái Banner đỏ chót trên đầu trang.
Không thể insert 1 triệu dòng vào bảng notifications được (quá tải DB).
Giải pháp: Mô hình Pull-based Announcements.
Bảng system_announcements:
SQL
CREATE TABLE system_announcements (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
title TEXT NOT NULL,
content TEXT, -- Hỗ trợ Markdown/HTML
-- Loại thông báo
type VARCHAR(20) DEFAULT 'INFO', -- INFO, WARNING, CRITICAL (Bảo trì), PROMOTION
-- Phạm vi hiển thị (Targeting)
target_regions TEXT[], -- VD: ['VN_NORTH'] (Chỉ báo cho khách VN)
target_plans TEXT[], -- VD: ['FREE_TIER'] (Chỉ báo cho gói Free nâng cấp đi)
start_at TIMESTAMPTZ DEFAULT NOW(),
end_at TIMESTAMPTZ,
is_active BOOLEAN DEFAULT TRUE,
created_by UUID -- Admin hệ thống
);
Bảng user_announcement_reads (Đánh dấu đã đọc):
SQL
CREATE TABLE user_announcement_reads (
user_id UUID NOT NULL REFERENCES users(_id),
announcement_id UUID NOT NULL REFERENCES system_announcements(_id),
read_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (user_id, announcement_id)
);
-> Logic: Khi user load trang, Frontend gọi API lấy danh sách Announcement đang Active. Trừ đi những cái đã có trong bảng user_announcement_reads.
4. Avatar & File Storage (Hạ tầng lưu trữ tĩnh)
Vấn đề:
User upload Avatar, Tenant upload Logo. Lưu vào đâu?
Nếu lưu trực tiếp URL S3 (https://s3.aws...) vào bảng users, sau này bạn muốn đổi sang Google Cloud Storage hoặc MinIO sẽ phải sửa database rất cực.
Giải pháp: Quản lý File ID trung gian.
Bảng storage_files:
SQL
CREATE TABLE storage_files (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID, -- Null nếu là Avatar cá nhân
uploader_id UUID,
-- Metadata
original_name TEXT,
mime_type VARCHAR(100), -- 'image/png'
size_bytes BIGINT,
-- Vị trí vật lý (Abstract)
bucket_name VARCHAR(50), -- 'avatars-prod'
object_key TEXT NOT NULL, -- 'users/123/avatar.png'
provider VARCHAR(20), -- 'AWS_S3', 'GCS', 'MINIO'
is_public BOOLEAN DEFAULT FALSE,
created_at TIMESTAMPTZ DEFAULT NOW()
);
Lưu ý: Trong bảng users, cột avatar_url nên đổi thành avatar_file_id UUID REFERENCES storage_files(_id). Khi API trả về cho Client, nó sẽ tự generate Signed URL hoặc Public URL.
5. API Usage Quotas (Rate Limiting nâng cao)
Vấn đề:
Chúng ta đã có api_keys cho máy. Nhưng còn User người thật thì sao?
Nếu một User F5 liên tục hoặc dùng tool auto-click, họ sẽ làm sập hệ thống.
Bảng usage_quotas (Hạn ngạch):
SQL
CREATE TABLE usage_quotas (
tenant_id UUID PRIMARY KEY REFERENCES tenants(_id),
-- Cấu hình giới hạn (Lưu JSON để linh hoạt)
-- VD: {
-- "api_requests_per_minute": 1000,
-- "max_storage_gb": 50,
-- "max_emails_per_day": 5000
-- }
limits JSONB NOT NULL,
updated_at TIMESTAMPTZ DEFAULT NOW()
);
Hệ thống API Gateway (như Kong/Nginx) hoặc Middleware sẽ đọc bảng này để chặn request (Throttling).
TỔNG KẾT HÀNH TRÌNH THIẾT KẾ CORE IDENTITY
Chúng ta đã đi qua một hành trình dài để xây dựng một SaaS Core chuẩn World-Class. Dưới đây là bức tranh toàn cảnh cuối cùng:
Identity Layer (Định danh): users, identities, profiles (Hỗ trợ Social, Passkeys).
Access Layer (Truy cập): sessions (Rotation), devices, mfa, pats.
Tenancy Layer (Đa khách hàng): tenants (Multi-region), domains, members.
Authorization Layer (Phân quyền): groups, roles, permissions, acls.
Governance Layer (Quản trị): audit_logs, legal, announcements, licenses.
Infrastructure Layer (Hạ tầng): files, quotas, jobs.
Lời khuyên cuối cùng: Đừng cố gắng CREATE TABLE tất cả 30-40 bảng này trong ngày đầu tiên. Hãy bắt đầu theo thứ tự ưu tiên:
MVP: users, tenants, members, roles.
V2: sso, groups, audit_logs.
V3 (Scale): shards, licenses, webauthn.
Bạn đang nắm trong tay bản thiết kế của một hệ thống có thể trị giá hàng triệu đô la. Chúc bạn triển khai thành công!
tiếp tục nâng cấp Identity Layer
Bạn đang muốn đẩy Identity Layer lên mức tối thượng, biến nó thành một Identity Provider (IdP) thực thụ (ngang tầm với Auth0, Keycloak hay Okta).
Để làm được điều này, chúng ta cần bổ sung 3 năng lực nâng cao: Xác thực thích ứng (Adaptive Auth), Cung cấp định danh (OAuth2 Provider) và Quản lý vòng đời định danh (Identity Lifecycle).
Dưới đây là chi tiết các nâng cấp:
1. Adaptive Authentication (Xác thực thích ứng dựa trên rủi ro)
Vấn đề:
Nếu bắt User nhập OTP mọi lần đăng nhập -> Trải nghiệm kém.
Nếu không hỏi OTP -> Kém bảo mật.
Giải pháp: Hệ thống chấm điểm rủi ro (Risk Score).
Đăng nhập ở Hà Nội (quen thuộc) -> Low Risk -> Cho qua.
10 phút sau đăng nhập ở New York (bất thường) -> High Risk -> Bắt buộc nhập OTP hoặc chặn.
Bảng user_behavior_profiles (Hồ sơ thói quen):
SQL
CREATE TABLE user_behavior_profiles (
user_id UUID PRIMARY KEY REFERENCES users(_id),
-- Danh sách IP thường dùng (Lưu dạng CIDR hoặc Hash)
known_ips INET[],
-- Danh sách thiết bị thường dùng (Fingerprints)
known_devices TEXT[],
-- Khung giờ hoạt động thường xuyên
-- VD: { "start_hour": 8, "end_hour": 20, "timezone": "Asia/Ho_Chi_Minh" }
activity_window JSONB,
-- Vị trí địa lý (GeoHash)
known_locations TEXT[],
updated_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng login_risk_logs (Lịch sử đánh giá rủi ro):
SQL
CREATE TABLE login_risk_logs (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID REFERENCES users(_id),
session_id UUID,
-- Điểm số rủi ro (0-100). VD: >80 là chặn, >50 là challenge MFA
risk_score INT,
-- Các yếu tố vi phạm
-- VD: ["NEW_IP", "IMPOSSIBLE_TRAVEL", "TOR_BROWSER"]
risk_factors TEXT[],
-- Quyết định của hệ thống
action_taken VARCHAR(20), -- 'ALLOW', 'CHALLENGE_MFA', 'BLOCK'
created_at TIMESTAMPTZ DEFAULT NOW()
);
2. OAuth2/OIDC Provider (Biến SaaS thành Nền tảng)
Vấn đề:
Khách hàng muốn tự xây dựng App nội bộ (Mobile App, Portal) nhưng muốn "Đăng nhập bằng tài khoản SaaS của bạn" (Log in with MySaaS).
Bạn cần đóng vai trò là IdP (như Google/Facebook).
Bảng oauth_clients (Ứng dụng kết nối):
SQL
CREATE TABLE oauth_clients (
client_id VARCHAR(64) PRIMARY KEY, -- Public ID
client_secret_hash VARCHAR(255) NOT NULL, -- Private Key
tenant_id UUID, -- App này thuộc về tenant nào (nếu là internal app)
name VARCHAR(100) NOT NULL, -- VD: "HR Portal Mobile"
logo_url TEXT,
-- Các đường dẫn được phép redirect về sau khi login xong
redirect_uris TEXT[] NOT NULL,
-- App này được phép xin quyền gì? (Scope Whitelist)
allowed_scopes TEXT[], -- VD: ['openid', 'profile', 'email']
is_trusted BOOLEAN DEFAULT FALSE, -- Nếu True: Bỏ qua màn hình hỏi "Consent"
created_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng oauth_grants (Sự đồng ý của người dùng):
Lưu lại việc: "User A đã cho phép App B đọc Email lúc 10h sáng".
SQL
CREATE TABLE oauth_grants (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id UUID NOT NULL REFERENCES users(_id),
client_id VARCHAR(64) NOT NULL REFERENCES oauth_clients(client_id),
-- Các quyền đã cấp
scopes TEXT[],
created_at TIMESTAMPTZ DEFAULT NOW(),
expires_at TIMESTAMPTZ, -- Hết hạn quyền truy cập
UNIQUE (user_id, client_id)
);
-> Lợi ích: Mở rộng hệ sinh thái. Các đối tác thứ 3 có thể viết phần mềm bổ trợ cho SaaS của bạn.
3. Identity Lifecycle: Soft Delete & Restoration (Xóa mềm)
Vấn đề:
User lỡ tay xóa tài khoản. Hoặc Nhân viên nghỉ việc quay lại làm.
Nếu dùng DELETE FROM users, dữ liệu mất vĩnh viễn.
Nếu dùng cờ is_deleted, bạn gặp rắc rối với ràng buộc UNIQUE(email). (User xóa acc xong tạo lại acc mới cùng email sẽ bị lỗi Duplicate).
Giải pháp: Xử lý ràng buộc Unique thông minh.
Cập nhật bảng users:
SQL
ALTER TABLE users
ADD COLUMN deleted_at TIMESTAMPTZ; -- Null = Active, Có ngày = Đã xóa
-- Xóa ràng buộc Unique cũ
ALTER TABLE users DROP CONSTRAINT users_email_key;
-- Tạo Index Unique một phần (Partial Index)
-- Chỉ check trùng email với những user CHƯA XÓA
CREATE UNIQUE INDEX idx_unique_email_active
ON users (email)
WHERE deleted_at IS NULL;
Bảng identity_restoration_tokens (Token khôi phục):
SQL
CREATE TABLE identity_restoration_tokens (
user_id UUID NOT NULL REFERENCES users(_id),
token VARCHAR(100) NOT NULL,
expires_at TIMESTAMPTZ NOT NULL,
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Logic: Khi user xóa tài khoản, ta update deleted_at = NOW(). Email đó được "giải phóng" để người khác đăng ký. Nếu user cũ muốn khôi phục trong 30 ngày, họ cần xác thực email để active lại (và set deleted_at = NULL).
4. Advanced Search: Trigram Indexing (Tìm kiếm người dùng mờ)
Vấn đề:
User gõ tìm kiếm: "nguyen van" (không dấu) hoặc "nguyn vn" (gõ sai).
Câu lệnh LIKE '%...%' rất chậm trên bảng triệu dòng.
Giải pháp: Sử dụng pg_trgm (Extension có sẵn trong Yugabyte/Postgres).
SQL
-- Bật extension
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- Tạo cột search vector (kết hợp tên + email + sđt)
ALTER TABLE users ADD COLUMN search_vector TEXT
GENERATED ALWAYS AS (lower(full_name || ' ' || email || ' ' || COALESCE(phone_number, ''))) STORED;
-- Tạo Index GIN Trigram
CREATE INDEX idx_users_search_trgm ON users USING GIN (search_vector gin_trgm_ops);
-- Query siêu nhanh (kể cả gõ sai chính tả nhẹ):
SELECT * FROM users
WHERE search_vector LIKE '%nguyen%';
-- Hoặc dùng similarity
SELECT * FROM users
WHERE similarity(search_vector, 'nguyen van a') > 0.3;
TỔNG HỢP KIẾN TRÚC IDENTITY LAYER (PHIÊN BẢN IDP)
Bây giờ Identity Layer của bạn đã bao gồm 3 tầng bảo vệ và mở rộng:
Core Foundation (Nền móng): users (Soft Delete), tenants, members.
Smart Security (Bảo mật thông minh):
user_behavior_profiles (Học thói quen).
login_risk_logs (Chặn rủi ro).
webauthn (Passkeys).
Platform Expansion (Mở rộng nền tảng):
oauth_clients (Cho phép App thứ 3 kết nối).
oauth_grants (Quản lý quyền truy cập).
Với bộ khung này, bạn không chỉ bán phần mềm SaaS, bạn đang bán một Hệ điều hành doanh nghiệp nơi Identity là trung tâm của mọi kết nối.
tiếp tục nâng cấp Identity layer
Để Identity Layer đạt đến cảnh giới "State-of-the-Art" (Hiện đại nhất), chúng ta cần giải quyết những bài toán cực khó mà chỉ các hệ thống siêu quy mô (Hyper-scale) như Google, Facebook hay các hệ thống Ngân hàng lõi mới đụng tới.
Chúng ta sẽ nâng cấp 3 mảng: Tự động hóa đồng bộ (SCIM Provisioning), Ủy quyền người dùng (User Delegation) và Phân quyền dựa trên quan hệ (ReBAC - Google Zanzibar model).
1. SCIM 2.0 Provisioning (Tự động hóa Quản lý User từ Azure AD/Okta)
Vấn đề:
Khách hàng Enterprise có 10.000 nhân viên trên Azure Active Directory (AD).
Khi họ tuyển nhân viên mới, họ không muốn phải vào SaaS của bạn để tạo user thủ công. Họ muốn: "Tạo bên Azure AD -> Tự động bắn sang SaaS".
Khi nhân viên nghỉ việc -> Xóa bên Azure AD -> Tự động xóa bên SaaS ngay lập tức.
Giải pháp: Hỗ trợ chuẩn SCIM 2.0 (System for Cross-domain Identity Management).
Bảng scim_directories (Kết nối thư mục):
SQL
CREATE TABLE scim_directories (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
provider_type VARCHAR(20), -- 'AZURE_AD', 'OKTA', 'ONELOGIN'
-- Token để Azure AD xác thực khi gọi API SCIM của bạn
scim_token_hash VARCHAR(255) NOT NULL,
is_active BOOLEAN DEFAULT TRUE,
last_synced_at TIMESTAMPTZ,
created_at TIMESTAMPTZ DEFAULT NOW()
);
Bảng scim_mappings (Ánh xạ ID):
Giúp hệ thống biết: User ID 123 bên Azure AD tương ứng với User ID abc bên SaaS của mình.
SQL
CREATE TABLE scim_mappings (
directory_id UUID NOT NULL REFERENCES scim_directories(_id),
external_id VARCHAR(255) NOT NULL, -- ID bên Azure AD
internal_entity_type VARCHAR(20) NOT NULL, -- 'USER', 'GROUP'
internal_entity_id UUID NOT NULL, -- ID bên SaaS (users._id hoặc groups._id)
-- Checksum để biết dữ liệu có thay đổi không
data_hash VARCHAR(64),
updated_at TIMESTAMPTZ DEFAULT NOW(),
PRIMARY KEY (directory_id, external_id, internal_entity_type)
);
-> Lợi ích: Đây là tính năng "Must-have" để bán gói Enterprise giá cao ($$$). Nó giúp khách hàng giảm tải vận hành IT.
2. User Delegation (Ủy quyền hành động)
Vấn đề:
Kịch bản 1 (Trợ lý): Giám đốc muốn thư ký được phép vào xem lịch và trả lời email thay mình, nhưng không được lộ mật khẩu Facebook/Login của Giám đốc.
Kịch bản 2 (Support): User gặp lỗi, cho phép nhân viên Support truy cập tài khoản trong vòng 1 tiếng để sửa.
Bảng user_delegations:
SQL
CREATE TABLE user_delegations (
_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
tenant_id UUID NOT NULL REFERENCES tenants(_id),
delegator_id UUID NOT NULL REFERENCES users(_id), -- Người ủy quyền (Giám đốc)
delegatee_id UUID NOT NULL REFERENCES users(_id), -- Người được ủy quyền (Thư ký)
-- Phạm vi ủy quyền (Chỉ được làm gì?)
-- VD: ['calendar:read', 'email:send']
scopes TEXT[] NOT NULL,
starts_at TIMESTAMPTZ DEFAULT NOW(),
expires_at TIMESTAMPTZ, -- Bắt buộc phải có hạn
is_active BOOLEAN DEFAULT TRUE,
-- Lý do (Audit)
reason TEXT, -- "Cho phép support debug ticket #123"
created_at TIMESTAMPTZ DEFAULT NOW()
);
-> Logic: Khi Thư ký đăng nhập, họ sẽ có tính năng "Switch to Delegated Account". Mọi hành động họ làm sẽ được ghi log: actor_id = Thư ký, on_behalf_of = Giám đốc.
3. ReBAC (Relationship-Based Access Control) - Mô hình Google Zanzibar
Vấn đề:
RBAC (Role) chỉ giải quyết được quyền hạn tĩnh (Admin/User).
Nhưng SaaS hiện đại cần quyền hạn động dựa trên quan hệ xã hội/dữ liệu:
"Tôi muốn chia sẻ tài liệu này cho User A xem."
"User A chia sẻ Folder cha cho User B -> User B tự động xem được các file con."
"Bạn của bạn tôi thì được xem profile của tôi."
Bảng access_control_lists (ACL) truyền thống sẽ bị bùng nổ dữ liệu và rất chậm khi query phân cấp sâu.
Giải pháp: Lưu trữ dưới dạng Tuples (Bộ ba quan hệ) giống Google Docs.
Bảng relationship_tuples (Trái tim của Authorization):
Cấu trúc: (Object) - (Relation) - (Subject)
VD: (Doc:123) - (viewer) - (User:A)
VD: (Doc:123) - (parent) - (Folder:456) -> Quan hệ thừa kế.
SQL
CREATE TABLE relationship_tuples (
tenant_id UUID NOT NULL,
-- Object (Tài nguyên)
namespace VARCHAR(50) NOT NULL, -- 'document', 'folder', 'project'
object_id UUID NOT NULL,
-- Relation (Quan hệ)
relation VARCHAR(50) NOT NULL, -- 'viewer', 'editor', 'owner', 'parent'
-- Subject (Ai/Cái gì?)
subject_namespace VARCHAR(50) NOT NULL, -- 'user', 'group', 'folder' (nếu là quan hệ lồng nhau)
subject_id UUID NOT NULL,
-- [Nâng cao] Subject Relation (Dùng cho nhóm lồng nhau)
-- VD: "Thành viên của Group A" -> subject_relation = 'member'
subject_relation VARCHAR(50),
created_at TIMESTAMPTZ DEFAULT NOW(),
-- Composite PK tối ưu cho việc traverse graph ngược xuôi
PRIMARY KEY (tenant_id, namespace, object_id, relation, subject_namespace, subject_id)
);
-- Index đảo ngược để trả lời câu hỏi: "User A được xem những tài liệu nào?"
CREATE INDEX idx_tuples_reverse_lookup
ON relationship_tuples (tenant_id, subject_id, relation);
-> Lợi ích: Hệ thống này cho phép bạn xây dựng tính năng "Sharing" phức tạp như Google Drive hay Notion. Đây là đẳng cấp cao nhất của Authorization hiện nay.
4. Anonymization & Data Masking (Bảo vệ PII)
Vấn đề:
Developer hoặc Database Admin (DBA) có thể truy cập DB để sửa lỗi.
Làm sao đảm bảo họ không nhìn thấy Email, SĐT thật của khách hàng?
Giải pháp: Lưu policy che giấu dữ liệu ngay trong cấu hình. (Thực tế việc che này thường làm ở tầng App hoặc DB View, nhưng cần bảng cấu hình).
Bảng data_masking_policies:
SQL
CREATE TABLE data_masking_policies (
tenant_id UUID PRIMARY KEY REFERENCES tenants(_id),
-- Cấu hình che giấu
-- VD: {
-- "email": "MASK_SHOW_LAST_4", (****@gmail.com)
-- "phone": "MASK_ALL", (********)
-- "salary": "NULLIFY"
-- }
rules JSONB NOT NULL,
-- Áp dụng cho Role nào? (Admin thì thấy hết, Support thì bị che)
applied_to_roles TEXT[] -- ['SUPPORT_STAFF', 'DEVELOPER']
);
TỔNG KẾT: IDENTITY & ACCESS MANAGEMENT (IAM) STACK
Chúc mừng! Bạn đã hoàn thành thiết kế cho một hệ thống IAM đạt chuẩn World-Class SaaS.
Dưới đây là các lớp (Layers) bạn đã xây dựng:
Identity Provider (IdP):
users, identities (AuthN).
scim_directories (Auto Provisioning - Enterprise).
oauth_clients (Platform Integration).
Access Management (AM):
sessions, mfa, webauthn (Authentication Security).
user_delegations (Impersonation).
Authorization (AuthZ):
roles, permissions (RBAC - Cho tính năng tĩnh).
relationship_tuples (ReBAC - Cho dữ liệu động/chia sẻ).
tenants, shards (Multi-tenancy isolation).
Governance (IG):
audit_logs, risk_logs.
legal_documents.
masking_policies.
Hệ thống này đủ mạnh để:
Phục vụ B2C (Social Login, Passkeys).
Phục vụ B2B SMB (Team, Invite, Roles).
Phục vụ B2B Enterprise (SSO, SCIM, Data Residency, Audit).
Bạn có thể dừng việc thiết kế Core Identity ở đây và tự tin rằng mình không bỏ sót bất kỳ yêu cầu quan trọng nào của thị trường SaaS hiện đại.
Các tài liệu cung cấp một hướng dẫn chuyên sâu về **thiết kế kiến trúc cơ sở dữ liệu** cho hệ thống **SaaS B2B quy mô lớn**, đạt chuẩn doanh nghiệp quốc tế. Nội dung tập trung vào việc xây dựng **bộ khung định danh (Identity)** vững chắc, quản lý phân quyền đa tầng và tối ưu hóa trải nghiệm người dùng thông qua các tính năng như **tính tiền theo mức sử dụng (Metering)** và **cờ tính năng (Feature Flags)**. Nguồn tài liệu cũng quy định chi tiết về **chuẩn hóa dữ liệu** và quy tắc đặt tên để đảm bảo tính nhất quán trên các nền tảng lưu trữ đa dạng như YugabyteDB, MongoDB và ClickHouse. Ngoài ra, các giải pháp nâng cao về **bảo mật**, **tự động hóa quy trình** và **khả năng mở rộng hệ sinh thái** được lồng ghép để hệ thống sẵn sàng cho hàng triệu người dùng. Cuối cùng, lộ trình triển khai được phân chia rõ ràng giúp doanh nghiệp tối ưu nguồn lực từ giai đoạn sản phẩm khả thi đến khi mở rộng toàn cầu.
keepLưu vào ghi chúcopy\_allthumb\_upthumb\_down
Làm thế nào để thiết kế cấu trúc CSDL SaaS đạt chuẩn Enterprise và World-class?
Những chiến lược nào giúp hệ thống SaaS mở rộng linh hoạt và bảo mật cao?
Các thành phần cốt lõi nào giúp tối ưu vận hành và trải nghiệm người dùng?
Chủ Nhật, 11 tháng 1
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả
Dựa trên các yêu cầu về một hệ thống SaaS "World-class" được mô tả trong nguồn dữ liệu — bao gồm việc quản lý tính tiền theo lưu lượng (Metering), bảo mật API Keys, phân tách tính năng (Feature Flags) và giám sát vận hành (Impersonation) — dưới đây là thiết kế chi tiết cho bảng **tenants** sử dụng YSQL (YugabyteDB SQL).
Bảng này đóng vai trò là hạt nhân (Core) trong phân vùng **Identity & Access**12, lưu trữ thông tin cơ bản của khách hàng tổ chức và kết nối với các mảng ghép chiến lược khác.
Thiết kế chi tiết bảng `tenants`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất cho mỗi khách hàng (Tenant). Được sử dụng làm Foreign Key cho các bảng `tenant_usages`, `api_keys`, `audit_logs`3.... |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân hoặc tên công ty của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`). Phục vụ cho cơ chế định tuyến tối ưu (Routing)26. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động. Dùng để chặn truy cập API hoặc tính năng nếu tenant bị khóa7. |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng. Hỗ trợ logic cho **Feature Flags** (VD: chỉ bật tính năng AI cho tier Enterprise)8. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí: Cố định (Fixed Fee) hoặc Theo thực tế dùng (Usage-based)26. |
| **max\_users** | INTEGER | NO | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) mặc định cho tenant, hỗ trợ kiểm soát tài nguyên6. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ của tenant, quan trọng để xác định chu kỳ tính phí trong bảng `tenant_usages`3. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tenant được khởi tạo trên hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin tenant gần nhất. |
Các điểm lưu ý từ nguồn dữ liệu áp dụng vào thiết kế:
• **Hỗ trợ Billing (Metering):** Trường `billing_type` và `_id` kết nối trực tiếp với bảng `tenant_usages` để quản lý các chỉ số như email gửi đi hoặc dung lượng lưu trữ39. Việc lưu trữ múi giờ (`timezone`) đảm bảo các Job tổng hợp dữ liệu từ ClickHouse về YugabyteDB sẽ cắt đoạn thời gian (`usage_period_start/end`) chính xác theo địa phương của khách hàng3.
• **Hỗ trợ Security (API Keys):** `_id` của bảng này là gốc để quản lý các `api_keys`. Khi trạng thái `status` của tenant chuyển sang `SUSPENDED`, hệ thống có thể lập tức vô hiệu hóa mọi truy cập từ API Key của tenant đó47.
• **Hỗ trợ Vận hành (Feature Flags & Impersonation):**
◦ Trường `tier` và `_id` được sử dụng trong bảng `feature_flags` để xác định các quy tắc (`rules`) bật/tắt tính năng cho từng nhóm khách hàng hoặc từng khách hàng cụ thể (như tính năng "AI Writing")8. ◦ Trong các bảng `audit_logs` tại ClickHouse, `tenant_id` (trỏ về `tenants._id`) là bắt buộc để truy vết các hành động "giả mạo" (Impersonation) của nhân viên hỗ trợ khi xử lý lỗi cho khách hàng15.
**Lời khuyên về lộ trình:** Theo nguồn dữ liệu, ở Giai đoạn 1 (MVP), bạn chỉ cần tập trung vào các trường cơ bản để định danh và phân gói. Các logic phức tạp về `billing_type` (Metered) có thể hoàn thiện dần khi hệ thống tiến lên Giai đoạn 3 (Growth)210.
\--------------------------------------------------------------------------------
**Ví dụ minh họa:** Hãy tưởng tượng bảng `tenants` giống như **cuốn sổ hộ khẩu** của một khu chung cư cao cấp. Mỗi dòng là một hộ gia đình. Số tầng/số phòng (`slug`) giúp bảo vệ dẫn khách vào đúng nhà, còn loại căn hộ (`tier`) quyết định họ có được dùng hồ bơi hay phòng gym không. Các hóa đơn điện nước (`tenant_usages`) cuối tháng sẽ được xuất dựa trên đúng mã định danh của hộ đó trong cuốn sổ này.
một tenant có thể mua nhiều gói dịch vụ mà?
Đúng như bạn nhận định, trong một hệ thống SaaS chuẩn Enterprise, **một Tenant hoàn toàn có thể mua và sử dụng đồng thời nhiều gói dịch vụ hoặc nhiều loại hình thanh toán khác nhau**1,2.
Dựa trên các nguồn dữ liệu, việc quản lý đa gói dịch vụ cho một khách hàng được thể hiện qua các điểm sau:
• **Tách biệt giữa Phí cố định và Phí biến đổi:** Hệ thống của bạn được thiết kế để xử lý song song hai loại hình:
◦ **Gói cố định (Fixed Fee):** Quản lý qua bảng `tenant_subscriptions`, dùng để kiểm soát các giới hạn tĩnh như "Tối đa 10 users"1,2. ◦ **Gói theo lưu lượng (Variable Fee/Metered):** Quản lý qua bảng `tenant_usages`, dùng để tính tiền dựa trên lượng dùng thực tế (như số email gửi đi, dung lượng lưu trữ)3,2.
• **Mối quan hệ 1-Nhiều (One-to-Many):** Trong cấu trúc dữ liệu của bảng `tenant_usages`, mỗi bản ghi không chỉ chứa `tenant_id` mà còn đi kèm với một **subscription\_id** riêng biệt3. Điều này xác nhận rằng một Tenant có thể có nhiều gói đăng ký (Subscriptions) khác nhau và hệ thống sẽ theo dõi mức tiêu dùng cho từng gói cụ thể đó3.
• **Khả năng mở rộng Add-on:** Với cấu trúc `Product Catalog` phân cấp, bạn có thể bán một "Gói nền" (Base Package) và sau đó khách hàng có thể mua thêm các "Gói bổ trợ" (Add-ons) hoặc các tính năng đặc thù được điều khiển qua `feature_flags`4,2.
**Ví dụ thực tế từ thiết kế:** Một khách hàng (Tenant A) có thể cùng lúc sở hữu:
1\. **Gói Pro ($100/tháng):** Cho phép tối đa 20 người dùng (Lưu trong `tenant_subscriptions`)1.
2\. **Gói Email Marketing (Metered):** Trả $0.01 cho mỗi email gửi đi (Dữ liệu tiêu dùng lưu trong `tenant_usages` và đối soát qua `subscription_id` của gói này)5,3.
3\. **Gói dùng thử tính năng AI:** Được bật qua `feature_flags` để dùng thử trong 30 ngày6,4.
\--------------------------------------------------------------------------------
**Sự ví von để bạn dễ hình dung:** Hãy coi **Tenant** là một người đi thuê căn hộ. Người này có thể ký một **hợp đồng thuê nhà cố định** hàng tháng (giống như `tenant_subscriptions`), nhưng đồng thời cũng có các **hợp đồng dịch vụ riêng lẻ** khác như tiền điện, tiền nước hoặc tiền internet tính theo dung lượng sử dụng (giống như `tenant_usages`). Tất cả các "gói" này đều phục vụ cho cùng một chủ thể nhưng có cách tính tiền và quản lý khác nhau.
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả
Dựa trên các phân tích về mô hình SaaS chuẩn Enterprise (hỗ trợ Metering, API Keys, Feature Flags và Routing tối ưu) từ nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants** sử dụng YSQL (YugabyteDB SQL).
Bảng này đóng vai trò là hạt nhân trung tâm (Core) trong phân vùng Identity & Access, kết nối với tất cả các mảng ghép chiến lược khác12.
Thiết kế chi tiết bảng `tenants`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất toàn cầu cho Tenant. Được dùng làm Foreign Key cho các bảng `tenant_usages`, `api_keys`, `audit_logs`1.... |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân hoặc tên tổ chức của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`). Phục vụ cho cơ chế định tuyến tối ưu `tenant_app_routes`2. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành. Dùng để chặn truy cập API hoặc tính năng ngay lập tức nếu khách hàng bị khóa35. |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp gói dịch vụ. Đây là cơ sở để áp dụng các `rules` trong bảng `feature_flags`26. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí: Cố định (Fixed), Theo thực tế dùng (Metered) hoặc kết hợp cả hai7.... |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ của khách hàng. Rất quan trọng để xác định chính xác chu kỳ tính phí (`usage_period_start/end`) khi tổng hợp dữ liệu từ ClickHouse3. |
| **max\_users** | INTEGER | NO | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) để kiểm soát số lượng users tối đa mà tenant có thể tạo7. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tenant gia nhập hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin tenant gần nhất. |
Giải thích các mối liên kết dựa trên nguồn dữ liệu:
• **Tính tiền theo lưu lượng (Metering):** Trường `_id` và `billing_type` là đầu nối để hệ thống Job quét dữ liệu từ ClickHouse và "bơm" vào bảng `tenant_usages`38. Việc lưu trữ `timezone` tại đây đảm bảo các báo cáo sử dụng và hóa đơn được cắt đoạn thời gian chính xác theo múi giờ địa phương của khách hàng thay vì dùng giờ UTC hệ thống3.
• **Bảo mật & API Keys:** Khi khách hàng muốn tích hợp Machine-to-Machine, bảng `api_keys` sẽ tham chiếu đến `_id` của tenant này4. Nếu trường `status` chuyển sang `SUSPENDED`, lớp Security sẽ tự động từ chối mọi yêu cầu có `tenant_id` tương ứng5.
• **Quản lý tính năng (Feature Flags):** Thay vì kiểm tra gói cước (Package) một cách cứng nhắc, hệ thống sử dụng trường `tier` hoặc `_id` để khớp với các quy tắc trong `feature_flags`. Ví dụ: Tính năng "AI Writing" có thể được bật cho 10% tenants thuộc `tier = 'ENTERPRISE'`6.
• **Vận hành & Giả mạo (Impersonation):** Trong quy trình hỗ trợ khách hàng, khi nhân viên Support thực hiện hành động "Acting As", `_id` của tenant sẽ được ghi nhận vào cột `tenant_id` trong `audit_logs` tại ClickHouse để đảm bảo tính minh bạch tuyệt đối110.
**Lời khuyên từ nguồn dữ liệu:** Ở giai đoạn đầu (MVP), bạn chỉ nên tập trung vào các trường định danh và phân gói cơ bản. Các logic phức tạp về `billing_type` (Metered) nên được hoàn thiện khi hệ thống bước vào giai đoạn Growth29.
\--------------------------------------------------------------------------------
**Sự ví von để dễ hiểu:** Bảng `tenants` giống như **"Hồ sơ gốc"** của một khách hàng trong khách sạn. Nó ghi rõ khách là ai, ở phòng nào (`slug`), đang sử dụng hạng phòng gì (`tier`) và thanh toán trọn gói hay dùng gì trả nấy (`billing_type`). Mọi dịch vụ khác như gọi đồ ăn (API Keys) hay giặt là (Metering) đều phải nhìn vào "Hồ sơ gốc" này để biết có được phép phục vụ và tính tiền cho ai.
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả; một tenant có thể mua nhiều gói dịch vụ
Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm Metering, API Keys, Feature Flags và hỗ trợ nhiều gói dịch vụ), dưới đây là thiết kế chi tiết bảng **tenants** sử dụng YSQL.
Để đáp ứng yêu cầu **"một tenant có thể mua nhiều gói dịch vụ"**, bảng `tenants` đóng vai trò là thực thể gốc (Core Entity)12. Việc quản lý các gói dịch vụ cụ thể sẽ được thực hiện thông qua các bảng quan hệ như `tenant_subscriptions` (cho phí cố định) và `tenant_usages` (cho phí theo lưu lượng)2.
Thiết kế chi tiết bảng `tenants`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất cho mỗi khách hàng tổ chức. Là gốc để tham chiếu cho `api_keys`, `tenant_subscriptions`, và `tenant_usages`2.... |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân/tổ chức của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) dùng cho cơ chế Routing tối ưu (`tenant_app_routes`)2. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động. Dùng để kiểm soát quyền truy cập hệ thống và hiệu lực của các gói dịch vụ/API Keys45. |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để áp dụng các quy tắc trong `feature_flags` (ví dụ: bật tính năng AI cho khách Enterprise)6. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Loại hình thanh toán chủ đạo (Cố định, Theo lưu lượng, hoặc kết hợp cả hai)2.... |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ của khách hàng. Cần thiết để Job tổng hợp dữ liệu từ ClickHouse về `tenant_usages` theo đúng chu kỳ ngày/giờ của khách hàng38. |
| **max\_users** | INTEGER | NO | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) mặc định cho số lượng người dùng7. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm khởi tạo tài khoản khách hàng. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin gần nhất. |
Giải quyết vấn đề mua nhiều gói dịch vụ
Theo nguồn dữ liệu, cấu trúc này hỗ trợ một Tenant sở hữu nhiều gói dịch vụ thông qua cơ chế sau:
1\. **Gói cố định (Fixed Fee):** Tenant liên kết với nhiều bản ghi trong bảng `tenant_subscriptions` (ví dụ: mua gói Core CRM và mua thêm gói Add-on HRM)2.
2\. **Gói theo lưu lượng (Usage-based):** Một Tenant có thể có nhiều chỉ số tiêu dùng khác nhau (Email, Storage, API calls) được lưu trong bảng `tenant_usages` thông qua cột `subscription_id`3. Điều này cho phép hệ thống tách biệt hóa đơn cho từng loại dịch vụ mà khách hàng đăng ký38.
3\. **Cơ chế linh hoạt:** Bảng `tenants` chỉ lưu trữ thông tin "gốc" (Identity), trong khi logic thương mại (bán gói nào, giá bao nhiêu) được tách biệt hoàn toàn để Dev có thể bật/tắt tính năng qua `feature_flags` mà không cần can thiệp vào cấu trúc thanh toán6.
\--------------------------------------------------------------------------------
**Sự ví von:** Bảng `tenants` giống như một **"Chứng minh nhân dân của doanh nghiệp"** trong hệ thống của bạn. Nó xác định danh tính và hạng thành viên. Còn việc doanh nghiệp đó mua bao nhiêu "sim điện thoại" hay "gói internet" (các gói dịch vụ) sẽ được quản lý ở các "hợp đồng" con (`subscriptions`), nhưng tất cả đều phải dựa trên số ID duy nhất từ bảng `tenants` này để đối soát và quản lý.
xem kỹ phân tích ở văn bản được dán, thiết kế lại cho đủ đi
Dựa trên các phân tích về hệ thống SaaS "World-class" từ nguồn dữ liệu (bao gồm Metering, API Keys, Feature Flags và khả năng xử lý đa gói dịch vụ), dưới đây là thiết kế chi tiết bảng **tenants** sử dụng YSQL.
Bảng này được thiết kế như một **thực thể hạt nhân (Core)** để kết nối các mảng ghép: Identity, Billing (Fixed & Metered), Security và Operations1.
Thiết kế chi tiết bảng `tenants` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất toàn cầu cho Tenant. Là gốc tham chiếu cho `tenant_subscriptions`, `tenant_usages`, `api_keys` và `audit_logs`1.... |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân hoặc tổ chức của khách hàng. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) phục vụ cơ chế **Routing tối ưu** và định danh URL14. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành. Khi `SUSPENDED`, hệ thống sẽ chặn quyền truy cập của cả User và API Keys3.... |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng. Là cơ sở để áp dụng các **Feature Flags** (VD: chỉ bật AI cho tier Enterprise)67. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Xác định Tenant dùng gói cố định, theo lưu lượng, hoặc kết hợp cả hai (Hybrid)1.... |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ của khách hàng. Cần thiết để Job tổng hợp dữ liệu từ ClickHouse về `tenant_usages` theo đúng chu kỳ ngày/giờ của khách hàng28. |
| **max\_users** | INTEGER | NO | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) để kiểm soát số lượng users tối đa (thường dùng cho gói Fixed Fee)5. |
| **metadata** | JSONB | YES | `{}` | | Lưu trữ các thông tin bổ sung linh hoạt mà không cần thay đổi cấu trúc bảng. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm Tenant gia nhập hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin gần nhất. |
Các đặc điểm đáp ứng phân tích từ nguồn dữ liệu:
1\. **Hỗ trợ mua nhiều gói dịch vụ:**
◦ Thiết kế này tách biệt bảng `tenants` (danh tính) khỏi các gói dịch vụ. Một Tenant có thể có nhiều bản ghi trong bảng **tenant\_subscriptions** (cho các gói phí cố định - Fixed Fee) và đồng thời có dữ liệu tiêu dùng trong bảng **tenant\_usages** (cho các gói tính phí theo lưu lượng - Metered)1.... ◦ Trường `billing_type` là `HYBRID` cho phép khách hàng vừa trả phí thuê bao tháng, vừa trả thêm phí theo thực tế sử dụng (ví dụ: trả phí phần mềm + $0.01/email gửi đi)18.
2\. **Tối ưu cho Metering (Tính tiền theo nhu cầu):**
◦ Việc lưu trữ `timezone` ngay tại bảng Tenant giúp các Worker tổng hợp dữ liệu từ ClickHouse xác định chính xác thời điểm bắt đầu và kết thúc chu kỳ (`usage_period_start/end`) của từng khách hàng để ghi vào bảng `tenant_usages`28.
3\. **Hỗ trợ Security & API Keys:**
◦ Trường `_id` là chìa khóa để quản lý các **api\_keys**. Khi khách hàng cần tích hợp Machine-to-Machine, hệ thống sẽ cấp Key dựa trên ID này, cho phép thu hồi (Revoke) Key mà không ảnh hưởng đến tài khoản người dùng chính36.
4\. **Quản trị và Vận hành (Feature Flags & Impersonation):**
◦ Dựa vào `tier` và `_id`, bộ phận Product có thể dùng **feature\_flags** để bật/tắt tính năng mới cho từng nhóm khách hàng mà không cần sửa code67. ◦ Mọi hành động "Acting As" (Impersonation) của nhân viên hỗ trợ sẽ được lưu vào ClickHouse kèm theo `tenant_id` từ bảng này để đảm bảo minh bạch49.
\--------------------------------------------------------------------------------
**Ví von để dễ hình dung:** Bảng `tenants` giống như **"Thẻ căn cước"** của một doanh nghiệp trong hệ thống của bạn. Nó xác định doanh nghiệp đó là ai và có hạng thành viên nào. Việc doanh nghiệp đó mua bao nhiêu "gói cước điện thoại" hay "gói internet" (các Subscriptions) và dùng bao nhiêu "dung lượng 4G" (Metering) sẽ được ghi chép ở các hóa đơn con, nhưng tất cả đều phải quy chiếu về tấm thẻ căn cước duy nhất này.
uuid v7 mà?
Bạn rất tinh ý. Việc sử dụng **UUID v7** thay cho UUID v4 (loại mặc định của hàm `gen_random_uuid()`) là một nâng cấp quan trọng để đạt đến chuẩn "World-class" như các nguồn dữ liệu đã đề cập1.
Dưới đây là lý do tại sao nên dùng UUID v7 cho bảng `tenants` và thiết kế cập nhật:
Tại sao UUID v7 lại tối ưu cho YugabyteDB (YSQL)?
1\. **Tính sắp xếp theo thời gian (Time-ordered):** Khác với UUID v4 là hoàn toàn ngẫu nhiên, UUID v7 có chứa timestamp ở các bit đầu tiên. Điều này giúp các bản ghi được chèn vào database theo thứ tự thời gian, cực kỳ có lợi cho hiệu năng index của YugabyteDB (giảm thiểu tình trạng phân mảnh index và giúp việc query các tenant mới nhất nhanh hơn)12.
2\. **Khả năng thay thế hoàn hảo:** UUID v7 vẫn có độ dài 128-bit và tương thích hoàn toàn với kiểu dữ liệu `UUID` trong YSQL, không làm thay đổi cấu trúc lưu trữ đã phân tích trong các nguồn34.
Thiết kế chi tiết bảng `tenants` (Cập nhật UUID v7)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | _(Generated by App/Extension)_ | `PRIMARY KEY` | Định danh duy nhất. **Sử dụng UUID v7** để tối ưu hóa việc sắp xếp và hiệu suất ghi vào phân vùng Identity15. |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân/tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) phục vụ cho **Routing tối ưu**5. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', ...))` | Trạng thái hoạt động để kiểm soát quyền truy cập API/Feature Flags67. |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để áp dụng các rules trong **Feature Flags**7. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí, hỗ trợ mô hình **Metering**18. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse về chính xác23. |
| **metadata** | JSONB | YES | `{}` | | Lưu trữ linh hoạt các chỉ số hoặc cấu hình bổ sung3. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo (trùng khớp với timestamp trong UUID v7). |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin gần nhất. |
Các điểm lưu ý từ nguồn dữ liệu áp dụng cho UUID v7:
• **Hiệu năng ghi log:** Khi bạn ghi nhận hàng tỷ sự kiện vào ClickHouse trong bảng `usage_events`, việc dùng UUID v7 làm `tenant_id` sẽ giúp các câu lệnh join giữa YugabyteDB và ClickHouse trở nên mượt mà hơn do dữ liệu có tính tuần tự29.
• **Bảo mật:** UUID v7 vẫn đảm bảo tính khó đoán (collision resistance) tương đương UUID v4, phù hợp để làm ID gốc cho các **API Keys** mà không lo bị dò quét46.
• **Lộ trình triển khai:** Mặc dù trong các ví dụ code của nguồn dữ liệu có dùng `gen_random_uuid()` (v4)34, nhưng đối với các hệ thống quy mô lớn (Giai đoạn 2 & 3), việc chuyển sang UUID v7 là một bước đi đúng đắn để tối ưu hóa "Infrastructure" và "Routing"58.
**Lời khuyên:** Vì YSQL dựa trên PostgreSQL, bạn có thể tạo UUID v7 ở tầng Application (ví dụ dùng thư viện trong Java/Go/Node.js) trước khi insert, hoặc cài đặt extension hỗ trợ UUID v7 nếu phiên bản DB của bạn cho phép.
\--------------------------------------------------------------------------------
**Ví dụ minh họa:** Nếu UUID v4 giống như việc ném những viên gạch vào một cái kho một cách ngẫu nhiên khiến việc tìm kiếm vất vả, thì **UUID v7** giống như việc bạn đánh số thứ tự và ngày tháng lên từng viên gạch trước khi xếp chúng vào kho. Bạn vẫn có những viên gạch định danh duy nhất, nhưng việc sắp xếp và tìm những viên mới nhất trở nên vô cùng nhanh chóng.
thiếu region\_code?
Phân tích của bạn rất chính xác và sắc sảo. Việc bổ sung trường **region\_code** là thực sự cần thiết để hoàn thiện bức tranh "World-class SaaS", đặc biệt khi đối chiếu với các yêu cầu về **Routing tối ưu** và **Feature Flags** trong nguồn dữ liệu1,2.
Dưới đây là bảng thiết kế đã được cập nhật thêm trường `region_code` cùng các logic liên quan:
Thiết kế chi tiết bảng `tenants` (Bổ sung `region_code`)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (khuyến khích dùng UUID v7 để tối ưu sắp xếp).3,4 |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`). |
| **region\_code** | VARCHAR(50) | NO | `'us-east-1'` | | **Mã vùng triển khai** (VD: `vn-north-1`, `eu-central-1`). Dùng cho Routing và Feature Flags.1,2 |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN (...))` | Trạng thái hoạt động của tenant.5 |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN (...))` | Phân cấp khách hàng (Free, Pro, Enterprise).3,1 |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | | Loại hình tính phí (Fixed, Metered, Hybrid).6,7 |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ để tổng hợp dữ liệu `tenant_usages` chính xác.4 |
| **metadata** | JSONB | YES | `{}` | | Lưu trữ linh hoạt các thông tin phụ. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm khởi tạo. |
Tại sao `region_code` lại quan trọng theo các nguồn dữ liệu?
1\. **Kiểm soát tính năng theo địa lý (Feature Flags):** Nguồn dữ liệu đề cập rằng bảng `feature_flags` có thể chứa các quy tắc như `"excluded_regions": ["eu-central-1"]`1. Nếu không có trường `region_code` trong bảng `tenants`, hệ thống sẽ không biết khách hàng đó có thuộc vùng bị loại trừ hay không để bật/tắt tính năng (như "AI Writing")5,1.
2\. **Định tuyến dữ liệu (Routing):** Trong phần hạ tầng, nguồn dữ liệu nhắc đến `tenant_app_routes` để thực hiện "Routing tối ưu"2. Trong kiến trúc phân tán (Multi-region), `region_code` giúp hệ thống điều hướng yêu cầu của người dùng đến cụm server gần nhất hoặc đúng nơi lưu trữ dữ liệu của họ, đảm bảo tốc độ và tuân thủ pháp lý về dữ liệu (như GDPR)3,2.
3\. **Hỗ trợ vận hành (Operations):** Khi nhân viên hỗ trợ thực hiện "Impersonation", việc biết tenant thuộc vùng nào giúp họ xác định đúng môi trường cần truy cập để kiểm tra lỗi8,9.
**Lời khuyên:** Việc thêm `region_code` giúp bạn sẵn sàng cho kịch bản mở rộng toàn cầu. Thậm chí, trường này có thể dùng làm **Partition Key** trong YugabyteDB nếu sau này bạn muốn phân vùng dữ liệu vật lý theo vị trí địa lý của khách hàng.
\--------------------------------------------------------------------------------
**Sự ví von:** Nếu `_id` là số căn cước, thì **region\_code** giống như **mã vùng hộ khẩu** của doanh nghiệp. Khi bạn muốn triển khai một dịch vụ chỉ dành riêng cho khu vực miền Bắc (Feature Flags theo vùng), hoặc muốn bưu điện gửi thư đến bưu cục gần nhà khách hàng nhất (Routing), bạn bắt buộc phải nhìn vào mã vùng này trên hồ sơ của họ.
thiếu updated\_at, deleted\_at
Bạn hoàn toàn đúng. Việc bổ sung **updated\_at** và **deleted\_at** là bước hoàn thiện cuối cùng để bảng `tenants` đạt chuẩn **"World-class SaaS"**, giúp hệ thống không chỉ vận hành tốt mà còn đáp ứng các yêu cầu khắt khe về **Audit Log** và **Khôi phục dữ liệu** (Soft Delete)12.
Dưới đây là thiết kế chi tiết đầy đủ nhất cho bảng **tenants** dùng YSQL, tích hợp tất cả các thành phần đã phân tích:
Thiết kế chi tiết bảng `tenants` (Full Version)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7). Là hạt nhân kết nối `api_keys`, `tenant_subscriptions` và `tenant_usages`34. |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`) dùng cho **Routing tối ưu**4. |
| **region\_code** | VARCHAR(50) | NO | | | Mã vùng triển khai, hỗ trợ quy tắc loại trừ trong **Feature Flags**5. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành của Tenant3. |
| **tier** | VARCHAR(20) | NO | `'FREE'` | | Phân cấp gói dịch vụ để áp dụng **Feature Flags**5. |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | | Loại hình tính phí (Fixed, Metered, Hybrid)16. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse chính xác37. |
| **metadata** | JSONB | YES | `{}` | | Lưu trữ linh hoạt các thông tin bổ sung. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | **Thời điểm cập nhật bản ghi gần nhất.** Tự động cập nhật qua Trigger khi có thay đổi thông tin. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | **Thời điểm xóa (Soft Delete).** Nếu không NULL, Tenant coi như đã bị xóa nhưng dữ liệu vẫn tồn tại cho mục đích **Audit**2. |
Tầm quan trọng của `updated_at` và `deleted_at` theo nguồn dữ liệu:
1\. **Duy trì tính minh bạch (Audit Logs):** Nguồn dữ liệu nhấn mạnh vào việc minh bạch tuyệt đối trong vận hành2. Khi một nhân viên thực hiện **Impersonation** và thay đổi cấu hình Tenant, `updated_at` sẽ ghi lại dấu mốc thời gian đó, giúp đối soát với `audit_logs` trong ClickHouse để biết chính xác ai đã làm gì và khi nào28.
2\. **Cơ chế Soft Delete (Xóa mềm):** Với các hệ thống SaaS Enterprise, việc xóa vật lý (Hard Delete) dữ liệu khách hàng là cực kỳ rủi ro1. Trường `deleted_at` cho phép bạn thực hiện "Xóa mềm":
◦ Ngay lập tức chặn truy cập của Tenant và vô hiệu hóa các `api_keys` liên quan910. ◦ Giữ lại dữ liệu để bộ phận kỹ thuật có thể khôi phục nếu khách hàng gia hạn lại hoặc để phục vụ điều tra sự cố trong tương lai2.
3\. **Hỗ trợ chu kỳ Billing:** Khi một Tenant hủy dịch vụ giữa chừng, `deleted_at` giúp hệ thống Metering xác định điểm dừng để tính toán hóa đơn cuối cùng trong bảng `tenant_usages` một cách công bằng37.
\--------------------------------------------------------------------------------
**Sự ví von để ghi nhớ:** Nếu bảng `tenants` là một **cuốn sổ hộ khẩu**, thì `updated_at` chính là **dòng ghi chú** mỗi khi có thay đổi về nhân khẩu hoặc địa chỉ, còn `deleted_at` giống như việc **gạch tên** nhưng không xé trang giấy đó đi. Việc giữ lại trang giấy (Soft Delete) giúp chính quyền (hệ thống) vẫn có thể tra cứu lại lịch sử khi cần thiết thay vì mất trắng thông tin.
ghi chú rõ cho tier, metadata
Dưới đây là thiết kế chi tiết bảng **tenants** được chuẩn hóa cho YSQL, tập trung vào việc giải quyết các bài toán về quy mô và tính linh hoạt thông qua hai trường quan trọng là `tier` và `metadata`.
Thiết kế chi tiết bảng `tenants` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (Sử dụng UUID v7 để tối ưu sắp xếp theo thời gian)1,2. |
| **name** | VARCHAR(255) | NO | | `UNIQUE` | Tên pháp nhân hoặc tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO | | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`) phục vụ Routing tối ưu1,2. |
| **region\_code** | VARCHAR(50) | NO | | | Mã vùng (VD: `us-east-1`). Dùng để áp dụng logic vùng miền trong **Feature Flags**3. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động để kiểm soát quyền truy cập API và hệ thống4,5. |
| **tier** | **VARCHAR(20)** | **NO** | **'FREE'** | **CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))** | **Phân cấp khách hàng để điều khiển tính năng (Xem chi tiết bên dưới).**3,2 |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | | Loại hình tính phí: Cố định, Theo lưu lượng (Metered), hoặc Hybrid1,6. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse chính xác6,7. |
| **metadata** | **JSONB** | **YES** | **{}** | | **Lưu trữ thuộc tính linh hoạt (Xem chi tiết bên dưới).**7 |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin gần nhất. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm xóa mềm (Soft Delete) phục vụ Audit8,9. |
\--------------------------------------------------------------------------------
Ghi chú chi tiết cho các trường quan trọng:
1\. Trường `tier` (Phân cấp khách hàng)
Trường này không chỉ đơn thuần để gọi tên gói cước mà đóng vai trò là **bộ lọc chiến lược** cho hệ thống:
• **Điều khiển Feature Flags:** Thay vì cấu hình bật tính năng cho từng Tenant ID (gây quá tải bảng cấu hình), hệ thống sử dụng `tier` như một "Strategy" trong bảng `feature_flags`3. Ví dụ: Quy tắc của tính năng "AI Writing" có thể được thiết lập là `{ "allowed_tiers": ["ENTERPRISE"] }`3.
• **Tách biệt Kỹ thuật và Thương mại:** Giúp đội ngũ Kỹ thuật có thể triển khai tính năng mới cho toàn bộ nhóm khách hàng (Tier) mà không cần can thiệp vào tầng thanh toán (Billing) phức tạp3,10.
• **Phân quyền truy cập nhanh:** Hỗ trợ hệ thống RBAC (Role-Based Access Control) đưa ra quyết định nhanh chóng về việc một tổ chức có quyền sử dụng một phân hệ (Module) nhất định hay không2.
2\. Trường `metadata` (Dữ liệu mở rộng linh hoạt)
Sử dụng kiểu dữ liệu **JSONB** (tương tự cách lưu `metrics_data` trong bảng `tenant_usages`) mang lại khả năng tùy biến cực cao7:
• **Lưu trữ thông tin tùy biến (Custom Attributes):** Mỗi doanh nghiệp có thể yêu cầu lưu thêm các thông tin đặc thù (như: Mã số thuế, Màu sắc thương hiệu, ID hệ thống cũ) mà không cần thực hiện `ALTER TABLE` làm gián đoạn database1,7.
• **Cấu hình đặc thù cho Integration:** Lưu các thông số kết nối hoặc Token của bên thứ ba mà chỉ riêng Tenant đó sử dụng khi tích hợp qua API Keys4,5.
• **Hỗ trợ Vận hành:** Nhân viên Support khi thực hiện "Impersonation" có thể dựa vào thông tin trong `metadata` để hiểu rõ bối cảnh đặc thù của khách hàng mà không cần truy vấn nhiều bảng khác8,9.
**Sự ví von để dễ hiểu:**
• **tier** giống như **hạng thẻ thành viên** (Vàng, Bạc, Đồng) của một hãng hàng không, quyết định bạn được vào phòng chờ thương gia hay không.
• **metadata** giống như **túi hành lý cá nhân** của mỗi khách hàng; mỗi người mang một thứ khác nhau (người mang máy ảnh, người mang sách) nhưng hãng hàng không vẫn quản lý chung được tất cả dưới một mã vé (Tenant ID) mà không cần xây riêng từng kho chứa cho mỗi loại đồ vật.
phần tier và billing\_type lưu trong bảng tenant\_subscriptions được không?
Về mặt kỹ thuật, bạn **hoàn toàn có thể** lưu `tier` và `billing_type` trong bảng `tenant_subscriptions`. Tuy nhiên, dựa trên kiến trúc SaaS "World-class" và các phân tích từ nguồn dữ liệu, việc giữ các trường này ở bảng **tenants** (bảng Core) là phương án tối ưu hơn vì những lý do chiến lược sau:
1\. Tách biệt giữa "Danh tính" và "Giao dịch thương mại"
• **Bảng** **tenants** **đại diện cho Danh tính (Identity):** Trường `tier` ở đây đóng vai trò là "hạng thành viên" tổng quát của khách hàng (ví dụ: khách hàng Enterprise luôn được ưu tiên hỗ trợ bất kể họ đang dùng gói dịch vụ nào)1.
• **Bảng** **tenant\_subscriptions** **đại diện cho Giao dịch (Commercial):** Bảng này lưu trữ các gói cụ thể mà họ đã mua (ví dụ: Gói CRM Pro, Gói HRM Basic)1.
• **Lợi ích:** Khi bạn cần kiểm tra nhanh xem một Tenant có được phép truy cập hệ thống hay không (thông qua `status`), việc có sẵn `tier` và `billing_type` ngay tại bảng Core sẽ giúp giảm bớt các lệnh `JOIN` phức tạp, tối ưu hóa hiệu năng cho các tác vụ cơ bản2.
2\. Phục vụ cơ chế Feature Flags (Cờ tính năng)
• Nguồn dữ liệu nhấn mạnh việc sử dụng **feature\_flags** để điều khiển tính năng dựa trên `rules` (quy tắc)3.
• Các quy tắc này thường truy vấn theo cấp độ Tenant (ví dụ: "Chỉ bật AI cho Tier Enterprise" hoặc "Tắt tính năng này ở Region EU")3. Nếu `tier` nằm ở bảng `tenant_subscriptions`, hệ thống sẽ phải quét qua nhiều gói dịch vụ mà Tenant đó đã mua để xác định cấp độ của họ, gây chậm trễ trong việc phản hồi tính năng (latency)3.
3\. Quản lý mô hình Billing Hybrid (Phí hỗn hợp)
• Khi hệ thống tiến đến Giai đoạn 3 (Growth), bạn sẽ cần xử lý tính tiền theo lưu lượng (**Metering**)4.
• Trường `billing_type` ở bảng `tenants` xác định **mô hình kinh doanh tổng thể** của khách hàng đó (ví dụ: khách hàng này thuộc nhóm luôn trả phí theo lưu lượng - `METERED`)2,5.
• Trong khi đó, `tenant_subscriptions` chỉ quản lý các giới hạn tĩnh (Quota)2. Việc tách biệt giúp bạn dễ dàng chạy các Job tổng hợp dữ liệu từ ClickHouse về bảng `tenant_usages` mà không bị lẫn lộn giữa các loại hình thanh toán khác nhau của cùng một khách hàng5,6.
4\. Giải quyết bài toán "Một Tenant mua nhiều gói"
Nếu bạn đưa `tier` vào `tenant_subscriptions`, một vấn đề sẽ phát sinh: **Nếu một Tenant mua một gói "Pro" và một gói "Free" cùng lúc, thì họ thuộc Tier nào?**
• Bằng cách giữ `tier` ở bảng `tenants`, bạn xác định được **vị thế cao nhất** của khách hàng đó trong hệ thống.
• Bảng `tenant_subscriptions` sẽ chỉ tập trung vào việc quản lý thời hạn và quyền hạn cụ thể của từng gói dịch vụ riêng lẻ1.
\--------------------------------------------------------------------------------
**Ví dụ minh họa:** Hãy tưởng tượng bảng `tenants` giống như chiếc **Thẻ thành viên (VIP/Gold/Member)** của một sòng bài lớn. Chiếc thẻ này (`tier`) quyết định bạn có được vào khu vực hút xì gà hay không (`feature_flags`). Còn bảng `tenant_subscriptions` giống như các **biên lai mua chip** hoặc **vé xem show** tại các quầy khác nhau trong sòng bài đó. Dù bạn mua bao nhiêu vé, thì hạng thẻ VIP trên tay bạn vẫn là "nguồn sự thật" duy nhất để nhân viên an ninh phục vụ bạn nhanh nhất.
thiết kế chi tiết bảng users dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả
Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm RBAC, Impersonation và quản lý danh tính), dưới đây là thiết kế chi tiết bảng **users** sử dụng YSQL.
Bảng này được thiết kế để tách biệt giữa người dùng thực (Human) và các truy cập máy (Machine), đồng thời hỗ trợ cơ chế giả mạo (Impersonation) minh bạch và phân quyền chuyên sâu1....
Thiết kế chi tiết bảng `users` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (Sử dụng **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và hiệu suất index). |
| **tenant\_id** | UUID | NO | | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định người dùng thuộc tổ chức (Tenant) nào3. |
| **email** | VARCHAR(255) | NO | | `UNIQUE` | Địa chỉ email dùng để đăng nhập và nhận thông báo. |
| **password\_hash** | VARCHAR(255) | NO | | | Chuỗi băm mật khẩu bảo mật (Không lưu mật khẩu gốc). |
| **full\_name** | VARCHAR(100) | NO | | | Tên đầy đủ của người dùng2. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'DISABLED', 'INVITED'))` | Trạng thái tài khoản. Khi `DISABLED`, người dùng không thể đăng nhập hoặc tạo API Keys14. |
| **role\_id** | UUID | NO | | | Liên kết với bảng `roles` để thực hiện phân quyền **RBAC**3. |
| **is\_support\_staff** | BOOLEAN | NO | `FALSE` | | Đánh dấu nếu đây là nhân viên của nhà cung cấp SaaS để thực hiện tính năng **Impersonation**25. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ cá nhân, hỗ trợ hiển thị báo cáo trong `tenant_usages`6. |
| **metadata** | JSONB | YES | `{}` | | Lưu thông tin tùy chỉnh (Avatar, tùy chọn giao diện, v.v.). |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo tài khoản. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật thông tin gần nhất. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm xóa mềm (Soft Delete) để giữ lại dữ liệu cho **Audit Log**2. |
Các đặc điểm đáp ứng phân tích từ nguồn dữ liệu:
• **Hỗ trợ Bảo mật & API Keys:** Trường `_id` của User được sử dụng làm `created_by` trong bảng `api_keys`4. Điều này cho phép hệ thống truy vết chính xác cá nhân nào trong tổ chức đã tạo ra chìa khóa truy cập cho máy (Machine-to-Machine)1.
• **Cơ chế Impersonation (Giả mạo):** Trường `is_support_staff` là điều kiện cần để hệ thống cho phép một người dùng thực hiện hành động "Acting As"2. Khi nhân viên này đăng nhập vào tài khoản khách hàng, ID của họ sẽ được ghi vào cột `impersonator_id` trong hệ thống log tại ClickHouse để đảm bảo minh bạch tuyệt đối5.
• **Phân quyền (RBAC):** Thông qua `role_id`, hệ thống có thể kiểm soát các `scopes` (phạm vi quyền hạn) tương tự như cách quản lý `scopes` cho API Keys (VD: `crm:read`, `hrm:write`)34.
• **Tính linh hoạt (Metadata):** Kiểu dữ liệu `JSONB` được áp dụng cho trường `metadata` để lưu trữ các thuộc tính linh hoạt mà không cần thay đổi cấu trúc bảng thường xuyên, tương tự như cách lưu trữ `metrics_data` trong phần Billing6.
\--------------------------------------------------------------------------------
**Sự ví von để dễ hiểu:** Nếu bảng `tenants` là một **tòa nhà công ty**, thì bảng `users` giống như **danh sách nhân viên** có thẻ ra vào tòa nhà đó. Trường `is_support_staff` giống như một chiếc **thẻ vạn năng** của nhân viên bảo trì (Support Team), cho phép họ vào phòng của khách để sửa chữa khi có yêu cầu, nhưng mọi hành động của họ đều được camera (`audit_logs`) ghi lại để đảm bảo an toàn.
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả
Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm khả năng quản lý đa gói dịch vụ, định vị dữ liệu toàn cầu, tính tiền theo lưu lượng và bảo mật chuyên sâu) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **tenants** cho YugabyteDB (YSQL).
Bảng này đóng vai trò là **hạt nhân định danh (Core Identity)**, tách biệt hoàn toàn khỏi các thực thể thương mại như gói cước (subscriptions) để hỗ trợ mô hình một khách hàng mua nhiều sản phẩm1....
Thiết kế chi tiết bảng `tenants` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất. Sử dụng **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và hiệu năng index trong YugabyteDB4.... |
| **code** | VARCHAR(64) | NO | | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số, gạch ngang. Dùng cho **Routing tối ưu**7.... |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty hoặc tổ chức810. |
| **data\_region** | VARCHAR(50) | NO | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | **Data Residency**. Quy định vị trí vật lý lưu dữ liệu (Geo-Partitioning) để tuân thủ luật pháp và giảm độ trễ11.... |
| **compliance\_level** | VARCHAR(20) | NO | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định logic xử lý xóa và log dữ liệu nhạy cảm8.... |
| **status** | VARCHAR(20) | NO | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))` | Trạng thái Master. Dùng làm "cầu dao tổng" để chặn truy cập ngay cả khi gói cước còn hạn16.... |
| **tier** | VARCHAR(20) | NO | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để điều khiển **Feature Flags** và ưu tiên hỗ trợ19.... |
| **billing\_type** | VARCHAR(20) | NO | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Xác định mô hình tính phí chủ đạo để Job tổng hợp dữ liệu từ ClickHouse hoạt động chính xác22.... |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ hành chính để tính toán chính xác chu kỳ sử dụng và thời điểm hết hạn gói cước theo giờ địa phương16.... |
| **active\_apps** | TEXT\[\] | YES | `NULL` | | **Cache danh sách App**. Mảng chứa mã các ứng dụng mà tenant có quyền truy cập để API Gateway kiểm tra nhanh17.... |
| **metadata** | JSONB | NO | `'{}'` | | Lưu trữ linh hoạt các thông tin profile như Logo, Website, Tax Code hoặc các thuộc tính tùy chỉnh8.... |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm khách hàng đăng ký vào hệ thống (UTC)3132. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật dữ liệu gần nhất, phục vụ Audit30.... |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | **Soft Delete**. Nếu khác NULL, coi như tenant đã bị hủy nhưng vẫn giữ lại dữ liệu để đối soát25.... |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Ngăn chặn việc ghi đè dữ liệu đồng thời khi nhiều Admin cùng chỉnh sửa30.... |
Các điểm lưu ý quan trọng theo nguồn dữ liệu:
• **Hỗ trợ đa gói cước:** Các trường về ngày hết hạn cụ thể (`subscription_end_at`) đã được đưa sang bảng `tenant_subscriptions`. Bảng này chỉ giữ lại `status` và `tier` làm "nguồn sự thật" để hệ thống ra quyết định nhanh về quyền truy cập1....
• **Chiến lược Sharding:** Trong YugabyteDB, `_id` (UUID v7) giúp phân tán dữ liệu đều trên các node. Nếu bạn kích hoạt **Geo-Partitioning**, Primary Key thực tế nên được cấu hình là `((data_region), _id)` để dữ liệu tự động chạy về server vật lý gần khách hàng nhất3738.
• **Tính linh hoạt của Metadata:** Việc sử dụng kiểu `JSONB` cho trường `metadata` (hoặc `profile`) giúp bạn tránh việc phải thực hiện `ALTER TABLE` khi khách hàng yêu cầu thêm các trường thông tin đặc thù2939.
• **Hiệu năng Routing:** Cột `code` (slug) cần được đánh index duy nhất kèm điều kiện `WHERE deleted_at IS NULL` để tối ưu hóa việc định tuyến URL từ Subdomain4041.
\--------------------------------------------------------------------------------
**Sự ví von để dễ hình dung:** Bảng `tenants` giống như một **"Hồ sơ gốc của một tập đoàn"**. Nó xác định tập đoàn đó ở đâu (`data_region`), theo luật nào (`compliance_level`) và có đang bị phong tỏa hay không (`status`). Còn việc tập đoàn đó mua bao nhiêu "gói dịch vụ lẻ" hay "phần mềm con" (Multi-subscriptions) thì được ghi ở các phụ lục hợp đồng riêng, nhưng tất cả đều phải quy chiếu về mã số hồ sơ gốc (`_id`) này1742.
câu lệnh ysql tạo bảng tenants
Dưới đây là câu lệnh **YSQL (YugabyteDB SQL)** hoàn chỉnh để tạo bảng **tenants**, được tổng hợp từ các phân tích chuyên sâu nhất trong nguồn dữ liệu nhằm đáp ứng mô hình SaaS chuẩn Enterprise (hỗ trợ đa gói cước, đa vùng dữ liệu, và quản trị an ninh tuyệt đối)1....
1\. Câu lệnh YSQL tạo bảng `tenants`
Câu lệnh này sử dụng **UUID v7** (được tạo từ tầng Application hoặc extension) để tối ưu hóa hiệu suất index theo thời gian4.
```
CREATE TABLE tenants (
-- I. ĐỊNH DANH & HẠ TẦNG (CORE IDENTITY)
_id UUID PRIMARY KEY, -- Sử dụng UUID v7 để sắp xếp theo thời gian và tránh Hotspot [4, 5]
code VARCHAR(64) NOT NULL, -- Slug/Subdomain (VD: 'acme-corp'). Chỉ chứa a-z, 0-9 và dấu gạch ngang [6, 7]
name TEXT NOT NULL, -- Tên hiển thị tổ chức [6]
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1', -- Vùng lưu trữ dữ liệu (Geo-Partitioning) [8, 9]
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD', -- Mức độ tuân thủ: GDPR, HIPAA, PCI-DSS [10, 11]
-- II. TRẠNG THÁI & PHÂN CẤP (OPERATIONAL STATE)
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL', -- Trạng thái: TRIAL, ACTIVE, SUSPENDED, DELETED [12, 13]
tier VARCHAR(20) NOT NULL DEFAULT 'FREE', -- Phân cấp: FREE, PRO, ENTERPRISE (Dùng cho Feature Flags) [14, 15]
billing_type VARCHAR(20) NOT NULL DEFAULT 'FIXED', -- FIXED, METERED, HYBRID [12, 15]
-- III. CẤU HÌNH ĐỊA PHƯƠNG (LOCALIZATION)
timezone VARCHAR(50) NOT NULL DEFAULT 'UTC', -- Múi giờ để tính chu kỳ Billing chính xác [12, 13]
locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN', -- Ngôn ngữ mặc định [12, 13]
currency_code VARCHAR(3) NOT NULL DEFAULT 'VND', -- Mã tiền tệ ISO 4217 [13, 16]
-- IV. DỮ LIỆU ĐỘNG & CACHE (FLEXIBILITY)
active_apps TEXT[], -- Mảng mã ứng dụng được phép dùng để Gatekeeper check nhanh [15, 17]
metadata JSONB NOT NULL DEFAULT '{}', -- Lưu trữ linh hoạt logo, website, tax_code... [18, 19]
-- V. TRUY VẾT & PHIÊN BẢN (AUDIT & CONCURRENCY)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), [20, 21]
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), [20, 21]
deleted_at TIMESTAMPTZ, -- Soft Delete [20, 21]
created_by UUID, -- User ID người tạo [20, 22]
updated_by UUID, -- User ID người sửa cuối [20, 22]
version BIGINT NOT NULL DEFAULT 1, -- Chống ghi đè đồng thời (Optimistic Locking) [21, 23]
-- RÀNG BUỘC DỮ LIỆU (CONSTRAINTS)
CONSTRAINT uq_tenants_code UNIQUE (code), [17, 24]
CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'), [7, 25]
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')), [24]
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')), [24]
CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')), [24]
CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at) [16]
);
```
2\. Các chỉ mục (Indexes) chiến lược
Để hỗ trợ khả năng định tuyến (Routing) và tra cứu cực nhanh, các chỉ mục sau là bắt buộc5...:
```
-- Tìm kiếm tenant theo Subdomain/Slug (Dùng cho API Gateway/Router)
CREATE UNIQUE INDEX idx_tenants_code_active ON tenants (code) WHERE deleted_at IS NULL; [27]
-- Tìm kiếm nhanh các ứng dụng mà Tenant đang sở hữu
CREATE INDEX idx_tenants_active_apps ON tenants USING GIN (active_apps); [27]
-- Thống kê và quản trị theo vùng dữ liệu và gói cước
CREATE INDEX idx_tenants_region_tier ON tenants (data_region, tier, status); [26, 27]
```
3\. Giải thích các thành phần "World-class" trong thiết kế
• **UUID v7 làm Khóa chính:** Việc sử dụng UUID v7 giúp các bản ghi mới luôn được chèn vào cuối index, giúp **giảm thiểu phân mảnh dữ liệu** và tăng tốc độ ghi đồng thời trong hệ thống phân tán như YugabyteDB48.
• **Trường** **data\_region****:** Đây là "vũ khí" để tuân thủ luật bảo mật dữ liệu (như GDPR). Nó cho phép hệ thống định tuyến dữ liệu vật lý về đúng server tại vùng địa lý mà khách hàng yêu cầu (Geo-Partitioning)910.
• **Trường** **tier** **và Feature Flags:** Thay vì kiểm tra gói cước phức tạp ở tầng code, hệ thống sử dụng `tier` để khớp với các quy tắc (rules) trong bảng `feature_flags`, cho phép **bật/tắt tính năng nóng** (như AI Writing) cho từng nhóm khách hàng mà không cần deploy lại1112.
• **Trường** **metadata** **(JSONB):** Đây là nơi chứa các thuộc tính linh hoạt. Thay vì thực hiện `ALTER TABLE` mỗi khi khách hàng muốn thêm một trường như "Mã số thuế" hay "Link TikTok", bạn chỉ cần đưa chúng vào cục JSON này1314.
• **Cơ chế Soft Delete (****deleted\_at****):** Tuyệt đối không xóa vật lý dữ liệu doanh nghiệp. Việc giữ lại bản ghi giúp hệ thống duy trì **tính minh bạch (Audit)** và có khả năng khôi phục nhanh khi khách hàng quay lại1516.
\--------------------------------------------------------------------------------
**Ví dụ minh họa:** Hãy coi bảng `tenants` này như **"Hộ chiếu điện tử"** của một doanh nghiệp.
• `_id` là mã số định danh duy nhất toàn cầu.
• `data_region` là quốc gia cấp hộ chiếu (nơi lưu dữ liệu gốc).
• `status` và `tier` cho biết quyền hạn của doanh nghiệp (được đi qua cửa khẩu nào, hạng thương gia hay phổ thông).
• `metadata` giống như trang ghi chú bổ sung, nơi bạn có thể dán thêm bất kỳ "visa" hay thông tin đặc thù nào mà không cần đổi quyển hộ chiếu mới.
thiết kế chi tiết bảng users dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng
Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **users** (đại diện cho danh tính toàn cục - Global Identity) sử dụng YSQL1....
Thiết kế này sử dụng **UUID v7** để tối ưu hóa hiệu suất index theo thời gian và đáp ứng các yêu cầu về bảo mật, phân quyền (RBAC) và giả mạo (Impersonation) đã được thảo luận4....
Thiết kế chi tiết bảng `users` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất toàn cục. Sử dụng **UUID v7** để sắp xếp theo thời gian, giúp tăng tốc độ chèn và truy vấn45. |
| **email** | VARCHAR(255) | NO | | `UNIQUE`, `CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')` | Email đăng nhập chính. Phải là duy nhất trên toàn sàn và đúng định dạng57. |
| **password\_hash** | TEXT | YES | `NULL` | | Chuỗi băm mật khẩu (Argon2/Bcrypt). Để trống nếu người dùng chỉ sử dụng SSO hoặc Social Login7.... |
| **full\_name** | TEXT | NO | | `CHECK (LENGTH(full_name) > 0)` | Tên hiển thị mặc định của người dùng510. |
| **phone\_number** | VARCHAR(20) | YES | `NULL` | `UNIQUE` | Số điện thoại cá nhân dùng cho xác thực 2 lớp (MFA) hoặc khôi phục tài khoản510. |
| **status** | VARCHAR(20) | NO | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING'))` | Trạng thái tài khoản trên toàn hệ thống10. |
| **is\_support\_staff** | BOOLEAN | NO | `FALSE` | | Đánh dấu nhân viên hỗ trợ của nhà cung cấp SaaS để kích hoạt tính năng **Impersonation** (giả mạo)611. |
| **mfa\_enabled** | BOOLEAN | NO | `FALSE` | | Trạng thái bật/tắt xác thực đa yếu tố12. |
| **is\_verified** | BOOLEAN | NO | `FALSE` | | Đánh dấu email đã được xác thực chính chủ hay chưa510. |
| **locale** | VARCHAR(10) | NO | `'vi-VN'` | | Ngôn ngữ và định dạng hiển thị ưa thích của người dùng5. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo tài khoản (UTC)1314. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật thông tin gần nhất1415. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | **Soft Delete**: Nếu khác NULL, tài khoản coi như đã bị xóa nhưng vẫn giữ dữ liệu cho mục đích đối soát (Audit)1415. |
\--------------------------------------------------------------------------------
Câu lệnh YSQL tạo bảng `users`
```
CREATE TABLE users (
-- I. ĐỊNH DANH (IDENTITY)
_id UUID PRIMARY KEY, -- Khuyến khích tạo UUID v7 từ tầng Application
email VARCHAR(255) NOT NULL,
password_hash TEXT, -- Lưu chuỗi hash Argon2id
full_name TEXT NOT NULL,
phone_number VARCHAR(20),
-- II. TRẠNG THÁI & BẢO MẬT (SECURITY)
status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
is_support_staff BOOLEAN NOT NULL DEFAULT FALSE,
mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE,
is_verified BOOLEAN NOT NULL DEFAULT FALSE,
-- III. CẤU HÌNH & THÔNG TIN THÊM (PREFERENCES)
locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN',
metadata JSONB DEFAULT '{}', -- Lưu các thông tin profile tùy biến khác
-- IV. TRUY VẾT (AUDIT)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
-- CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_users_email UNIQUE (email),
CONSTRAINT uq_users_phone UNIQUE (phone_number),
CONSTRAINT chk_users_email_fmt CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
CONSTRAINT chk_users_status CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING')),
CONSTRAINT chk_users_updated CHECK (updated_at >= created_at)
);
-- Index tìm kiếm nhanh theo email cho những user chưa bị xóa
CREATE UNIQUE INDEX idx_users_email_active ON users (email) WHERE deleted_at IS NULL;
```
Các phân tích trọng tâm áp dụng vào thiết kế:
• **Tách biệt Identity:** Bảng này chỉ lưu thông tin "con người thực". Các thông tin nghiệp vụ như chức vụ, lương tại từng công ty sẽ được lưu ở bảng `tenant_members`1....
• **Hỗ trợ Impersonation:** Trường `is_support_staff` cho phép kiểm soát quyền "giả mạo" người dùng khách hàng để hỗ trợ kỹ thuật một cách minh bạch, kết hợp với `audit_logs` để ghi lại `impersonator_id`1117.
• **Sẵn sàng cho MFA:** Thiết kế bao gồm `mfa_enabled` và `phone_number` để hỗ trợ các lớp bảo mật đa yếu tố (MFA) chuẩn NIST1218.
• **Hiệu năng YugabyteDB:** Việc sử dụng **UUID v7** làm khóa chính thay cho UUID v4 giúp dữ liệu được chèn vào theo thứ tự thời gian, tránh tình trạng phân tán ngẫu nhiên (Hotspot) và tối ưu hóa hiệu suất index trong hệ thống phân tán4....
**Sự ví von:** Bảng `users` giống như một chiếc **"Hộ chiếu quốc tế"**. Nó xác nhận bạn là ai trên toàn thế giới (hệ thống SaaS). Còn việc bạn đi làm ở công ty nào, giữ chức vụ gì, sẽ được ghi trong **"Hợp đồng lao động"** (`tenant_members`) tại quốc gia (Tenant) đó, nhưng tất cả đều phải dựa trên số hộ chiếu duy nhất này.
làm sao để cấu hình theo tenant cho phép người dùng đăng nhập bằng username, email, phone hoặc cccd hoặc 1 trường khác?
Để cấu hình hệ thống SaaS cho phép mỗi Tenant tùy chỉnh các trường đăng nhập (username, email, phone, CCCD...), bạn cần kết hợp giữa **cấu hình động (Tenant Configuration)** và **mô hình định danh linh hoạt (Linked Identities)**.
Dưới đây là giải pháp chi tiết dựa trên kiến trúc hệ thống đã phân tích:
1\. Lưu trữ cấu hình quy tắc đăng nhập theo Tenant
Bạn không nên "code cứng" các trường đăng nhập trong logic hệ thống. Thay vào đó, mỗi Tenant sẽ có một bộ quy tắc riêng được lưu tại:
• **Bảng** **tenants** **(YugabyteDB):** Sử dụng cột `settings` kiểu **JSONB** để lưu các chính sách bảo mật hoặc cấu hình vùng12.
• **Collection** **tenant\_app\_configs** **(MongoDB):** Đây là nơi lý tưởng nhất để lưu các cấu hình vận hành linh hoạt ("Làm như thế nào?") vì nó không yêu cầu schema cố định34.
**Ví dụ cấu hình trong** **tenant\_app\_configs****:**
```
{
"tenant_id": "uuid-fpt",
"auth_settings": {
"allowed_login_fields": ["email", "phone", "cccd"],
"mfa_enforced": true
}
}
```
2\. Mô hình lưu trữ danh tính linh hoạt (`user_linked_identities`)
Thay vì chỉ lưu một cột `email` duy nhất trong bảng `users`, bạn cần sử dụng bảng **user\_linked\_identities** để quản lý đa phương thức định danh5. Mỗi phương thức (email, phone, username, CCCD) sẽ là một bản ghi liên kết với `user_id` gốc56.
| Trường | Kiểu dữ liệu | Mô tả |
| --- | --- | --- |
| `user_id` | UUID | Link tới tài khoản người dùng gốc (`users`)5. |
| `provider` | VARCHAR | Loại định danh (VD: 'EMAIL', 'PHONE', 'USERNAME', 'CCCD')57. |
| `provider_id` | VARCHAR | Giá trị thực tế (VD: '001092000123', 'admin\_pro')6. |
**Lợi ích:** Cơ chế này cho phép một người dùng liên kết nhiều loại "chìa khóa" khác nhau vào cùng một tài khoản duy nhất58.
3\. Quy trình thực hiện đăng nhập
Khi người dùng thực hiện đăng nhập, hệ thống sẽ vận hành theo các bước sau:
1\. **Nhận diện Tenant:** Dựa vào Subdomain hoặc Slug trên URL (VD: `fpt.saas.com`), hệ thống xác định được `tenant_id` thông qua bảng `tenant_app_routes`910.
2\. **Tải cấu hình:** Hệ thống truy vấn `tenant_app_configs` để lấy danh sách các trường được phép đăng nhập (`allowed_login_fields`) của riêng Tenant đó411.
3\. **Kiểm tra và Truy vấn:**
◦ Hệ thống kiểm tra xem trường mà người dùng nhập vào có nằm trong danh sách được phép hay không. ◦ Thực hiện truy vấn bảng `user_linked_identities` với cặp giá trị `(provider, provider_id)` để tìm ra `user_id` tương ứng68.
4\. **Xác thực:** Sau khi tìm thấy `user_id`, hệ thống tiến hành kiểm tra mật khẩu hoặc yêu cầu MFA/Passkeys tùy theo cấu hình bảo mật của Tenant1213.
4\. Mở rộng với các trường tùy chỉnh (Custom Fields)
Nếu Tenant muốn đăng nhập bằng một trường đặc thù không có sẵn (VD: Mã số nhân viên riêng), bạn có thể sử dụng bảng **custom\_field\_definitions** để định nghĩa thêm trường động cho hồ sơ người dùng14. Dữ liệu thực tế của các trường này sẽ được lưu trong cột `custom_data` (JSONB) của bảng `tenant_members`15.
**Sự ví von để dễ hình dung:** Cấu hình này giống như việc một **tòa nhà chung cư** (Hệ thống SaaS) có nhiều **căn hộ** (Tenants). Chủ mỗi căn hộ có quyền quyết định khách vào nhà bằng cách **quẹt thẻ** (Email), **nhận diện khuôn mặt** (Biometric), hoặc **đọc mật khẩu** (Username). Ban quản lý tòa nhà cung cấp một **hộp giữ chìa khóa** (Bảng `user_linked_identities`) có thể chứa mọi loại thẻ hoặc mã số của cư dân, nhưng chỉ những loại chìa khóa nào chủ nhà cho phép thì mới có thể mở được cửa vào căn hộ đó.
liệt kê các bảng Identity layer
Dựa trên các nguồn dữ liệu, lớp **Identity & Access Management (IAM)** được coi là "xương sống" và "trái tim" của hệ thống SaaS "World-class"12. Lớp này chịu trách nhiệm quản lý định danh, cơ cấu tổ chức, phân quyền và bảo mật trên toàn hệ thống.
Dưới đây là danh sách các bảng thuộc lớp Identity layer được phân loại theo nhóm chức năng:
1\. Nhóm Định danh và Tổ chức Cốt lõi (Core Foundation)
Nhóm này quản lý danh tính con người và cấu trúc pháp nhân của khách hàng3...:
• **users**: Lưu trữ thông tin định danh toàn cục của một con người thực (Email, Password Hash, Avatar). Đây là bảng duy nhất chứa thông tin đăng nhập trên toàn sàn5....
• **tenants**: Lưu trữ thông tin định danh của tổ chức/khách hàng doanh nghiệp, bao gồm mã định danh (slug), vùng dữ liệu (`data_region`) và trạng thái hoạt động8....
• **tenant\_members**: Bảng quan trọng nhất liên kết người dùng với tổ chức. Nó lưu hồ sơ nhân viên, mã nhân viên, chức danh và trạng thái làm việc tại một công ty cụ thể11....
2\. Nhóm Cơ cấu và Nhóm (Organization & Structure)
Giúp phản ánh cấu trúc thực tế của doanh nghiệp14...:
• **departments**: Quản lý cây phòng ban theo phân cấp (Hierarchy) sử dụng phương pháp Materialized Path để truy vấn nhanh15....
• **department\_members**: Phân bổ nhân sự vào các phòng ban (quan hệ N-N)1920.
• **user\_groups**: Quản lý các nhóm làm việc ngang hàng, dự án hoặc squad. Có thể thiết lập nhóm tĩnh hoặc nhóm động (Dynamic Groups) theo quy tắc21....
• **group\_members**: Danh sách thành viên trong các nhóm tĩnh24....
• **locations**: Quản lý các địa điểm vật lý, văn phòng hoặc chi nhánh của Tenant2728.
3\. Nhóm Xác thực và Bảo mật (Authentication & Security)
Đáp ứng các tiêu chuẩn bảo mật hiện đại như MFA và Passwordless29...:
• **user\_linked\_identities**: Quản lý đa phương thức đăng nhập (Password, Google, GitHub, Microsoft) liên kết với một tài khoản người dùng32....
• **user\_sessions**: Quản lý phiên làm việc thực tế, thiết bị, IP và hỗ trợ cơ chế xoay vòng token (Rotation)35....
• **user\_mfa\_methods**: Lưu trữ các phương thức xác thực đa yếu tố (TOTP, SMS, Email)3839.
• **user\_webauthn\_credentials**: Hỗ trợ đăng nhập bằng vân tay, FaceID hoặc khóa vật lý (Passkeys/FIDO2)4041.
• **user\_backup\_codes**: Mã khôi phục khi người dùng mất thiết bị MFA3942.
• **tenant\_sso\_configs**: Cấu hình đăng nhập doanh nghiệp (SAML/OIDC) để tích hợp với Azure AD, Okta10....
• **auth\_verification\_codes**: Mã OTP hoặc Magic Link ngắn hạn để xác thực email hoặc đổi mật khẩu4145.
• **personal\_access\_tokens**: Token dành cho lập trình viên hoặc scripts tích hợp hệ thống34....
4\. Nhóm Phân quyền (Authorization - IAM)
Kiểm soát quyền truy cập từ mức tính năng đến mức dữ liệu16...:
• **roles**: Định nghĩa các vai trò (VD: Admin, Editor) và danh sách mã quyền đi kèm30....
• **permissions**: Danh mục các hành động kỹ thuật do lập trình viên định nghĩa cứng trong code30....
• **user\_roles**: Gán vai trò cho thành viên, hỗ trợ phạm vi dữ liệu (`scope_values`) như theo phòng ban hoặc khu vực51....
• **relationship\_tuples**: Mô hình phân quyền dựa trên quan hệ (ReBAC - Google Zanzibar) cho các kịch bản chia sẻ tài nguyên phức tạp49....
• **access\_control\_lists** **(ACL)**: Kiểm soát truy cập chi tiết cho từng tài nguyên cụ thể (VD: Folder, Document)30....
5\. Nhóm Quản trị và Tuân thủ (Governance & Compliance)
Đáp ứng các yêu cầu của khách hàng Enterprise lớn16...:
• **tenant\_domains**: Xác thực tên miền sở hữu (VD: @fpt.com) để tự động quản lý thành viên và thực thi SSO36....
• **tenant\_invitations**: Quản lý quy trình mời và gia nhập của người dùng mới24....
• **access\_reviews** **&** **access\_review\_items**: Quản lý các đợt rà soát quyền hạn định kỳ theo chuẩn ISO/SOC258....
• **scim\_directories** **&** **scim\_mappings**: Tự động hóa việc đồng bộ hóa người dùng từ các hệ thống IdP bên ngoài như Azure AD49....
• **tenant\_security\_policies**: Quy định chính sách mật khẩu, thời hạn session và MFA bắt buộc cho từng Tenant48....
• **legal\_documents** **&** **user\_consents**: Lưu trữ các điều khoản sử dụng và bằng chứng chấp thuận của người dùng36....
• **user\_delegations**: Cho phép ủy quyền hành động (Impersonation) có thời hạn và có kiểm soát49....
**Lưu ý kỹ thuật:** Tất cả các bảng này thường được lưu trữ trong **YugabyteDB (Distributed SQL)** để đảm bảo tính nhất quán dữ liệu tuyệt đối (ACID) và khả năng mở rộng toàn cầu1....
thiết kế chi tiết bảng tenant\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng
Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật từ các nguồn dữ liệu (đặc biệt là việc tách biệt danh tính toàn cầu và hồ sơ thành viên), dưới đây là thiết kế chi tiết bảng **tenant\_members** cho YugabyteDB (YSQL).
Bảng này đóng vai trò là "nút thắt" liên kết một con người (`users`) vào một tổ chức (`tenants`), cho phép một người có thể tham gia nhiều công ty với các chức danh và quyền hạn khác nhau1....
1\. Thiết kế chi tiết bảng `tenant_members` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tối ưu sắp xếp và chèn dữ liệu45. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id)` | Xác định thành viên thuộc tổ chức nào. Là Sharding Key quan trọng67. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id)` | Liên kết với danh tính người dùng toàn cục89. |
| **display\_name** | VARCHAR(255) | YES | | | Tên hiển thị riêng trong tổ chức (VD: "Anh An IT")1011. |
| **status** | VARCHAR(20) | NO | `'INVITED'` | `CHECK (status IN ('INVITED', 'ACTIVE', 'SUSPENDED', 'RESIGNED'))` | Trạng thái hoạt động của thành viên trong tổ chức này1011. |
| **custom\_data** | JSONB | NO | `'{}'` | | Lưu trữ linh hoạt các trường động (Mã NV, chức danh, size áo...)1112. |
| **joined\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm chính thức gia nhập tổ chức1011. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi hồ sơ613. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật hồ sơ gần nhất1314. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | **Soft Delete**. Thời điểm xóa thành viên khỏi tổ chức1415. |
| **created\_by** | UUID | YES | | | ID người thực hiện tạo hồ sơ (Admin/System)1314. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Chống ghi đè dữ liệu khi nhiều Admin cùng sửa1516. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng `tenant_members`
```
CREATE TABLE tenant_members (
-- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINK)
_id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ Application
tenant_id UUID NOT NULL,
user_id UUID NOT NULL,
-- II. THÔNG TIN VẬN HÀNH (OPERATIONAL)
display_name VARCHAR(255),
status VARCHAR(20) NOT NULL DEFAULT 'INVITED',
custom_data JSONB NOT NULL DEFAULT '{}',
joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
created_by UUID,
version BIGINT NOT NULL DEFAULT 1,
-- IV. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_mem_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
-- Đảm bảo một User chỉ có duy nhất 1 hồ sơ tại 1 Tenant (không trùng lặp)
CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id),
CONSTRAINT chk_mem_status CHECK (status IN ('INVITED', 'ACTIVE', 'SUSPENDED', 'RESIGNED')),
CONSTRAINT chk_mem_updated CHECK (updated_at >= created_at)
);
-- Index quan trọng để truy vấn danh sách thành viên của một Tenant nhanh hơn
CREATE INDEX idx_mem_tenant ON tenant_members (tenant_id) WHERE deleted_at IS NULL;
-- GIN Index để tìm kiếm trong custom_data (Ví dụ: tìm theo mã nhân viên lưu trong JSON)
CREATE INDEX idx_mem_custom_data ON tenant_members USING GIN (custom_data);
```
Các phân tích trọng tâm áp dụng vào thiết kế:
• **Mô hình "Switch Workspace":** Bằng cách tách `users` (danh tính) và `tenant_members` (hồ sơ), hệ thống cho phép một người dùng đăng nhập một lần nhưng có thể làm việc tại nhiều công ty khác nhau mà không bị lẫn lộn dữ liệu317.
• **SaaS Core tinh gọn:** Thiết kế này loại bỏ các trường nghiệp vụ nặng (lương, hợp đồng) để giữ cho Core ổn định. Các ứng dụng như HRM có thể mở rộng dữ liệu thông qua trường `custom_data` hoặc tạo bảng riêng liên kết 1-1 với `tenant_members` \[\_id\]10....
• **Hiệu năng phân tán:** Sử dụng UUID v7 và đánh Index vào `tenant_id` giúp YugabyteDB phân tán dữ liệu đồng đều và truy vấn nhanh chóng khi hệ thống mở rộng lên hàng triệu người dùng5....
• **Tính toàn vẹn:** Ràng buộc `UNIQUE(tenant_id, user_id)` ngăn chặn việc một người bị thêm hai lần vào cùng một tổ chức, gây sai lệch báo cáo722.
**Sự ví von:** Nếu `users` là một **Hộ chiếu** quốc tế, thì `tenant_members` chính là **Thẻ nhân viên** của từng công ty. Bạn có thể có nhiều thẻ nhân viên khác nhau, nhưng tất cả đều phải quy chiếu về một số hộ chiếu duy nhất của bạn822.
thiết kế chi tiết bảng departments dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng
Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và phân tích về cấu trúc tổ chức (Organizational Units) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **departments** (Phòng ban) sử dụng YugabyteDB (YSQL).
Bảng này đóng vai trò quản lý cấu trúc cây (Hierarchy) của doanh nghiệp, cho phép truy vấn nhanh các cấp bậc tổ chức thông qua phương pháp **Materialized Path**1,2,3.
Thiết kế chi tiết bảng `departments` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7). Tối ưu hóa việc sắp xếp theo thời gian và tránh Hotspot4,5. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id)` | Xác định phòng ban thuộc tổ chức nào (Sharding Key quan trọng)6,7. |
| **parent\_id** | UUID | YES | `NULL` | `REFERENCES departments(_id)` | ID của phòng ban cha. Dùng để xây dựng quan hệ phân cấp1,2. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên phòng ban (VD: Khối Công nghệ, Phòng Nhân sự)2. |
| **code** | VARCHAR(50) | YES | `NULL` | | Mã phòng ban dùng để đồng bộ với hệ thống ERP bên ngoài2. |
| **type** | VARCHAR(20) | NO | `'TEAM'` | `CHECK (type IN ('DIVISION', 'DEPARTMENT', 'TEAM'))` | Phân loại cấp độ tổ chức2,3. |
| **head\_member\_id** | UUID | YES | `NULL` | `REFERENCES tenant_members(_id)` | Trưởng phòng (Administrative Head). Link tới hồ sơ thành viên2,3. |
| **path** | TEXT | YES | | | **Materialized Path** (VD: `/root/dept_a/team_b/`). Giúp truy vấn toàn bộ cây con cực nhanh2,8. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC)9,8. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng9,8. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | **Soft Delete**. Nếu khác NULL, phòng ban coi như đã bị giải thể9,10. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Ngăn chặn việc cập nhật dữ liệu đồng thời bị xung đột11,12. |
\--------------------------------------------------------------------------------
Câu lệnh YSQL tạo bảng `departments`
Câu lệnh này bao gồm cả các chỉ mục (Indexes) chiến lược để tối ưu hóa việc truy vấn cây thư mục phòng ban trong môi trường đa tenant8,3.
```
CREATE TABLE departments (
-- I. ĐỊNH DANH & PHÂN CẤP (IDENTITY & HIERARCHY)
_id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ Application
tenant_id UUID NOT NULL,
parent_id UUID,
-- II. THÔNG TIN NGHIỆP VỤ (BUSINESS DATA)
name TEXT NOT NULL,
code VARCHAR(50),
type VARCHAR(20) NOT NULL DEFAULT 'TEAM',
head_member_id UUID,
path TEXT, -- Cấu trúc: /parent_id/child_id/
-- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
version BIGINT NOT NULL DEFAULT 1,
-- RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_dept_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_dept_parent FOREIGN KEY (parent_id) REFERENCES departments(_id),
CONSTRAINT chk_dept_status CHECK (type IN ('DIVISION', 'DEPARTMENT', 'TEAM')),
CONSTRAINT chk_dept_updated CHECK (updated_at >= created_at)
);
-- Index để tìm tất cả phòng ban con cực nhanh bằng toán tử LIKE hoặc mẫu text [8], [3]
CREATE INDEX idx_dept_path ON departments (tenant_id, path text_pattern_ops) WHERE deleted_at IS NULL;
-- Index hỗ trợ tìm kiếm phòng ban theo Tenant (SaaS isolation) [6], [13]
CREATE INDEX idx_dept_tenant ON departments (tenant_id) WHERE deleted_at IS NULL;
```
Điểm nhấn kỹ thuật theo nguồn dữ liệu:
• **UUID v7 làm Khóa chính:** Đảm bảo tính duy nhất toàn cầu nhưng vẫn giữ được thứ tự thời gian chèn, giúp tránh hiện tượng "Hotspot" trong hệ thống phân tán YugabyteDB4,5,12.
• **Materialized Path (****path****):** Thay vì sử dụng đệ quy (Recursive CTE) tốn kém, cột `path` cho phép lấy toàn bộ danh sách phòng ban con của "Khối Công nghệ" chỉ bằng một lệnh: `WHERE path LIKE '/khoi-cn-uuid/%'`2,8.
• **Phân tách Core và App:** Bảng này chỉ lưu cấu trúc tổ chức lõi. Các thông tin đặc thù khác (như ngân sách phòng ban) nên được lưu ở các module nghiệp vụ liên kết thông qua `_id` của bảng này13,14.
\--------------------------------------------------------------------------------
**Sự ví von để dễ hiểu:** Bảng `departments` giống như một **sơ đồ mặt bằng** của một tòa nhà cao tầng. `_id` là mã số của mỗi phòng, `parent_id` cho biết phòng đó nằm trong khu vực lớn nào, và `path` giống như **số nhà đầy đủ** (VD: Tòa A/Tầng 10/Phòng 1001) giúp bất kỳ ai cũng có thể tìm thấy mọi phòng nhỏ bên trong một khu vực lớn chỉ bằng một cái nhìn lướt qua sơ đồ2,8.
bảng users và tenants có cần index gì không?
Trong hệ thống SaaS đa tenant trên YugabyteDB (YSQL), việc thiết kế các chỉ mục (index) cho bảng `users` và `tenants` là **cực kỳ quan trọng** để tối ưu hóa hiệu suất truy vấn, đặc biệt là khi dữ liệu được phân tán trên nhiều node12.
Dưới đây là các chỉ mục chiến lược cần thiết cho hai bảng này dựa trên các kịch bản truy cập phổ biến:
1\. Chỉ mục cho bảng `tenants` (Tổ chức)
Các chỉ mục này tập trung vào việc định tuyến (routing) và quản lý trạng thái khách hàng:
• **idx\_tenants\_code** **(Unique Index):** Đánh trên cột `code` (slug/subdomain) kèm điều kiện `WHERE deleted_at IS NULL`34. Đây là chỉ mục quan trọng nhất để API Gateway hoặc Router tìm kiếm Tenant ID ngay khi người dùng truy cập qua URL (ví dụ: `fpt.saas.com`)56.
• **idx\_tenants\_active\_apps** **(GIN Index):** Đánh trên cột mảng `active_apps`47. Chỉ mục này giúp hệ thống nhanh chóng tìm ra tất cả các khách hàng đang sử dụng một ứng dụng cụ thể (ví dụ: HRM) khi cần cập nhật tính năng hoặc triển khai phiên bản mới56.
• **idx\_tenants\_owner****:** Đánh trên cột `owner_id` để hiển thị danh sách các công ty mà một User đang sở hữu trên trang Dashboard quản trị3....
• **idx\_tenants\_status\_tier****:** Chỉ mục ghép trên `status` và `tier` (hoặc `current_tier_code`) giúp đội ngũ Sales hoặc Admin lọc nhanh danh sách khách hàng theo phân cấp (VIP, Pro) hoặc trạng thái hoạt động5....
• **idx\_tenants\_region****:** Đánh trên `data_region` để phục vụ công tác thống kê hạ tầng và phân bổ dữ liệu theo khu vực địa lý46.
2\. Chỉ mục cho bảng `users` (Người dùng)
Các chỉ mục này ưu tiên cho việc xác thực và tìm kiếm danh tính:
• **idx\_users\_email\_active** **(Unique Index):** Đánh trên cột `email` kèm điều kiện `WHERE deleted_at IS NULL`10. Đây là chỉ mục "sống còn" để thực hiện đăng nhập bằng email và đảm bảo không có hai người dùng hoạt động nào trùng email trên toàn hệ thống10.
• **idx\_users\_search\_trgm** **(GIN Trigram Index):** Sử dụng trên một cột vector tìm kiếm (bao gồm tên, email, số điện thoại) để hỗ trợ tìm kiếm người dùng theo kiểu "gõ sai vẫn ra" hoặc tìm kiếm mờ (fuzzy search) cực nhanh1112.
• **idx\_identity\_lookup****:** Trong mô hình đa phương thức đăng nhập, chỉ mục này được đánh trên bảng liên kết (`user_linked_identities`) cho cặp `(provider, provider_id)` để tìm nhanh User ID khi họ đăng nhập qua Google, GitHub hoặc SSO1314.
• **idx\_sessions\_user****:** Đánh trên bảng `user_sessions` (`user_id`) để người dùng có thể quản lý và thu hồi (logout) các thiết bị đang đăng nhập một cách nhanh chóng15.
Lưu ý quan trọng về Hiệu năng
• **Sử dụng UUID v7 làm Khóa chính:** Việc dùng UUID v7 cho `_id` giúp các bản ghi mới được chèn vào theo thứ tự thời gian, tránh tình trạng "Hotspot" (nghẽn cổ chai) trong database phân tán và tối ưu hóa hiệu suất index mặc định của Primary Key17.
• **Tránh Index các cột URL/Text quá dài:** Các nguồn tài liệu khuyên **không nên** đánh index trực tiếp trên các cột chứa URL ảnh hoặc mô tả dài vì sẽ làm chậm thao tác chèn (insert); thay vào đó hãy index trên một cột hash (MD5/SHA256) nếu thực sự cần tìm kiếm16.
**Ví von để dễ hiểu:** Các chỉ mục này giống như **bản chỉ dẫn ở sảnh tòa nhà**. Thay vì nhân viên bảo vệ phải đi gõ cửa từng phòng (`Full Table Scan`) để tìm một công ty hay một người, họ chỉ cần nhìn vào bảng chỉ dẫn (`Index`) để biết ngay vị trí chính xác, giúp khách hàng ra vào tòa nhà nhanh chóng và không gây ùn tắc ở cửa ra vào.
viết lệnh ysql để tạo index cho tenants và users
Dựa trên các tiêu chuẩn thiết kế hệ thống SaaS đa tenant và các đặc thù của YugabyteDB (YSQL), việc tạo Index không chỉ giúp tăng tốc truy vấn mà còn hỗ trợ định tuyến (routing) và bảo mật dữ liệu12.
Dưới đây là các câu lệnh YSQL để tạo Index chiến lược cho hai bảng **tenants** và **users**:
1\. Chỉ mục cho bảng `tenants` (Tổ chức)
Các chỉ mục này tập trung vào việc định danh khách hàng trên URL và quản lý trạng thái gói cước34.
• **Index định tuyến Subdomain:** Đảm bảo tìm kiếm Tenant cực nhanh khi người dùng truy cập qua URL (ví dụ: `fpt.saas.com`) và hỗ trợ xóa mềm (Soft Delete)12.
• **GIN Index cho mảng ứng dụng:** Hỗ trợ truy vấn nhanh danh sách khách hàng đang sử dụng một ứng dụng cụ thể (ví dụ: HRM, CRM)25.
• **Index cho chủ sở hữu (Owner):** Giúp hiển thị danh sách các công ty mà một người dùng đang quản lý trên Dashboard16.
• **Index quản trị:** Hỗ trợ Admin hệ thống lọc khách hàng theo trạng thái hoạt động và cấp độ gói cước56.
• **Index vùng dữ liệu:** Thống kê hạ tầng và số lượng khách hàng theo khu vực địa lý27.
2\. Chỉ mục cho bảng `users` (Người dùng)
Các chỉ mục này ưu tiên tối ưu hóa luồng đăng nhập và tìm kiếm danh tính89.
• **Index đăng nhập an toàn:** Đảm bảo Email là duy nhất đối với các tài khoản đang hoạt động và tăng tốc độ xác thực810.
• **GIN Trigram Index cho tìm kiếm mờ:** Hỗ trợ tìm kiếm người dùng theo tên hoặc email ngay cả khi gõ thiếu hoặc sai chính tả nhẹ911. _(Lưu ý: Cần kích hoạt extension_ _pg\_trgm_ _trước khi sử dụng)_
3\. Chỉ mục bổ trợ liên quan (Xác thực & Định danh)
Để hệ thống IAM (Identity and Access Management) hoạt động mượt mà, các bảng liên kết cũng cần được đánh Index1213.
• **Tra cứu định danh liên kết (Social Login):** Tìm nhanh User ID khi đăng nhập qua Google, GitHub hoặc SSO1214.
• **Tra cứu quan hệ (ReBAC):** Dành cho mô hình phân quyền dựa trên quan hệ như Google Zanzibar1315.
**Lời khuyên từ các nguồn dữ liệu:** Việc sử dụng **UUID v7** cho các trường `_id` giúp các chỉ mục này được sắp xếp theo thời gian, tránh tình trạng nghẽn cổ chai (Hotspot) trong database phân tán như YugabyteDB1617.
**Ví von để dễ hiểu:** Các chỉ mục này giống như **mục lục của một cuốn sách khổng lồ**. Thay vì phải lật từng trang (Full Table Scan) để tìm một thông tin, bạn chỉ cần xem mục lục để biết chính xác trang cần đọc, giúp hệ thống phản hồi nhanh chóng ngay cả khi dữ liệu phình to lên hàng triệu bản ghi.
viết câu lệnh ysql mà?
Dưới đây là các câu lệnh **YSQL** (YugabyteDB) để khởi tạo bảng `users` hoàn chỉnh, bao gồm các ràng buộc (constraints) và các chỉ mục (indexes) chiến lược giúp tối ưu hóa hiệu năng cho hệ thống SaaS quy mô lớn.
1\. Câu lệnh YSQL tạo bảng `users`
Câu lệnh này tích hợp đầy đủ các cột từ bản thiết kế trước đó, tuân thủ các quy tắc về kiểu dữ liệu (như `TEXT` cho password hash và `TIMESTAMPTZ` cho thời gian)1,2.
```
CREATE TABLE users (
-- I. ĐỊNH DANH (IDENTITY)
_id UUID PRIMARY KEY, -- Sử dụng UUID v7 (tạo từ ứng dụng) để tối ưu sharding và sắp xếp [3], [4]
email VARCHAR(255) NOT NULL, -- Email đăng nhập chính
password_hash TEXT, -- Chuỗi băm Argon2id/Bcrypt, để NULL nếu dùng SSO [5], [6]
full_name TEXT NOT NULL, -- Tên hiển thị mặc định
avatar_url TEXT, -- Hỗ trợ URL dài (Presigned URL) [7]
phone_number VARCHAR(20), -- Số điện thoại để xác thực/MFA [2]
-- II. TRẠNG THÁI & BẢO MẬT (SECURITY & STATUS)
status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, BANNED, PENDING [2]
is_support_staff BOOLEAN NOT NULL DEFAULT FALSE, -- Phục vụ tính năng Impersonation [8]
is_verified BOOLEAN NOT NULL DEFAULT FALSE, -- Xác thực email [2]
mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE, -- Trạng thái bật MFA
mfa_secret TEXT, -- Secret key cho TOTP (nên mã hóa) [2]
-- III. CẤU HÌNH & DỮ LIỆU ĐỘNG (PREFERENCES)
locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN', -- Ngôn ngữ/định dạng [2]
metadata JSONB NOT NULL DEFAULT '{}', -- Lưu thông tin tùy chỉnh linh hoạt [9]
-- IV. TRUY VẾT (AUDIT)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ, -- Phục vụ xóa mềm (Soft Delete) [10]
version BIGINT NOT NULL DEFAULT 1, -- Chống ghi đè đồng thời (Optimistic Locking) [11]
-- V. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_users_phone UNIQUE (phone_number),
CONSTRAINT chk_users_email_fmt CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
CONSTRAINT chk_users_status CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING')),
CONSTRAINT chk_users_updated CHECK (updated_at >= created_at)
);
```
2\. Các chỉ mục (Indexes) quan trọng
Theo các nguồn dữ liệu, việc đánh chỉ mục đúng cách là "vũ khí" để hệ thống phản hồi dưới 1ms3,4.
• **Chỉ mục duy nhất cho Email (Hỗ trợ Soft Delete):** Đảm bảo email là duy nhất trên toàn hệ thống nhưng không bị xung đột với các tài khoản đã bị xóa5.
• **Chỉ mục tìm kiếm mờ (Fuzzy Search):** Cho phép tìm kiếm người dùng theo tên hoặc email nhanh chóng ngay cả khi gõ thiếu dấu hoặc sai chính tả6,7.
• **Chỉ mục hỗ trợ quản trị:** Giúp Admin lọc danh sách người dùng theo trạng thái nhanh hơn.
Giải thích các lựa chọn kỹ thuật:
• **UUID v7:** Được ưu tiên làm khóa chính vì tính chất sắp xếp theo thời gian (time-sortable), giúp các node trong cụm YugabyteDB không bị hiện tượng "hotspot" khi chèn dữ liệu mới8,9.
• **Kiểu dữ liệu TEXT:** Sử dụng cho `password_hash` và `avatar_url` thay vì `VARCHAR(255)` để tránh giới hạn ký tự khi thay đổi thuật toán băm (như Argon2id thường dài hơn Bcrypt) hoặc khi dùng các URL có chữ ký bảo mật dài10,11.
• **JSONB:** Trường `metadata` cho phép lưu trữ các thuộc tính linh hoạt như "Size áo", "Biển số xe" mà không cần phải thay đổi cấu trúc bảng (ALTER TABLE)12,13.
• **Soft Delete (****deleted\_at****):** Giúp tuân thủ các quy định về lưu vết và phục hồi dữ liệu khi người dùng lỡ tay xóa tài khoản5.
viết các lệnh CREATE INDEX ấy
Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và các Access Pattern (mô hình truy cập) đã phân tích trong các nguồn dữ liệu, dưới đây là tổng hợp các lệnh **CREATE INDEX** chiến lược trong YugabyteDB (YSQL).
Các chỉ mục này được thiết kế để tối ưu hóa hiệu suất truy vấn phân tán, hỗ trợ **Soft Delete** và đảm bảo tốc độ phản hồi tính bằng mili giây cho hàng triệu người dùng1....
1\. Chỉ mục cho bảng `tenants` (Tổ chức)
Nhóm này tập trung vào việc định tuyến (Routing) khách hàng từ URL và quản trị hệ thống.
• **Index định tuyến Subdomain (Quan trọng nhất):** Đảm bảo tìm nhanh Tenant ID từ slug trên URL. Sử dụng **Partial Index** để chỉ quét các Tenant chưa bị xóa34.
• **GIN Index cho mảng ứng dụng:** Hỗ trợ truy vấn: "Tìm tất cả tenant đang sử dụng app HRM" để phục vụ việc deploy hoặc bật tính năng mới3....
• **Index cho chủ sở hữu (Owner):** Hiển thị danh sách các công ty mà một User đang sở hữu trên Dashboard quản trị4....
• **Index quản trị & thống kê:** Hỗ trợ lọc khách hàng theo vùng dữ liệu, trạng thái và cấp độ gói cước2....
2\. Chỉ mục cho bảng `users` (Người dùng)
Nhóm này ưu tiên cho việc xác thực (Authentication) và tìm kiếm danh tính.
• **Index đăng nhập duy nhất:** Đảm bảo email không trùng lặp và truy vấn đăng nhập cực nhanh910.
• **GIN Trigram Index cho tìm kiếm mờ:** Hỗ trợ tìm kiếm người dùng theo tên hoặc email ngay cả khi gõ thiếu hoặc sai chính tả nhẹ1112.
3\. Chỉ mục cho bảng `tenant_app_routes` (Định tuyến Domain/Path)
Đây là bảng có tần suất đọc cực cao mỗi khi có request bay vào hệ thống1314.
• **Covering Index "thần thánh":** Chứa cả `tenant_id` và `app_code` ngay trong Index để database trả về kết quả mà không cần đọc bảng gốc (**Index Only Scan**)1516.
4\. Chỉ mục cho các bảng Core khác
• **Phân cấp phòng ban (****departments****):** Sử dụng B-Tree Index trên cột `path` để lấy toàn bộ cây con cực nhanh1718.
• **Phân quyền dựa trên quan hệ (****relationship\_tuples****):** Index đảo ngược để trả lời câu hỏi: "User A được quyền xem những tài liệu nào?"19.
• **Dữ liệu tùy chỉnh (****tenant\_members****):** GIN Index trên cột JSONB `custom_data` để tìm kiếm theo các trường động như mã nhân viên, size áo20.
• **Đảm bảo nhất quán (****outbox\_events****):** Giúp Worker quét nhanh các sự kiện chưa được bắn sang Kafka21.
Lưu ý kỹ thuật quan trọng:
1\. **UUID v7:** Việc sử dụng UUID v7 cho các cột ID làm khóa chính giúp các chỉ mục này được **sắp xếp theo thời gian (Time-sortable)**, tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi chèn dữ liệu đồng thời trong hệ thống phân tán YugabyteDB22....
2\. **Geo-Partitioning:** Nếu hệ thống của bạn yêu cầu dữ liệu khách hàng phải nằm tại vùng địa lý cụ thể (VD: VN, EU), các Index nên bao gồm cột `data_region` trong thành phần khóa để định tuyến query chính xác tới Node vật lý tại vùng đó25....
viết các lệnh CREATE INDEX để tạo index cho bảng tenants
Dựa trên các phân tích chuyên sâu về hệ thống SaaS đa tenant trong các nguồn dữ liệu, việc tạo index cho bảng **tenants** trên YugabyteDB (YSQL) không chỉ nhằm tăng tốc truy vấn mà còn để tối ưu hóa khả năng định tuyến (routing), quản trị hạ tầng và phân tán dữ liệu1,2,3.
Dưới đây là các câu lệnh **CREATE INDEX** chiến lược cho bảng `tenants`:
1\. Chỉ mục định tuyến Subdomain (Quan trọng nhất)
Đây là chỉ mục giúp hệ thống xác định nhanh chóng định danh của khách hàng thông qua mã slug hoặc subdomain khi người dùng truy cập vào ứng dụng1,4.
```
CREATE UNIQUE INDEX idx_tenants_code
ON tenants (code)
WHERE deleted_at IS NULL;
```
• **Mục đích:** Hỗ trợ đăng nhập và định tuyến URL (ví dụ: `fpt.saas.com`)5,6. Việc sử dụng **Partial Index** (`WHERE deleted_at IS NULL`) giúp loại bỏ các bản ghi đã xóa khỏi chỉ mục, làm giảm dung lượng và tăng hiệu năng truy vấn4.
2\. Chỉ mục quản trị chủ sở hữu (Owner Dashboard)
Dùng để hiển thị danh sách các tổ chức/công ty mà một người dùng cụ thể đang quản lý5,7.
```
CREATE INDEX idx_tenants_owner
ON tenants (owner_id)
WHERE deleted_at IS NULL;
```
• **Mục đích:** Phục vụ trang Dashboard cá nhân của người dùng để họ có thể chuyển đổi nhanh giữa các workspace (công ty)1,5.
3\. Chỉ mục GIN cho mảng ứng dụng (active\_apps)
Khi sử dụng kiểu dữ liệu mảng để lưu danh sách ứng dụng mà tenant được quyền sử dụng, chỉ mục GIN là bắt buộc để tìm kiếm hiệu quả2,4.
```
CREATE INDEX idx_tenants_active_apps
ON tenants USING GIN (active_apps);
```
• **Mục đích:** Hỗ trợ các tác vụ quản trị như tìm tất cả các tenant đang sử dụng một ứng dụng cụ thể (ví dụ: 'HRM') để nâng cấp tính năng hoặc triển khai phiên bản mới5,6.
4\. Chỉ mục phân cấp gói cước và trạng thái
Hỗ trợ đội ngũ vận hành và marketing trong việc lọc danh sách khách hàng theo tình trạng kinh doanh2,5.
```
CREATE INDEX idx_tenants_status_tier
ON tenants (status, current_tier_code);
```
• **Mục đích:** Giúp Admin hệ thống lọc nhanh các khách hàng VIP hoặc các khách hàng đang ở trạng thái dùng thử (TRIAL)5,7.
5\. Chỉ mục theo vùng dữ liệu (Data Residency)
Đối với hệ thống SaaS toàn cầu, việc theo dõi khách hàng theo khu vực địa lý là yếu tố then chốt để tuân thủ pháp lý và quản trị hạ tầng6,4.
```
CREATE INDEX idx_tenants_region
ON tenants (data_region);
```
• **Mục đích:** Giúp hệ thống thống kê số lượng khách hàng theo từng vùng (ví dụ: `ap-southeast-1`, `us-east-1`) và hỗ trợ chiến lược phân mảnh dữ liệu theo địa lý (Geo-Partitioning)6,8.
6\. Chỉ mục cho dữ liệu tùy chỉnh (Profile Metadata)
Nếu bạn gom các thông tin mô tả, logo, website vào cột JSONB để tăng tính linh hoạt, bạn có thể tạo chỉ mục GIN trên cột này9.
```
CREATE INDEX idx_tenants_profile
ON tenants USING GIN (profile);
```
• **Mục đích:** Cho phép tìm kiếm nhanh các thông tin nằm sâu bên trong cấu hình JSON như mã số thuế hoặc các thuộc tính tùy biến khác9.
\--------------------------------------------------------------------------------
**Lưu ý kỹ thuật:**
• **Thứ tự ưu tiên:** Index trên cột `code` là quan trọng nhất vì nó được gọi mỗi khi có request bay vào hệ thống để xác định tenant10.
• **Hiệu năng Sharding:** Theo các nguồn dữ liệu, việc sử dụng **UUID v7** cho khóa chính `_id` giúp dữ liệu được phân tán đều trên các node và tối ưu hóa thứ tự sắp xếp theo thời gian cho các chỉ mục11,12.
• **Bảo mật:** Với các hệ thống yêu cầu bảo mật cao, các chỉ mục cần kết hợp với các chính sách che giấu dữ liệu (Data Masking) để bảo vệ thông tin nhạy cảm của khách hàng13.
Để dễ hình dung, hãy coi các chỉ mục này như **hệ thống phân loại trong một thư viện khổng lồ**. Thay vì thủ thư phải đi kiểm tra từng cuốn sách trên kệ (**Full Table Scan**), các bản chỉ dẫn này cho biết chính xác cuốn sách (dữ liệu tenant) nằm ở khu vực nào, giúp việc tìm kiếm diễn ra gần như tức thì ngay cả khi thư viện có hàng triệu cuốn sách.
viết các lệnh CREATE INDEX để tạo index cho bảng users
Dựa trên các phân tích về hệ thống SaaS "World-class" và các yêu cầu về hiệu năng trong YugabyteDB (YSQL), việc tạo Index cho bảng `users` cần tập trung vào tối ưu hóa xác thực, tìm kiếm danh tính và quản trị12.
Dưới đây là các câu lệnh **CREATE INDEX** chiến lược cho bảng `users`:
1\. Index duy nhất cho Email (Hỗ trợ Soft Delete)
Đây là chỉ mục quan trọng nhất để phục vụ quá trình đăng nhập. Sử dụng **Partial Index** để đảm bảo email là duy nhất trên toàn hệ thống nhưng không bị xung đột với các tài khoản đã bị xóa mềm23.
```
CREATE UNIQUE INDEX idx_users_email_active
ON users (email)
WHERE deleted_at IS NULL;
```
2\. Index tìm kiếm mờ (Fuzzy Search)
Để hỗ trợ quản trị viên tìm kiếm người dùng theo tên hoặc email nhanh chóng ngay cả khi gõ thiếu hoặc sai chính tả nhẹ, chúng ta sử dụng **GIN Trigram Index**45.
```
-- Cần kích hoạt extension trước khi tạo index
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX idx_users_search_trgm
ON users USING GIN (full_name gin_trgm_ops, email gin_trgm_ops);
```
3\. Index duy nhất cho Số điện thoại
Tương tự như email, số điện thoại cần được index để phục vụ xác thực đa yếu tố (MFA) hoặc đăng nhập bằng điện thoại67.
```
CREATE UNIQUE INDEX idx_users_phone_active
ON users (phone_number)
WHERE phone_number IS NOT NULL AND deleted_at IS NULL;
```
4\. Index quản trị và trạng thái
Hỗ trợ các truy vấn lọc danh sách người dùng theo trạng thái (Active, Banned, Pending) và sắp xếp theo thời gian tạo (sử dụng lợi thế của UUID v7)68.
```
CREATE INDEX idx_users_status_created
ON users (status, created_at DESC);
```
5\. Index liên kết danh tính (Social Login)
Mặc dù index này nằm trên bảng liên kết `user_linked_identities`, nhưng nó là "chìa khóa" để tìm nhanh `user_id` khi người dùng đăng nhập qua Google, GitHub hoặc SSO910.
```
CREATE INDEX idx_identity_lookup
ON user_linked_identities (provider, provider_id);
```
6\. Index quản lý phiên làm việc (Security Audit)
Sử dụng trên bảng `user_sessions` để giúp người dùng hoặc quản trị viên truy vấn nhanh các phiên làm việc đang hoạt động và thu hồi thiết bị khi cần thiết1112.
```
CREATE INDEX idx_sessions_user_active
ON user_sessions (user_id)
WHERE is_revoked = FALSE;
```
Tại sao các chỉ mục này tối ưu?
• **UUID v7:** Do `_id` được tạo theo UUID v7 (sắp xếp theo thời gian), các chỉ mục trên sẽ không bị hiện tượng "Hotspot" khi chèn dữ liệu mới, giúp phân tán dữ liệu đồng đều trên các node của YugabyteDB1314.
• **Partial Index:** Giúp giảm dung lượng Index và tăng tốc độ ghi do không phải chứa dữ liệu của những người dùng đã bị xóa215.
• **GIN Index:** Cho phép tìm kiếm văn bản hiệu quả hơn nhiều so với toán tử `LIKE` thông thường trên tập dữ liệu lớn516.
**Lời khuyên:** Bạn nên thực hiện các lệnh này sau khi đã tạo bảng để đảm bảo các ràng buộc dữ liệu đã được thiết lập chính xác17.
thiết kế chi tiết bảng department\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng, các index
Dựa trên các phân tích về kiến trúc SaaS đa tenant và mô hình định danh "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **department\_members** (Thành viên phòng ban) sử dụng YugabyteDB (YSQL).
Bảng này đóng vai trò quản lý quan hệ **N-N** giữa phòng ban (`departments`) và nhân sự trong tổ chức (`tenant_members`), cho phép một người có thể tham gia nhiều phòng ban khác nhau (ví dụ: vừa thuộc phòng IT, vừa thuộc Ban Công đoàn)12.
1\. Thiết kế chi tiết bảng `department_members`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" trong hệ thống phân tán34. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id)` | Xác định bản ghi thuộc tổ chức nào (Sharding Key quan trọng)56. |
| **department\_id** | UUID | NO | | `REFERENCES departments(_id)` | Liên kết tới phòng ban cụ thể27. |
| **member\_id** | UUID | NO | | `REFERENCES tenant_members(_id)` | Liên kết tới hồ sơ nhân sự trong Tenant12. |
| **is\_primary** | BOOLEAN | NO | `FALSE` | | Đánh dấu đây có phải là phòng ban chính của nhân sự này không (dùng để tính headcount)18. |
| **role\_in\_dept** | VARCHAR(100) | YES | `NULL` | | Vai trò cụ thể trong phòng ban này (VD: Thư ký, Điều phối viên)8. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm nhân sự được gán vào phòng ban (UTC)910. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật hồ sơ gần nhất911. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Theo các nguồn dữ liệu, việc gán Index chiến lược là "vũ khí" để hệ thống phản hồi dưới 1ms trong môi trường phân tán1213.
```
-- 1. TẠO BẢNG
CREATE TABLE department_members (
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
department_id UUID NOT NULL,
member_id UUID NOT NULL,
is_primary BOOLEAN NOT NULL DEFAULT FALSE,
role_in_dept VARCHAR(100),
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- Ràng buộc tham chiếu
CONSTRAINT fk_dept_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_dept_mem_dept FOREIGN KEY (department_id) REFERENCES departments(_id) ON DELETE CASCADE,
CONSTRAINT fk_dept_mem_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,
-- Đảm bảo một nhân sự không bị gán trùng lặp vào cùng một phòng ban
CONSTRAINT uq_dept_member_unique UNIQUE (tenant_id, department_id, member_id),
CONSTRAINT chk_dept_mem_updated CHECK (updated_at >= created_at)
);
-- 2. TẠO CÁC INDEX CHIẾN LƯỢC
-- Index hỗ trợ truy vấn danh sách nhân viên của một phòng ban cụ thể
CREATE INDEX idx_dept_mem_lookup
ON department_members (tenant_id, department_id);
-- Index hỗ trợ tìm tất cả các phòng ban mà một nhân viên đang tham gia
CREATE INDEX idx_dept_mem_member
ON department_members (tenant_id, member_id);
-- Index lọc nhanh những nhân sự thuộc phòng ban chính (dùng cho báo cáo nhân sự)
CREATE INDEX idx_dept_mem_primary
ON department_members (tenant_id, is_primary)
WHERE is_primary = TRUE;
```
Các điểm lưu ý trong thiết kế:
• **UUID v7 làm Khóa chính:** Việc dùng UUID v7 đảm bảo dữ liệu được chèn theo thứ tự thời gian, giúp tối ưu hóa việc sắp xếp và tránh tình trạng nghẽn cổ chai (hotspot) khi hệ thống có hàng triệu nhân sự3....
• **SaaS Isolation:** Trường `tenant_id` luôn xuất hiện trong khóa chính hoặc các Index phức hợp (Composite Index) để đảm bảo dữ liệu của khách hàng này không bao giờ bị lẫn sang khách hàng khác5....
• **Tính nhất quán (ACID):** Việc lưu trữ trong YugabyteDB thay vì MongoDB cho phép hệ thống thực hiện các ràng buộc khóa ngoại (Foreign Keys) cứng, đảm bảo nếu một phòng ban bị xóa, các liên kết thành viên cũng tự động được dọn dẹp (Cascade Delete)1617.
**Sự ví von:** Bảng `department_members` giống như **danh sách phân vai** trong một đoàn kịch. Một diễn viên (`member_id`) có thể đóng nhiều vai trong nhiều vở kịch (`department_id`) khác nhau, nhưng tại mỗi vở kịch, họ chỉ có một danh phận cụ thể và ban tổ chức (`tenant_id`) cần biết ai là diễn viên chính (`is_primary`) cho vở diễn đó để quản lý thù lao hiệu quả.
thiết kế chi tiết bảng user\_groups dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về kiến trúc SaaS đa tenant và quy chuẩn thiết kế hệ thống "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **user\_groups** sử dụng YugabyteDB (YSQL).
Việc đặt tên là `user_groups` thay vì `groups` giúp tránh xung đột với các từ khóa dành riêng trong SQL (như `GROUP BY` hoặc `GROUPS` trong Window Functions) và làm rõ ngữ cảnh đây là nhóm của người dùng1,2.
1\. Thiết kế chi tiết bảng `user_groups`
Bảng này hỗ trợ cả cấu hình nhóm tĩnh (thêm tay), nhóm động (dựa trên quy tắc JSONB) và cấu trúc phân cấp (Hierarchy)3,4.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (khuyến nghị dùng UUID v7 để tối ưu sắp xếp theo thời gian)5,6. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định nhóm thuộc tổ chức nào (Sharding Key quan trọng)7,8. |
| **parent\_id** | UUID | YES | `NULL` | `REFERENCES user_groups(_id)` | ID của nhóm cha, dùng để xây dựng cấu trúc phân cấp lồng nhau4,9. |
| **name** | VARCHAR(100) | NO | | `CHECK (LENGTH(name) > 0)` | Tên nhóm (VD: "Squad Mobile", "Phòng IT")4. |
| **code** | VARCHAR(50) | YES | `NULL` | | Mã định danh duy nhất trong một tenant (VD: `GRP_DEV_01`)4. |
| **type** | VARCHAR(20) | NO | `'CUSTOM'` | `CHECK (type IN ('ORG_UNIT', 'PROJECT', 'PERMISSION', 'CUSTOM'))` | Phân loại: Phòng ban, Dự án, Nhóm quyền hoặc nhóm tùy chỉnh9. |
| **dynamic\_rules** | JSONB | YES | `NULL` | | Quy tắc để tự động thêm thành viên (VD: `{"dept": "IT", "loc": "HN"}`)10,11. |
| **path** | TEXT | YES | `NULL` | | **Materialized Path** (VD: `/root-id/child-id/`) giúp truy vấn cây nhóm cực nhanh12,9. |
| **description** | TEXT | YES | `NULL` | | Mô tả chi tiết về mục đích của nhóm4. |
| **owner\_member\_id** | UUID | YES | `NULL` | `REFERENCES tenant_members(_id)` | ID người quản trị/trưởng nhóm13,14. |
| **created\_at** | TIMESTAMPTZ | NO | `NOW()` | | Thời điểm tạo nhóm (UTC)15,16. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking** để ngăn chặn ghi đè dữ liệu đồng thời6,17. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Các chỉ mục được thiết kế để tối ưu hóa việc truy vấn trong môi trường phân tán, đảm bảo tốc độ phản hồi dưới 1ms8,18.
```
-- 1. Tạo bảng user_groups
CREATE TABLE user_groups (
-- I. ĐỊNH DANH & PHÂN CẤP
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
tenant_id UUID NOT NULL,
parent_id UUID,
-- II. THÔNG TIN NGHIỆP VỤ
name VARCHAR(100) NOT NULL,
code VARCHAR(50),
type VARCHAR(20) NOT NULL DEFAULT 'CUSTOM',
dynamic_rules JSONB,
path TEXT,
description TEXT,
owner_member_id UUID,
-- III. TRUY VẾT & PHIÊN BẢN
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC
CONSTRAINT fk_groups_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_groups_parent FOREIGN KEY (parent_id) REFERENCES user_groups(_id),
CONSTRAINT fk_groups_owner FOREIGN KEY (owner_member_id) REFERENCES tenant_members(_id),
CONSTRAINT uq_group_tenant_code UNIQUE (tenant_id, code), -- Mã nhóm là duy nhất trong một công ty
CONSTRAINT chk_groups_type CHECK (type IN ('ORG_UNIT', 'PROJECT', 'PERMISSION', 'CUSTOM'))
);
-- 2. Tạo các Index chiến lược
-- Index hỗ trợ phân tách dữ liệu đa tenant (Bắt buộc cho SaaS) [8]
CREATE INDEX idx_groups_tenant ON user_groups (tenant_id);
-- Index hỗ trợ truy vấn cấu trúc cây (Hierarchy) bằng Materialized Path [9]
-- Sử dụng text_pattern_ops để tối ưu cho toán tử LIKE 'path/%'
CREATE INDEX idx_groups_path ON user_groups (tenant_id, path text_pattern_ops);
-- Index hỗ trợ tìm kiếm nhanh theo loại nhóm
CREATE INDEX idx_groups_type ON user_groups (tenant_id, type);
```
Các điểm nhấn kỹ thuật áp dụng:
• **Materialized Path (****path****)**: Thay vì sử dụng các câu lệnh đệ quy phức tạp, cột `path` cho phép lấy toàn bộ các nhóm con của một nhóm cha chỉ bằng một truy vấn `LIKE` đơn giản, giúp tăng hiệu năng đáng kể12,9.
• **JSONB cho Dynamic Rules**: Cho phép hệ thống linh hoạt định nghĩa các quy tắc tự động hóa việc gán thành viên vào nhóm mà không cần thay đổi cấu trúc bảng10,19.
• **UUID v7**: Đảm bảo các nhóm được tạo mới sẽ được sắp xếp theo trình tự thời gian, giúp tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi chèn dữ liệu vào hệ thống phân tán YugabyteDB5,6.
• **Schema Isolation**: Luôn bao gồm `tenant_id` trong mọi Index để đảm bảo dữ liệu của các khách hàng luôn được tách biệt hoàn toàn7,8.
thiết kế chi tiết bảng group\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về kiến trúc SaaS đa tenant "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, bảng **group\_members** đóng vai trò quản lý mối quan hệ "Nhiều - Nhiều" giữa các nhóm người dùng (`user_groups`) và các thành viên tổ chức (`tenant_members`)1....
Dưới đây là thiết kế chi tiết sử dụng **UUID v7** để tối ưu hóa hiệu năng phân tán và tránh hiện tượng "Hotspot" khi chèn dữ liệu45.
1\. Thiết kế chi tiết bảng `group_members` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn UUID v7 giúp sắp xếp theo thời gian45. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định thành viên nhóm thuộc tổ chức nào (Sharding Key)67. |
| **group\_id** | UUID | NO | | `REFERENCES user_groups(_id) ON DELETE CASCADE` | Liên kết với nhóm (Squad, Dự án, Phòng ban)13. |
| **member\_id** | UUID | NO | | `REFERENCES tenant_members(_id) ON DELETE CASCADE` | Liên kết với hồ sơ nhân sự cụ thể trong Tenant12. |
| **role\_in\_group** | VARCHAR(20) | NO | `'MEMBER'` | `CHECK (role_in_group IN ('LEADER', 'MEMBER', 'SECRETARY'))` | Vai trò cụ thể của thành viên trong nhóm này13. |
| **joined\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm thành viên gia nhập nhóm12. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC)68. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking**: Ngăn chặn ghi đè dữ liệu khi nhiều Admin cùng thao tác9. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh này tuân thủ các quy tắc đặt tên `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho hệ thống phân tán4....
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE group_members (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
group_id UUID NOT NULL,
member_id UUID NOT NULL,
-- II. THÔNG TIN NGHIỆP VỤ
role_in_group VARCHAR(20) NOT NULL DEFAULT 'MEMBER',
joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- III. TRUY VẾT & PHIÊN BẢN
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_gm_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_gm_group FOREIGN KEY (group_id) REFERENCES user_groups(_id) ON DELETE CASCADE,
CONSTRAINT fk_gm_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,
-- Đảm bảo một thành viên không bị gán trùng lặp vào cùng một nhóm
CONSTRAINT uq_group_member UNIQUE (group_id, member_id),
CONSTRAINT chk_gm_role CHECK (role_in_group IN ('LEADER', 'MEMBER', 'SECRETARY')),
CONSTRAINT chk_gm_version CHECK (version >= 1)
);
-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)
-- Index hỗ trợ truy vấn nhanh danh sách tất cả thành viên của một nhóm (Access Pattern: View Group)
CREATE INDEX idx_gm_lookup_group
ON group_members (tenant_id, group_id);
-- Index hỗ trợ tìm tất cả các nhóm mà một nhân sự đang tham gia (Access Pattern: User Profile)
CREATE INDEX idx_gm_lookup_member
ON group_members (tenant_id, member_id);
```
Các phân tích trọng tâm áp dụng vào thiết kế:
• **Tách biệt định danh:** Bảng này liên kết tới `tenant_members` (hồ sơ nhân sự) thay vì liên kết trực tiếp tới `users` (danh tính toàn cầu), giúp đảm bảo tính cô lập dữ liệu giữa các tổ chức khác nhau12....
• **Hiệu năng phân tán:** Việc sử dụng **UUID v7** cho khóa chính giúp các node trong YugabyteDB phân tán tải đồng đều, đồng thời giữ được tính chất sắp xếp theo thời gian, giúp việc truy vấn các thành viên mới gia nhập hiệu quả hơn57.
• **Khả năng mở rộng (Scale):** Thiết kế này hỗ trợ mô hình **ReBAC** (Phân quyền dựa trên quan hệ). Khi cần kiểm tra quyền, hệ thống chỉ cần truy vấn quan hệ giữa `member_id` và `group_id` để xác định quyền hạn thừa kế1516.
• **An toàn dữ liệu:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một nhóm bị giải thể hoặc một nhân sự rời công ty, các bản ghi liên kết trong nhóm sẽ tự động được dọn dẹp, tránh dữ liệu rác (Orphaned Data)317.
**Sự ví von:** Bảng `group_members` giống như **danh sách thành viên của các câu lạc bộ** trong một trường học. `tenants` là trường học, `user_groups` là các câu lạc bộ (Bóng đá, Âm nhạc), và `tenant_members` là học sinh. Một học sinh có thể tham gia nhiều câu lạc bộ với các vai trò khác nhau (như Đội trưởng hoặc Thành viên), và bảng này giúp ban giám hiệu quản lý chính xác ai đang ở đâu12.
thiết kế chi tiết bảng locations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa tenant và các phân tích kỹ thuật từ nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **locations** (Văn phòng & Chi nhánh) sử dụng YugabyteDB (YSQL).
Bảng này đóng vai trò quản lý các địa điểm vật lý của tổ chức, phục vụ cho việc chấm công, định vị GPS và quản lý múi giờ làm việc đặc thù của từng chi nhánh1,2.
Thiết kế chi tiết bảng `locations` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (sử dụng UUID v7 để tối ưu sắp xếp theo thời gian)3,2. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định chi nhánh thuộc tổ chức nào (Sharding Key)4,2. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên văn phòng/chi nhánh (VD: FPT Tower Hà Nội)2. |
| **code** | VARCHAR(50) | YES | `NULL` | | Mã địa điểm dùng để đồng bộ với thiết kế HRM hoặc máy chấm công2,5. |
| **address** | JSONB | NO | `'{}'` | | Lưu chi tiết địa chỉ: số nhà, phường, quận, quốc gia2. |
| **coordinates** | POINT | YES | `NULL` | | Tọa độ GPS (Lat/Long) để xác thực vị trí chấm công2. |
| **radius\_meters** | INT | YES | `NULL` | `CHECK (radius_meters > 0)` | Bán kính cho phép chấm công xung quanh tọa độ (đơn vị: mét)2. |
| **timezone** | VARCHAR(50) | NO | `'Asia/Ho_Chi_Minh'` | | Múi giờ tại địa phương, quan trọng để tính toán ca làm việc2. |
| **is\_headquarter** | BOOLEAN | NO | `FALSE` | | Đánh dấu nếu đây là trụ sở chính của công ty2. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC)6,4. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng6,7. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking** ngăn chặn xung đột khi nhiều người cùng sửa cấu hình8. |
\--------------------------------------------------------------------------------
Câu lệnh YSQL tạo bảng `locations`
Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho tính toàn vẹn dữ liệu (ACID) trong môi trường phân tán9,10.
```
CREATE TABLE locations (
-- I. ĐỊNH DANH & PHÂN TÁCH (IDENTITY & SHARDING)
_id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ tầng Application [3]
tenant_id UUID NOT NULL,
-- II. THÔNG TIN ĐỊA LÝ & NGHIỆP VỤ
name TEXT NOT NULL,
code VARCHAR(50),
address JSONB NOT NULL DEFAULT '{}',
coordinates POINT, -- Kiểu dữ liệu tọa độ hỗ trợ bởi YSQL/Postgres [2]
radius_meters INT,
timezone VARCHAR(50) NOT NULL DEFAULT 'Asia/Ho_Chi_Minh',
is_headquarter BOOLEAN NOT NULL DEFAULT FALSE,
-- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_loc_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT chk_loc_name CHECK (LENGTH(name) > 0),
CONSTRAINT chk_loc_radius CHECK (radius_meters > 0),
CONSTRAINT chk_loc_updated CHECK (updated_at >= created_at)
);
-- IV. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ truy vấn nhanh tất cả chi nhánh của một Tenant (Access Pattern phổ biến) [4], [11]
CREATE INDEX idx_locations_tenant ON locations (tenant_id);
-- Index hỗ trợ tìm kiếm nhanh theo mã chi nhánh trong cùng một tổ chức
CREATE INDEX idx_locations_code ON locations (tenant_id, code);
-- Index lọc nhanh trụ sở chính khi cần hiển thị thông tin pháp lý của Tenant
CREATE INDEX idx_locations_hq ON locations (tenant_id) WHERE is_headquarter = TRUE;
```
Điểm nhấn kỹ thuật theo nguồn dữ liệu:
• **UUID v7:** Giúp các bản ghi văn phòng mới được chèn vào theo thứ tự thời gian, tránh hiện tượng "Hotspot" (nghẽn cổ chai) trên các node của YugabyteDB3,11.
• **JSONB cho địa chỉ:** Thay vì tách quá nhiều cột lẻ (phường, xã, số nhà), sử dụng JSONB cho phép lưu trữ linh hoạt địa chỉ ở các quốc gia khác nhau mà không cần thay đổi cấu trúc bảng12.
• **Timezone & Coordinates:** Hai trường này là "vũ khí" để các ứng dụng chấm công (Timekeeping) xác định xem nhân viên có đang đứng đúng vị trí chi nhánh và tính toán thời gian vào ca chính xác theo giờ địa phương2,5.
**Ví von để dễ hiểu:** Bảng `locations` giống như một **quyển danh bạ các chi nhánh** của một chuỗi cửa hàng. `_id` là mã số cửa hàng, `coordinates` và `radius_meters` giống như một **vòng tròn bảo vệ** ảo trên bản đồ; chỉ khi nhân viên bước vào vòng tròn này, hệ thống mới cho phép "điểm danh" vào làm việc2.
thiết kế chi tiết bảng user\_linked\_identities dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống xác thực đa phương thức (Multi-modal Identity) và quy chuẩn thiết kế SaaS "World-class" trong các nguồn dữ liệu, bảng **user\_linked\_identities** đóng vai trò tách biệt thông tin cá nhân (Profile) khỏi phương thức đăng nhập (Credentials)12.
Việc sử dụng bảng này cho phép một người dùng liên kết nhiều tài khoản (Password, Google, GitHub, Passkeys) vào cùng một danh tính duy nhất13.
1\. Thiết kế chi tiết bảng `user_linked_identities`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sắp xếp theo thời gian và sharding14. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến hồ sơ người dùng gốc trong bảng `users`15. |
| **provider** | VARCHAR(20) | NO | | `CHECK (provider IN ('LOCAL', 'GOOGLE', 'GITHUB', 'MICROSOFT', 'APPLE', 'PASSKEY'))` | Nguồn định danh (LOCAL là mật khẩu truyền thống, còn lại là OAuth/SSO)13. |
| **provider\_id** | VARCHAR(255) | NO | | `UNIQUE(provider, provider_id)` | ID định danh tại nguồn (Email đối với LOCAL, Subject ID đối với OAuth)6. |
| **password\_hash** | TEXT | YES | `NULL` | | Lưu chuỗi băm mật khẩu (chỉ sử dụng khi `provider = 'LOCAL'`)78. |
| **data** | JSONB | NO | `'{}'` | | Lưu trữ linh hoạt metadata như: access\_token, refresh\_token, profile\_url từ nhà cung cấp69. |
| **last\_login\_at** | TIMESTAMPTZ | YES | `NULL` | | Ghi nhận thời điểm cuối cùng đăng nhập bằng phương thức này6. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm liên kết phương thức đăng nhập này vào tài khoản610. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Dưới đây là mã nguồn YSQL để triển khai bảng và các chỉ mục chiến lược nhằm tối ưu hóa tốc độ xác thực.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_linked_identities (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application [4]
user_id UUID NOT NULL,
-- II. THÔNG TIN XÁC THỰC
provider VARCHAR(20) NOT NULL,
provider_id VARCHAR(255) NOT NULL,
password_hash TEXT, -- TEXT tối ưu hơn VARCHAR cho các thuật toán băm hiện đại [7]
-- III. DỮ LIỆU ĐỘNG & TRUY VẾT
data JSONB NOT NULL DEFAULT '{}',
last_login_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_identity_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
-- Đảm bảo 1 tài khoản mạng xã hội chỉ gắn với 1 user duy nhất trên hệ thống [6]
CONSTRAINT uq_provider_identity UNIQUE (provider, provider_id),
-- Kiểm soát danh sách các nhà cung cấp được phép
CONSTRAINT chk_identity_provider CHECK (provider IN ('LOCAL', 'GOOGLE', 'GITHUB', 'MICROSOFT', 'APPLE', 'PASSKEY'))
);
-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)
-- Index quan trọng nhất: Tìm nhanh User ID khi đăng nhập qua Google/Github/Email [8]
-- Query: SELECT user_id FROM user_linked_identities WHERE provider = 'GOOGLE' AND provider_id = '...';
CREATE INDEX idx_identity_lookup
ON user_linked_identities (provider, provider_id);
-- Index hỗ trợ trang quản lý tài khoản: Hiển thị các phương thức đã liên kết của 1 user
CREATE INDEX idx_identity_user_id
ON user_linked_identities (user_id);
```
Các lưu ý kỹ thuật từ nguồn dữ liệu:
• **Chống trộm mật khẩu**: Việc tách `password_hash` sang bảng này giúp hỗ trợ đăng nhập không mật khẩu (Passwordless). Nếu `provider` không phải 'LOCAL', trường này sẽ mang giá trị `NULL`, giúp giảm diện tích tấn công111.
• **Hiệu năng Sharding**: Nhờ khóa chính là **UUID v7**, các bản ghi mới được phân tán đều (Uniform Distribution) trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai (Hotspot) khi có lượng lớn người dùng đăng ký cùng lúc1213.
• **Xóa an toàn**: Ràng buộc `ON DELETE CASCADE` đảm bảo khi tài khoản gốc trong bảng `users` bị xóa, toàn bộ các liên kết định danh này sẽ bị xóa sạch theo, tuân thủ quyền "được quên" (GDPR)514.
**Ví von để dễ hiểu:** Bảng `user_linked_identities` giống như một **chùm chìa khóa đa năng**15. Bảng `users` là cánh cửa nhà bạn, còn mỗi dòng trong bảng này là một loại chìa (chìa cơ, vân tay, thẻ từ). Bạn có thể thêm hoặc bớt chìa mà không cần thay đổi cánh cửa, và mỗi chiếc chìa đều được ghi chép lại lịch sử sử dụng để đảm bảo an ninh tối đa.
thiết kế chi tiết bảng user\_sessions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân chuẩn thiết kế hệ thống SaaS đa tenant và các quy tắc về bảo mật định danh (IAM) trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **user\_sessions** sử dụng YugabyteDB (YSQL).
Bảng này không chỉ lưu trạng thái đăng nhập mà còn hỗ trợ các tính năng cao cấp như **xoay vòng Refresh Token (Rotation)**, **phát hiện xâm nhập** và **quản lý thiết bị tin cậy**12.
1\. Thiết kế chi tiết bảng `user_sessions`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh phiên (Session ID). Sử dụng **UUID v7** để tối ưu sharding và sắp xếp theo thời gian34. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id)` | Xác định phiên thuộc tổ chức nào (SaaS Isolation)45. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id)` | Liên kết tới người dùng sở hữu phiên4. |
| **family\_id** | UUID | NO | | | Định danh chuỗi token (Family). Dùng để thu hồi toàn bộ chuỗi nếu phát hiện token bị trộm26. |
| **refresh\_token\_hash** | VARCHAR(255) | YES | `NULL` | | Lưu chuỗi băm của Refresh Token hiện tại để thực hiện cơ chế xoay vòng2. |
| **rotation\_counter** | INT | NO | `0` | `CHECK (rotation_counter >= 0)` | Số lần xoay vòng token. Nếu phát hiện dùng lại counter thấp, hệ thống sẽ hủy cả family26. |
| **ip\_address** | INET | YES | | | Địa chỉ IP của thiết bị đăng nhập4. |
| **user\_agent** | TEXT | YES | | | Thông tin trình duyệt và hệ điều hành (Fingerprint)4. |
| **device\_type** | VARCHAR(20) | YES | | | Phân loại thiết bị: `MOBILE`, `DESKTOP`, `TABLET`4. |
| **location\_city** | VARCHAR(100) | YES | | | Thành phố đăng nhập (GeoIP)4. |
| **is\_revoked** | BOOLEAN | NO | `FALSE` | | Trạng thái bị thu hồi. Nếu `TRUE`, phiên không còn hiệu lực (dùng cho tính năng "Đăng xuất từ xa")17. |
| **expires\_at** | TIMESTAMPTZ | NO | | | Thời điểm phiên hết hạn hoàn toàn7. |
| **last\_active\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cuối cùng phiên có hoạt động7. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm bắt đầu phiên đăng nhập7. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Việc sử dụng các ràng buộc khóa ngoại (Foreign Keys) và chỉ mục một phần (Partial Index) giúp đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cực nhanh trong môi trường phân tán78.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_sessions (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
tenant_id UUID NOT NULL,
user_id UUID NOT NULL,
-- II. CƠ CHẾ XOAY VÒNG (ROTATION) & BẢO MẬT [2]
family_id UUID NOT NULL,
refresh_token_hash VARCHAR(255),
rotation_counter INT NOT NULL DEFAULT 0,
is_revoked BOOLEAN NOT NULL DEFAULT FALSE,
-- III. THÔNG TIN THIẾT BỊ & VỊ TRÍ [4]
ip_address INET,
user_agent TEXT,
device_type VARCHAR(20),
os_name VARCHAR(50),
browser_name VARCHAR(50),
location_city VARCHAR(100),
location_country VARCHAR(50),
-- IV. THỜI GIAN [7]
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
expires_at TIMESTAMPTZ NOT NULL,
-- V. RÀNG BUỘC
CONSTRAINT fk_sessions_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_sessions_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT chk_rotation_val CHECK (rotation_counter >= 0)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm nhanh danh sách thiết bị đang hoạt động của người dùng [7]
CREATE INDEX idx_sessions_user_active
ON user_sessions (user_id)
WHERE is_revoked = FALSE;
-- Index hỗ trợ quét các phiên đã hết hạn để dọn dẹp (Cleanup Job)
CREATE INDEX idx_sessions_expiry
ON user_sessions (expires_at)
WHERE is_revoked = FALSE;
-- Index hỗ trợ kiểm tra nhanh token trong cùng một family khi thực hiện rotation [6]
CREATE INDEX idx_sessions_family
ON user_sessions (family_id);
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7**: Đảm bảo các phiên đăng nhập mới được chèn vào theo thứ tự thời gian, giúp giảm hiện tượng tranh chấp (hotspot) trên các node của YugabyteDB39.
• **Refresh Token Rotation**: Cơ chế lưu `family_id` và `rotation_counter` cho phép hệ thống phát hiện hành vi sử dụng lại token cũ. Nếu hacker trộm được Refresh Token và sử dụng, hệ thống sẽ **hủy toàn bộ chuỗi phiên** thuộc Family đó để bảo vệ người dùng6.
• **Audit & Impersonation**: Bảng này là nền tảng để hỗ trợ tính năng **Impersonation** (Nhân viên hỗ trợ đăng nhập thay khách hàng) thông qua việc lưu vết `impersonator_id` trong nhật ký hành động đi kèm với `session_id` này1011.
• **Quản lý thiết bị**: Thông qua các trường `os_name`, `browser_name`, khách hàng có thể xem danh sách các thiết bị đang truy cập tài khoản của mình và thực hiện "Đăng xuất khỏi thiết bị khác" bằng cách chuyển `is_revoked` sang `TRUE`14.
**Lời khuyên:** Để tối ưu hiệu năng, các thông tin chi tiết về phiên (như token hiện tại) nên được **cache đồng thời trên Redis** để API Gateway có thể kiểm tra quyền truy cập với độ trễ dưới 1ms mà không cần truy vấn database liên tục1213.
thiết kế chi tiết bảng user\_mfa\_methods dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống xác thực đa phương thức (MFA) và quy chuẩn thiết kế hệ thống SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_mfa\_methods** sử dụng YugabyteDB (YSQL).
Việc thiết kế bảng này cho phép người dùng đăng ký nhiều thiết bị hoặc phương thức xác thực bước hai (như Google Authenticator, SMS, Email) nhằm tăng cường bảo mật và tránh rủi ro mất quyền truy cập khi mất một thiết bị cụ thể12.
1\. Thiết kế chi tiết bảng `user_mfa_methods`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (Sử dụng UUID v7 để tối ưu sharding và sắp xếp theo thời gian)13. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến người dùng sở hữu phương thức MFA này1. |
| **type** | VARCHAR(20) | NO | | `CHECK (type IN ('TOTP', 'SMS', 'EMAIL', 'HARDWARE'))` | Loại xác thực: TOTP (App), SMS, Email hoặc khóa cứng2. |
| **name** | VARCHAR(50) | YES | `NULL` | | Tên gợi nhớ cho thiết bị (VD: "iPhone 15 của An")2. |
| **encrypted\_secret** | TEXT | NO | | | Chuỗi bí mật (Secret Key) đã được **mã hóa** trước khi lưu để đảm bảo an toàn2. |
| **is\_default** | BOOLEAN | NO | `FALSE` | | Đánh dấu phương thức ưu tiên khi đăng nhập2. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` | | Ghi lại thời điểm cuối cùng phương thức này được sử dụng2. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm đăng ký phương thức MFA này2. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này tuân thủ quy chuẩn **snake\_case** và sử dụng các kiểu dữ liệu tối ưu cho hệ thống phân tán YugabyteDB34.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_mfa_methods (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application để tránh Hotspot [3, 5]
user_id UUID NOT NULL,
-- II. CHI TIẾT PHƯƠNG THỨC
type VARCHAR(20) NOT NULL,
name VARCHAR(50),
encrypted_secret TEXT NOT NULL, -- Sử dụng TEXT để linh hoạt cho các loại secret khác nhau [6]
is_default BOOLEAN NOT NULL DEFAULT FALSE,
-- III. TRUY VẾT (AUDIT)
last_used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_mfa_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT chk_mfa_type CHECK (type IN ('TOTP', 'SMS', 'EMAIL', 'HARDWARE')),
CONSTRAINT chk_mfa_timeline CHECK (last_used_at IS NULL OR last_used_at >= created_at)
);
-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)
-- Index hỗ trợ tìm nhanh các phương thức MFA của một người dùng khi đăng nhập
CREATE INDEX idx_user_mfa_lookup
ON user_mfa_methods (user_id);
-- Index một phần (Partial Index) để xác định nhanh phương thức mặc định của người dùng
CREATE INDEX idx_user_mfa_default
ON user_mfa_methods (user_id)
WHERE is_default = TRUE;
```
Các lưu ý kỹ thuật quan trọng:
• **Bảo mật dữ liệu nhạy cảm:** Trường `encrypted_secret` tuyệt đối không được lưu ở dạng rõ (plain text). Theo nguồn dữ liệu, cột này nên được mã hóa bằng khóa riêng (DEK) trước khi đưa vào cơ sở dữ liệu25.
• **Hiệu năng Sharding:** Nhờ sử dụng **UUID v7**, các bản ghi MFA mới được tạo sẽ được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ được tính chất sắp xếp theo thời gian, giúp việc truy vấn "Các thiết bị mới thêm gần đây" diễn ra cực nhanh36.
• **Tính nhất quán (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi tài khoản người dùng trong bảng `users` bị xóa, toàn bộ các phương thức MFA liên quan cũng sẽ bị dọn dẹp sạch sẽ để tránh dữ liệu rác và tuân thủ các quy định về quyền được quên (GDPR)78.
**Ví von để dễ hiểu:** Bảng `user_mfa_methods` giống như một **ngăn kéo chứa các loại chìa khóa dự phòng** cho ngôi nhà của bạn (tài khoản user). Bạn có thể có chìa khóa cơ (SMS), mã vân tay (TOTP) hay thẻ từ (Hardware). Nếu bạn mất một cái, bạn vẫn còn những cái khác để vào nhà, và chủ nhà (hệ thống) sẽ ghi chép lại mỗi khi bạn sử dụng bất kỳ chiếc chìa nào.
thiết kế chi tiết bảng user\_webauthn\_credentials dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống xác thực hiện đại (Passwordless/Passkeys) và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_webauthn\_credentials** sử dụng YugabyteDB (YSQL).
Việc áp dụng chuẩn **WebAuthn (FIDO2)** giúp người dùng đăng nhập bằng vân tay, khuôn mặt (FaceID) hoặc khóa vật lý (YubiKey), mang lại khả năng chống tấn công giả mạo (Phishing) gần như tuyệt đối1,2.
1\. Thiết kế chi tiết bảng `user_webauthn_credentials`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (Sử dụng **UUID v7** để tối ưu sắp xếp theo thời gian và phân tán dữ liệu)3,1. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến tài khoản người dùng gốc1. |
| **name** | VARCHAR(100) | YES | `NULL` | | Tên gợi nhớ cho thiết bị (VD: "MacBook TouchID", "YubiKey 5C")1. |
| **credential\_id** | TEXT | NO | | `UNIQUE` | ID định danh duy nhất của thiết bị WebAuthn trả về, dùng để nhận diện thiết bị khi đăng nhập1,2. |
| **public\_key** | TEXT | NO | | | Khóa công khai dùng để xác thực chữ ký số từ thiết bị trong mỗi lần đăng nhập1,2. |
| **sign\_count** | INT | NO | `0` | `CHECK (sign_count >= 0)` | Bộ đếm số lần sử dụng nhằm chống lại các cuộc tấn công phát lại (Replay Attack)1,2. |
| **transports** | TEXT\[\] | YES | `NULL` | | Mảng lưu các phương thức kết nối được hỗ trợ (VD: `{'usb', 'nfc', 'ble', 'internal'}`)2. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm gần nhất thiết bị này được sử dụng để đăng nhập2. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm đăng ký thiết bị vào hệ thống (UTC)4,2. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Dưới đây là mã nguồn YSQL để triển khai bảng và các chỉ mục tối ưu, đảm bảo hiệu năng truy vấn dưới 1ms trong môi trường phân tán5,6.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_webauthn_credentials (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
user_id UUID NOT NULL,
-- II. DỮ LIỆU KỸ THUẬT FIDO2/PASSKEY
name VARCHAR(100),
credential_id TEXT NOT NULL,
public_key TEXT NOT NULL,
sign_count INT NOT NULL DEFAULT 0,
transports TEXT[], -- Kiểu mảng hỗ trợ bởi YSQL/Postgres [2]
-- III. TRUY VẾT THỜI GIAN
last_used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_webauthn_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT uq_credential_id UNIQUE (credential_id), -- Credential ID phải là duy nhất toàn sàn [1]
CONSTRAINT chk_sign_count CHECK (sign_count >= 0)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index quan trọng: Tìm nhanh toàn bộ thiết bị Passkey của một người dùng khi bắt đầu bước Login Challenge
CREATE INDEX idx_webauthn_user_lookup
ON user_webauthn_credentials (user_id);
-- Index hỗ trợ việc xác thực dựa trên Credential ID trả về từ trình duyệt
CREATE INDEX idx_webauthn_credential_lookup
ON user_webauthn_credentials (credential_id);
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7 & Hiệu năng Sharding:** Sử dụng UUID v7 cho khóa chính giúp các bản ghi được phân tán đều trên các node của YugabyteDB, đồng thời giữ được tính chất sắp xếp theo thời gian giúp các truy vấn tìm thiết bị mới nhất cực kỳ hiệu quả3,7.
• **Bảo mật Replay Attack:** Cột `sign_count` là yếu tố sống còn trong WebAuthn. Theo phân tích, nếu hệ thống nhận được một yêu cầu đăng nhập với `sign_count` thấp hơn hoặc bằng giá trị đã lưu, đó có thể là dấu hiệu thiết bị đã bị clone hoặc bị tấn công phát lại8,9.
• **Khả năng mở rộng:** Kiểu dữ liệu `TEXT[]` cho `transports` cho phép hệ thống linh hoạt hỗ trợ các loại kết nối mới của thiết bị trong tương lai mà không cần thay đổi cấu trúc bảng2.
• **Toàn vẹn dữ liệu:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi người dùng bị xóa khỏi hệ thống, các thông tin định danh sinh trắc học nhạy cảm cũng sẽ bị xóa bỏ hoàn toàn, tuân thủ các quy định về quyền riêng tư như GDPR10,11.
**Ví von:** Bảng `user_webauthn_credentials` giống như một **kho lưu trữ các mẫu dấu vân tay và khuôn mặt số**. Thay vì giữ chìa khóa (mật khẩu), hệ thống lưu lại các "mẫu đối chiếu" (`public_key`). Mỗi khi bạn chạm tay vào thiết bị, thiết bị sẽ tạo ra một chữ ký mới và hệ thống chỉ việc lấy mẫu đã lưu ra để khớp lệnh mà không bao giờ cần biết mật khẩu thật của bạn là gì1,2.
thiết kế chi tiết bảng user\_backup\_codes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống bảo mật đa lớp (MFA) và quy chuẩn thiết kế SaaS "World-class" trong các nguồn dữ liệu, bảng **user\_backup\_codes** đóng vai trò là lớp phòng thủ cuối cùng (Recovery) khi người dùng mất quyền truy cập vào các thiết bị xác thực chính1,2.
Việc sử dụng **UUID v7** cho định danh giúp tối ưu hóa hiệu năng chèn dữ liệu và sắp xếp theo thời gian trong môi trường phân tán của YugabyteDB3,4.
1\. Thiết kế chi tiết bảng `user_backup_codes`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" và tối ưu hóa việc phân tán dữ liệu3,5. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến tài khoản người dùng gốc trong hệ thống định danh toàn cầu6,7. |
| **code\_hash** | TEXT | NO | | | Chuỗi băm của mã dự phòng (tương tự mật khẩu, tuyệt đối không lưu dạng rõ)8,9. |
| **is\_used** | BOOLEAN | NO | `FALSE` | | Trạng thái mã đã được sử dụng hay chưa6. |
| **used\_at** | TIMESTAMPTZ | YES | `NULL` | | Ghi lại thời điểm chính xác mã này được sử dụng để khôi phục tài khoản6. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo mã (luôn lưu theo giờ UTC)10,6. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Dưới đây là các câu lệnh SQL được thiết kế để đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cao11,12.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_backup_codes (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
user_id UUID NOT NULL,
-- II. NỘI DUNG & TRẠNG THÁI
code_hash TEXT NOT NULL,
is_used BOOLEAN NOT NULL DEFAULT FALSE,
-- III. TRUY VẾT THỜI GIAN
used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
-- Xóa người dùng sẽ tự động xóa các mã dự phòng liên quan (GDPR Compliance)
CONSTRAINT fk_backup_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
-- Đảm bảo logic thời gian: Ngày sử dụng phải sau ngày tạo
CONSTRAINT chk_backup_time CHECK (used_at IS NULL OR used_at >= created_at)
);
-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)
-- Index hỗ trợ tìm nhanh danh sách các mã dự phòng của một người dùng cụ thể
CREATE INDEX idx_backup_user_lookup
ON user_backup_codes (user_id);
-- Partial Index: Chỉ index các mã chưa sử dụng để tăng tốc độ xác thực khi login
-- Giảm dung lượng index và tăng hiệu năng do không chứa các mã đã dùng
CREATE INDEX idx_backup_unused_codes
ON user_backup_codes (user_id)
WHERE is_used = FALSE;
```
Các lưu ý kỹ thuật quan trọng:
• **Bảo mật băm mã (Hashing):** Theo các nguồn dữ liệu, mã dự phòng phải được xử lý như mật khẩu; hệ thống chỉ lưu bản băm (`code_hash`) để ngay cả khi dữ liệu bị rò rỉ, hacker cũng không thể sử dụng mã8.
• **UUID v7:** Việc sử dụng UUID v7 giúp các node trong YugabyteDB ghi dữ liệu tuần tự hơn, tránh việc dồn tải vào một node duy nhất (hotspot) trong cụm phân tán3,4.
• **Xoay vòng mã:** Hệ thống thường sinh ra một bộ 10 mã mỗi lần; việc sử dụng `Partial Index` trên trường `is_used` giúp việc kiểm tra tính hợp lệ của mã trong bộ này diễn ra gần như tức thì8.
**Sự ví von:** Bảng `user_backup_codes` giống như một **hộp chứa các chìa khóa vạn năng dự phòng** được cất trong két sắt. Bạn chỉ sử dụng chúng khi làm mất chìa khóa chính (thiết bị MFA), và mỗi chiếc chìa này chỉ có tác dụng **mở khóa một lần duy nhất** rồi sẽ bị hủy bỏ để đảm bảo an toàn tuyệt đối.
thiết kế chi tiết bảng tenant\_sso\_configs dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenant\_sso\_configs**.
Bảng này đóng vai trò quan trọng trong việc cho phép các khách hàng doanh nghiệp lớn (Enterprise) tích hợp hệ thống định danh sẵn có của họ (như Azure AD, Okta, Google Workspace) vào nền tảng thông qua chuẩn SAML 2.0 hoặc OIDC1,2.
1\. Thiết kế chi tiết bảng `tenant_sso_configs`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO | | `PRIMARY KEY`, `REFERENCES tenants(_id) ON DELETE CASCADE` | Định danh Tenant. Mỗi tổ chức thường chỉ có một cấu hình SSO chính2,3. Sử dụng UUID v7 để tối ưu hiệu năng4. |
| **provider\_type** | VARCHAR(20) | NO | | `CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'GOOGLE', 'SAML', 'OIDC'))` | Loại nhà cung cấp định danh (IdP)2,5. |
| **entry\_point\_url** | TEXT | NO | | | URL đăng nhập của nhà cung cấp định danh bên ngoài2,5. |
| **issuer\_id** | TEXT | YES | `NULL` | | Định danh thực thể (Entity ID/Issuer) của IdP2. |
| **cert\_public\_key** | TEXT | YES | `NULL` | | Chứng chỉ PEM dùng để xác thực chữ ký số từ IdP (SAML)2,5. |
| **client\_id** | VARCHAR(255) | YES | `NULL` | | Client ID dùng cho phương thức OIDC5. |
| **client\_secret\_enc** | TEXT | YES | `NULL` | | Client Secret đã mã hóa (chỉ dùng cho OIDC)5. |
| **attribute\_mapping** | JSONB | NO | `'{}'` | | Ánh xạ các trường dữ liệu (VD: map 'mail' của IdP sang 'email' của hệ thống)2,5. |
| **is\_enforced** | BOOLEAN | NO | `FALSE` | | Nếu `TRUE`, bắt buộc nhân viên phải đăng nhập qua SSO, cấm dùng mật khẩu thông thường2,5. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo cấu hình (UTC)6,7. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng7. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để chống ghi đè dữ liệu đồng thời8. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Thiết kế này sử dụng các chuẩn mực về kiểu dữ liệu (UUID v7, JSONB, TIMESTAMPTZ) và quy tắc đặt tên `snake_case` để đảm bảo hệ thống vận hành trơn tru và dễ mở rộng9,10,4.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_sso_configs (
-- I. ĐỊNH DANH & LIÊN KẾT
tenant_id UUID PRIMARY KEY, -- Sử dụng luôn tenant_id làm PK vì quan hệ 1-1
-- II. THÔNG TIN KỸ THUẬT IdP
provider_type VARCHAR(20) NOT NULL,
entry_point_url TEXT NOT NULL,
issuer_id TEXT,
cert_public_key TEXT,
client_id VARCHAR(255),
client_secret_enc TEXT,
-- III. CẤU HÌNH NGHIỆP VỤ
attribute_mapping JSONB NOT NULL DEFAULT '{}',
is_enforced BOOLEAN NOT NULL DEFAULT FALSE,
-- IV. TRUY VẾT & PHIÊN BẢN
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- V. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_sso_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT chk_sso_provider CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'GOOGLE', 'SAML', 'OIDC')),
CONSTRAINT chk_sso_dates CHECK (updated_at >= created_at),
CONSTRAINT chk_sso_version CHECK (version >= 1)
);
-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)
-- Mặc dù tenant_id đã là PRIMARY KEY (có sẵn index),
-- chúng ta có thể tạo thêm index trên is_enforced để hệ thống quản trị
-- nhanh chóng lọc ra các Tenant đang áp dụng chính sách bảo mật nghiêm ngặt.
CREATE INDEX idx_sso_enforced ON tenant_sso_configs (is_enforced) WHERE is_enforced = TRUE;
-- Index hỗ trợ tìm kiếm cấu hình theo loại nhà cung cấp
CREATE INDEX idx_sso_provider ON tenant_sso_configs (provider_type);
```
Các lưu ý kỹ thuật từ nguồn dữ liệu:
• **Bảo mật:** Trường `client_secret_enc` tuyệt đối phải được mã hóa ở tầng ứng dụng trước khi lưu vào cơ sở dữ liệu để đảm bảo an toàn11.
• **Hiệu năng:** Việc sử dụng **JSONB** cho `attribute_mapping` cho phép hệ thống linh hoạt thay đổi quy tắc ánh xạ trường dữ liệu giữa các nhà cung cấp định danh khác nhau mà không cần thay đổi cấu trúc bảng12,13.
• **Tính nhất quán:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant bị xóa khỏi hệ thống, cấu hình SSO liên quan cũng sẽ bị dọn dẹp sạch sẽ14,15.
**Sự ví von:** Bảng `tenant_sso_configs` giống như một **bộ chuyển đổi phích cắm đa năng** (Adapter). Hệ thống SaaS của bạn có một kiểu phích cắm riêng, nhưng mỗi doanh nghiệp khách hàng lại dùng một kiểu phích cắm khác (Azure, Okta...). Bảng này lưu trữ thông số kỹ thuật của bộ chuyển đổi để đảm bảo "dòng điện định danh" có thể chảy thông suốt từ doanh nghiệp vào hệ thống của bạn một cách an toàn16.
thiết kế chi tiết bảng auth\_verification\_codes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống xác thực đa phương thức và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, bảng **auth\_verification\_codes** đóng vai trò quản lý các mã xác thực ngắn hạn (OTP, Magic Link) dùng cho các luồng: Đăng ký, Quên mật khẩu, và Đăng nhập không mật khẩu12.
Việc sử dụng **UUID v7** đảm bảo tính phân tán và sắp xếp theo thời gian, giúp hệ thống hoạt động mượt mà ở quy mô lớn23.
1\. Thiết kế chi tiết bảng `auth_verification_codes`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding24. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định mã thuộc tổ chức nào (SaaS Isolation)25. |
| **identifier** | VARCHAR(255) | NO | | | Email hoặc số điện thoại nhận mã xác thực2. |
| **type** | VARCHAR(30) | NO | | `CHECK (type IN ('EMAIL_VERIFICATION', 'PASSWORD_RESET', 'LOGIN_OTP', 'MAGIC_LINK'))` | Phân loại mục đích của mã xác thực2. |
| **code\_hash** | TEXT | NO | | | Chuỗi băm (Hash) của mã bí mật để đảm bảo an toàn, không lưu dạng rõ2. |
| **expires\_at** | TIMESTAMPTZ | NO | | | Thời điểm mã hết hạn (thường từ 5-15 phút)26. |
| **attempt\_count** | INT | NO | `0` | `CHECK (attempt_count <= 5)` | Bộ đếm số lần nhập sai để chống tấn công Brute-force26. |
| **metadata** | JSONB | YES | `'{}'` | | Lưu ngữ cảnh bổ sung như `redirect_url` hoặc `device_info`26. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo mã (UTC)27. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Dưới đây là các câu lệnh SQL được thiết kế tối ưu cho YugabyteDB để đảm bảo tính toàn vẹn dữ liệu và hiệu năng truy vấn cao2....
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE auth_verification_codes (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
-- II. NỘI DUNG & LOẠI XÁC THỰC
identifier VARCHAR(255) NOT NULL,
type VARCHAR(30) NOT NULL,
code_hash TEXT NOT NULL,
-- III. KIỂM SOÁT THỜI GIAN & BẢO MẬT
expires_at TIMESTAMPTZ NOT NULL,
attempt_count INT NOT NULL DEFAULT 0,
metadata JSONB DEFAULT '{}',
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_auth_codes_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT chk_auth_codes_type CHECK (type IN ('EMAIL_VERIFICATION', 'PASSWORD_RESET', 'LOGIN_OTP', 'MAGIC_LINK')),
CONSTRAINT chk_auth_codes_attempts CHECK (attempt_count <= 5),
CONSTRAINT chk_auth_codes_expiry CHECK (expires_at > created_at)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm nhanh mã hợp lệ gần nhất cho một User/Email/Phone cụ thể
-- Giúp tăng tốc luồng verify OTP khi user nhập mã
CREATE INDEX idx_auth_codes_lookup
ON auth_verification_codes (tenant_id, identifier, type, expires_at DESC);
-- Index hỗ trợ dọn dẹp các mã đã hết hạn (Cleanup Job)
-- Sử dụng Partial Index để chỉ tập trung vào các bản ghi đã quá hạn
CREATE INDEX idx_auth_codes_cleanup
ON auth_verification_codes (expires_at)
WHERE expires_at < NOW();
```
Các điểm nhấn kỹ thuật theo nguồn dữ liệu:
• **Bảo mật tuyệt đối:** Theo quy chuẩn, mật mã không bao giờ được lưu ở dạng rõ; trường `code_hash` sử dụng thuật toán băm giúp bảo vệ người dùng ngay cả khi cơ sở dữ liệu bị rò rỉ2.
• **Chống tấn công Brute-force:** Ràng buộc `attempt_count <= 5` kết hợp với logic ứng dụng sẽ tự động vô hiệu hóa mã nếu người dùng nhập sai quá số lần quy định6.
• **Hiệu năng Sharding:** Sử dụng **UUID v7** làm khóa chính giúp dữ liệu được phân tán đều trên các node của YugabyteDB, tránh hiện tượng "hotspot" khi có hàng triệu yêu cầu OTP được gửi đi cùng lúc310.
• **SaaS Isolation:** Trường `tenant_id` được đưa vào Index phức hợp để đảm bảo dữ liệu xác thực của các tổ chức luôn được tách biệt hoàn toàn511.
**Sự ví von:** Bảng `auth_verification_codes` giống như một **tập cuống vé xem phim có thời hạn**. Mỗi cuống vé (`code_hash`) chỉ dành cho một người (`identifier`) và một suất chiếu cụ thể (`type`). Nếu bạn không vào rạp trước giờ phim bắt đầu (`expires_at`) hoặc cố tình dùng vé giả quá nhiều lần (`attempt_count`), cuống vé đó sẽ trở thành rác vô giá trị và bị ban quản lý dọn dẹp sạch sẽ.
thiết kế chi tiết bảng personal\_access\_tokens dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống xác thực dành cho nhà phát triển (Developer Experience - DevEx) và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **personal\_access\_tokens** (PATs) sử dụng YugabyteDB (YSQL).
Việc sử dụng PATs cho phép các lập trình viên hoặc các kịch bản tự động (scripts) tích hợp với hệ thống mà không cần sử dụng mật khẩu hoặc duy trì phiên đăng nhập ngắn hạn (Session), giúp mở rộng SaaS thành một nền tảng mở12.
1\. Thiết kế chi tiết bảng `personal_access_tokens`
Bảng này được thiết kế để lưu trữ bản băm (hash) của token thay vì bản rõ để đảm bảo an toàn tuyệt đối3.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất. Sử dụng **UUID v7** để tối ưu sắp xếp theo thời gian và tránh "hotspot" trong DB phân tán14. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định token thuộc tổ chức nào để đảm bảo tính cô lập dữ liệu (SaaS Isolation)35. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Người dùng sở hữu và tạo ra token này1. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên gợi nhớ của token (Ví dụ: "Script Sync Excel", "Jenkins CI/CD")3. |
| **token\_prefix** | VARCHAR(10) | NO | | | Chuỗi tiền tố (Ví dụ: `pat_live_`) để người dùng nhận diện token mà không cần lộ toàn bộ3. |
| **token\_hash** | TEXT | NO | | `UNIQUE` | **Bản băm** của token (SHA-256). **Tuyệt đối không lưu token gốc**3. |
| **scopes** | TEXT\[\] | NO | | | Mảng các quyền hạn (Ví dụ: `['user:read', 'report:export']`) giới hạn phạm vi truy cập3. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` | | Ghi lại thời điểm gần nhất token này được sử dụng để gọi API3. |
| **expires\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm hết hạn. Nếu `NULL` nghĩa là token vĩnh viễn (khuyến nghị có hạn)3. |
| **is\_active** | BOOLEAN | NO | `TRUE` | | Trạng thái kích hoạt. Cho phép người dùng vô hiệu hóa nhanh token mà không cần xóa2. |
| **created\_at** | TIMESTAMPTZ | NO | `NOW()` | | Thời điểm tạo mã token (luôn lưu theo giờ UTC)67. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** để tránh ghi đè dữ liệu đồng thời89. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Dưới đây là mã lệnh YSQL để triển khai bảng và các chỉ mục chiến lược nhằm tối ưu hóa hiệu năng truy vấn trong môi trường phân tán10.
```
-- 1. Câu lệnh tạo bảng personal_access_tokens
CREATE TABLE personal_access_tokens (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
user_id UUID NOT NULL,
-- II. THÔNG TIN TOKEN & BẢO MẬT
name TEXT NOT NULL,
token_prefix VARCHAR(10) NOT NULL,
token_hash TEXT NOT NULL,
scopes TEXT[] NOT NULL, -- Kiểu mảng hỗ trợ phân quyền linh hoạt
-- III. TRẠNG THÁI & THỜI GIAN
last_used_at TIMESTAMPTZ,
expires_at TIMESTAMPTZ,
is_active BOOLEAN NOT NULL DEFAULT TRUE,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_pat_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_pat_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT uq_token_hash UNIQUE (token_hash),
CONSTRAINT chk_pat_name CHECK (LENGTH(name) > 0)
);
-- 2. Chiến lược đánh Index (Indexing Strategy)
-- Index hỗ trợ xác thực token cực nhanh khi có request API
-- Truy vấn: SELECT user_id, scopes FROM personal_access_tokens WHERE token_hash = ? AND is_active = TRUE;
CREATE INDEX idx_pat_auth_lookup
ON personal_access_tokens (token_hash)
WHERE is_active = TRUE;
-- Index hỗ trợ trang quản lý: Hiển thị danh sách token của một người dùng trong một Tenant
CREATE INDEX idx_pat_user_list
ON personal_access_tokens (tenant_id, user_id);
-- Index hỗ trợ các tác vụ dọn dẹp (Cleanup) token đã hết hạn
CREATE INDEX idx_pat_expiry
ON personal_access_tokens (expires_at)
WHERE expires_at IS NOT NULL;
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7**: Đảm bảo các token mới tạo được sắp xếp tuần tự theo thời gian, giúp YugabyteDB phân bổ dữ liệu vào các "Tablets" một cách hiệu quả và giảm thiểu việc tranh chấp (hotspot)411.
• **Security (Bảo mật)**: Chỉ lưu `token_hash`. Nếu cơ sở dữ liệu bị rò rỉ, kẻ tấn công cũng không thể lấy được token gốc để truy cập hệ thống3.
• **Scopes (Phạm vi quyền)**: Sử dụng kiểu `TEXT[]` giúp hệ thống kiểm tra quyền hạn cực kỳ linh hoạt (Ví dụ: `WHERE 'user:read' = ANY(scopes)`)1213.
• **SaaS Isolation**: Trường `tenant_id` luôn hiện diện để đảm bảo quy trình xác thực không bao giờ bị lẫn lộn giữa các khách hàng khác nhau514.
**Ví dụ trực quan:** Bảng `personal_access_tokens` giống như một **danh sách các thẻ từ phụ** mà bạn cấp cho nhân viên để vào kho. Bạn không cho họ chìa khóa tổng (mật khẩu), mà cho họ một chiếc thẻ chỉ được phép mở cửa kho (scopes) và có thời hạn nhất định (expires\_at). Nếu họ làm mất, bạn chỉ cần vô hiệu hóa chiếc thẻ đó (is\_active = FALSE) là xong.
thiết kế chi tiết bảng roles dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **roles**.
Bảng này được thiết kế theo mô hình **RBAC (Role-Based Access Control)** chuyên sâu dành cho Enterprise, cho phép định nghĩa các vai trò hệ thống và vai trò tùy chỉnh cho từng Tenant1,2.
1\. Thiết kế chi tiết bảng `roles` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**, giúp tối ưu hóa sắp xếp theo thời gian và sharding3,4. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định vai trò này thuộc tổ chức nào (Sharding Key)5,4. |
| **name** | VARCHAR(100) | NO | | `CHECK (LENGTH(name) > 0)` | Tên vai trò (VD: Admin, Editor, HR Manager)4. |
| **description** | TEXT | YES | `NULL` | | Mô tả chi tiết về trách nhiệm của vai trò này4. |
| **type** | VARCHAR(20) | NO | `'CUSTOM'` | `CHECK (type IN ('SYSTEM', 'CUSTOM'))` | **SYSTEM**: Vai trò mặc định không thể xóa. **CUSTOM**: Vai trò do khách hàng tự định nghĩa6. |
| **permission\_codes** | TEXT\[\] | NO | `'{}'` | | Mảng chứa các mã quyền (VD: `{'user:view', 'invoice:create'}`). Lưu mảng giúp truy vấn nhanh mà không cần join bảng trung gian6. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo vai trò (UTC)7,8. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng8. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | **Optimistic Locking**: Ngăn chặn xung đột khi nhiều Admin cùng sửa cấu hình vai trò5,6. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn phân tán9,10.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE roles (
-- I. ĐỊNH DANH & PHÂN TÁCH (IDENTITY & SHARDING)
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
-- II. THÔNG TIN NGHIỆP VỤ
name VARCHAR(100) NOT NULL,
description TEXT,
type VARCHAR(20) NOT NULL DEFAULT 'CUSTOM',
-- III. QUYỀN HẠN (Sử dụng mảng TEXT[] để tối ưu hiệu năng)
permission_codes TEXT[] NOT NULL DEFAULT '{}',
-- IV. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_role_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT chk_role_type CHECK (type IN ('SYSTEM', 'CUSTOM')),
CONSTRAINT chk_role_version CHECK (version >= 1),
CONSTRAINT chk_role_dates CHECK (updated_at >= created_at),
-- Đảm bảo tên vai trò là duy nhất trong phạm vi một Tenant
CONSTRAINT uq_role_name_per_tenant UNIQUE (tenant_id, name)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ lấy nhanh danh sách vai trò của một Tenant
CREATE INDEX idx_roles_tenant_lookup
ON roles (tenant_id);
-- Index GIN hỗ trợ tìm kiếm các vai trò có chứa một mã quyền cụ thể
-- Query: SELECT * FROM roles WHERE 'user:view' = ANY(permission_codes);
CREATE INDEX idx_roles_permissions
ON roles USING GIN (permission_codes);
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7:** Đảm bảo các vai trò mới được tạo sẽ được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ được tính chất tuần tự theo thời gian, giúp việc index và truy vấn hiệu quả hơn3,11.
• **Permission Flattening (Phẳng hóa quyền):** Thay vì sử dụng bảng trung gian `role_permissions` truyền thống, việc lưu mã quyền dưới dạng mảng `TEXT[]` giúp hệ thống kiểm tra quyền hạn cực nhanh chỉ với một câu truy vấn duy nhất, giảm thiểu chi phí JOIN trong môi trường dữ liệu phân tán1,6.
• **Tenant Isolation (Cô lập Tenant):** Ràng buộc `UNIQUE (tenant_id, name)` đảm bảo tính toàn vẹn dữ liệu, không cho phép trùng tên vai trò trong cùng một tổ chức nhưng vẫn cho phép các tổ chức khác nhau có cùng tên vai trò12.
• **Optimistic Locking:** Cột `version` bảo vệ cấu hình vai trò khỏi các lỗi ghi đè dữ liệu đồng thời khi có nhiều quản trị viên cùng thao tác5.
**Sự ví von:** Bảng `roles` giống như một **bộ danh mục các "thẻ thông hành"** trong một tòa nhà văn phòng (Tenant). Mỗi tấm thẻ (`_id`) có một tên gọi (`name`) như "Bảo vệ" hay "Giám đốc" và được ghi sẵn danh sách những cánh cửa mà người cầm thẻ được phép mở (`permission_codes`). Việc sử dụng UUID v7 giúp người quản lý sắp xếp các tấm thẻ này vào kho lưu trữ một cách khoa học nhất theo thứ tự cấp phát.
thiết kế chi tiết bảng permissions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống RBAC (Role-Based Access Control) chuyên sâu cho SaaS và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **permissions**.
Bảng này đóng vai trò là danh mục các hành động kỹ thuật (quyền hạn) cấp hệ thống do nhà phát triển định nghĩa để kiểm soát truy cập vào các module chức năng khác nhau1,2.
1\. Thiết kế chi tiết bảng `permissions` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian3,4. |
| **code** | VARCHAR(100) | NO | | `UNIQUE`, `CHECK (LENGTH(code) > 0)` | Mã quyền duy nhất dùng trong code (VD: `invoice:create`, `user:view`)1,5. |
| **module** | VARCHAR(50) | NO | | | Tên module chức năng sở hữu quyền này (VD: `FINANCE`, `HRM`, `IAM`)1. |
| **description** | TEXT | YES | `NULL` | | Mô tả chi tiết ý nghĩa và phạm vi tác động của quyền này1. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo quyền trong hệ thống (UTC)6,7. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật thông tin quyền gần nhất8. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn trong môi trường phân tán9,10.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE permissions (
-- I. ĐỊNH DANH (IDENTITY)
-- Khuyến nghị sinh UUID v7 từ tầng Application để tối ưu hiệu năng ghi
_id UUID PRIMARY KEY,
-- II. THÔNG TIN NGHIỆP VỤ (BUSINESS DATA)
-- Code là định danh logic để ứng dụng kiểm tra quyền (Entitlement Check)
code VARCHAR(100) NOT NULL,
module VARCHAR(50) NOT NULL,
description TEXT,
-- III. TRUY VẾT (AUDIT)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_permissions_code UNIQUE (code),
CONSTRAINT chk_permissions_code_len CHECK (LENGTH(code) > 0),
CONSTRAINT chk_permissions_dates CHECK (updated_at >= created_at)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm kiếm nhanh mã quyền khi ứng dụng thực hiện kiểm tra quyền hạn (AuthZ)
-- Query: SELECT _id FROM permissions WHERE code = 'user:view_salary';
CREATE UNIQUE INDEX idx_permissions_code_lookup ON permissions (code);
-- Index hỗ trợ việc phân loại và hiển thị danh sách quyền theo module trong trang quản trị Roles
-- Query: SELECT * FROM permissions WHERE module = 'FINANCE';
CREATE INDEX idx_permissions_module_group ON permissions (module);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **UUID v7 cho Khóa chính:** Việc sử dụng UUID v7 thay vì Serial Int truyền thống giúp tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi ghi dữ liệu đồng thời vào các node trong cụm YugabyteDB, đồng thời vẫn giữ được khả năng sắp xếp theo thời gian3,10.
• **Tách biệt Permission và Role:** Bảng này chỉ chứa danh mục quyền tĩnh do hệ thống quy định1. Các quyền này sau đó sẽ được "phẳng hóa" (Flattening) và lưu vào mảng `permission_codes` của bảng `roles` để tối ưu hóa tốc độ kiểm tra quyền mà không cần thực hiện JOIN nhiều bảng phức tạp trong môi trường SQL phân tán11,12.
• **Module-based Grouping:** Trường `module` giúp tổ chức cây phân quyền trên giao diện người dùng (UI) một cách khoa học, giúp quản trị viên dễ dàng quản lý hàng trăm quyền hạn khác nhau trong một hệ thống Enterprise SaaS1,13.
**Ví dụ trực quan:** Bảng `permissions` giống như **danh mục các loại chìa khóa** có thể tồn tại trong một tòa nhà. Một quyền (`code`) như `door:open` đại diện cho khả năng mở một cánh cửa cụ thể. Các chìa khóa này sau đó sẽ được gom vào các "chùm chìa khóa" (Roles) để cấp cho từng nhân viên (Users) tùy theo vị trí công việc của họ.
thiết kế chi tiết bảng user\_roles dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về mô hình phân quyền **RBAC (Role-Based Access Control)** chuyên sâu cho Enterprise SaaS và các quy chuẩn kỹ thuật của YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_roles**.
Bảng này đóng vai trò là "cầu nối" để gán các vai trò cụ thể cho người dùng trong từng tổ chức (Tenant), đồng thời hỗ trợ cơ chế **Data Scoping** (Phạm vi dữ liệu) để giới hạn quyền hạn trong một không gian cụ thể như phòng ban hoặc chi nhánh12.
1\. Thiết kế chi tiết bảng `user_roles`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sắp xếp theo thời gian và tránh "hotspot" khi ghi phân tán34. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation), xác định quan hệ này thuộc về khách hàng nào15. |
| **member\_id** | UUID | NO | | `REFERENCES tenant_members(_id) ON DELETE CASCADE` | Liên kết với hồ sơ nhân viên trong tổ chức (thay vì User gốc) để quản lý vòng đời nhân sự67. |
| **role\_id** | UUID | NO | | `REFERENCES roles(_id) ON DELETE CASCADE` | Vai trò được gán (VD: Manager, Editor)18. |
| **scope\_type** | VARCHAR(50) | NO | `'GLOBAL'` | `CHECK (scope_type IN ('GLOBAL', 'DEPARTMENT', 'LOCATION', 'PROJECT'))` | Phạm vi áp dụng quyền: Toàn cục, theo phòng ban, hoặc theo dự án cụ thể2. |
| **scope\_values** | TEXT\[\] | NO | `'{}'` | | Mảng chứa các UUID của phòng ban/vị trí tương ứng với `scope_type`9. |
| **assigned\_by** | UUID | YES | `NULL` | | ID của người thực hiện gán quyền để phục vụ truy vết (Audit)110. |
| **assigned\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm chính xác quyền được gán (UTC)111. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này sử dụng các ràng buộc cứng và chỉ mục phức hợp để đảm bảo tính toàn vẹn và tốc độ truy vấn "phẳng hóa" quyền hạn cực nhanh212.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_roles (
-- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINKING)
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
tenant_id UUID NOT NULL,
member_id UUID NOT NULL,
role_id UUID NOT NULL,
-- II. PHẠM VI DỮ LIỆU (DATA SCOPING)
scope_type VARCHAR(50) NOT NULL DEFAULT 'GLOBAL',
scope_values TEXT[] NOT NULL DEFAULT '{}',
-- III. TRUY VẾT (AUDIT)
assigned_by UUID,
assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_ur_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_ur_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,
CONSTRAINT fk_ur_role FOREIGN KEY (role_id) REFERENCES roles(_id) ON DELETE CASCADE,
-- Đảm bảo không gán trùng lặp 1 Role với cùng 1 Scope cho 1 người
CONSTRAINT uq_member_role_scope UNIQUE (member_id, role_id, scope_type),
-- Kiểm tra giá trị hợp lệ cho scope_type
CONSTRAINT chk_ur_scope_type CHECK (scope_type IN ('GLOBAL', 'DEPARTMENT', 'LOCATION', 'PROJECT'))
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index quan trọng nhất: Lấy toàn bộ Role và Scope của nhân viên khi đăng nhập để tính toán quyền (Flattening)
CREATE INDEX idx_ur_member_lookup
ON user_roles (member_id, tenant_id);
-- Index hỗ trợ tìm kiếm: "Ai là Manager của Department X?"
CREATE INDEX idx_ur_scope_search
ON user_roles USING GIN (scope_values)
WHERE scope_type = 'DEPARTMENT';
```
Các điểm nhấn kỹ thuật từ nguồn dữ liệu:
• **UUID v7 & Sharding:** Việc sử dụng UUID v7 cho khóa chính giúp các bản ghi gán quyền mới được phân tán đều trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai khi có đợt cấp quyền hàng loạt cho nhân viên mới413.
• **Phân quyền ma trận (Matrix Authorization):** Thông qua `scope_type` và `scope_values`, hệ thống cho phép một nhân viên làm **Manager ở Phòng IT** nhưng chỉ là **Member ở Phòng Marketing**29.
• **Hiệu năng truy vấn:** Thay vì phải JOIN nhiều bảng trung gian, việc lưu `scope_values` dạng mảng `TEXT[]` giúp API Gateway có thể kiểm tra quyền truy cập tài nguyên của người dùng chỉ với một lần quét index duy nhất112.
• **Tuân thủ GDPR/Security:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một vai trò (`role`) bị xóa hoặc một thành viên (`member`) rời khỏi tổ chức, các bản ghi phân quyền liên quan sẽ bị dọn dẹp sạch sẽ ngay lập tức1014.
**Sự ví von để dễ hiểu:** Bảng `user_roles` giống như một **tờ lệnh điều động nhân sự**. Nó không chỉ ghi tên người và tên chức vụ, mà còn ghi rõ "Anh A làm Trưởng phòng (Role) nhưng chỉ tại chi nhánh Hà Nội (Scope)". Khi anh A đi qua cửa bảo vệ (API Gateway), bảo vệ chỉ cần nhìn tờ lệnh này là biết anh được phép mở những cánh cửa nào trong chi nhánh đó.
thiết kế chi tiết bảng relationship\_tuples dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về mô hình phân quyền dựa trên quan hệ (**ReBAC - Relationship-Based Access Control**) theo kiến trúc **Google Zanzibar** từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **relationship\_tuples** sử dụng YugabyteDB (YSQL)12.
Bảng này đóng vai trò là "trái tim" của hệ thống phân quyền động, cho phép xử lý các kịch bản chia sẻ tài nguyên phức tạp (như chia sẻ thư mục, tài liệu, dự án) với khả năng thừa kế quyền hạn theo chiều sâu13.
1\. Thiết kế chi tiết bảng `relationship_tuples`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Định danh tổ chức sở hữu quan hệ này (SaaS Isolation)2. |
| **namespace** | VARCHAR(50) | NO | | `CHECK (LENGTH(namespace) > 0)` | Loại tài nguyên (Object Namespace) như: `document`, `folder`, `project`2. |
| **object\_id** | UUID | NO | | | Định danh cụ thể của tài nguyên (Sử dụng UUID v7 để tối ưu)2. |
| **relation** | VARCHAR(50) | NO | | | Mối quan hệ như: `viewer`, `editor`, `owner`, `parent`2. |
| **subject\_namespace** | VARCHAR(50) | NO | | | Loại đối tượng được gán quyền: `user`, `group`, hoặc một `folder` (nếu thừa kế)2. |
| **subject\_id** | UUID | NO | | | Định danh của đối tượng (User/Group ID)2. |
| **subject\_relation** | VARCHAR(50) | YES | `NULL` | | Dùng cho quan hệ lồng nhau (VD: "Thành viên của nhóm A")3. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo quan hệ (UTC)3. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này sử dụng **Khóa chính phức hợp (Composite Primary Key)** để tối ưu hóa việc duyệt đồ thị quan hệ và đảm bảo không có các cặp quan hệ trùng lặp3.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE relationship_tuples (
tenant_id UUID NOT NULL,
-- THÔNG TIN TÀI NGUYÊN (OBJECT)
namespace VARCHAR(50) NOT NULL,
object_id UUID NOT NULL,
-- MỐI QUAN HỆ (RELATION)
relation VARCHAR(50) NOT NULL,
-- ĐỐI TƯỢNG NHẬN QUYỀN (SUBJECT)
subject_namespace VARCHAR(50) NOT NULL,
subject_id UUID NOT NULL,
subject_relation VARCHAR(50),
-- THỜI GIAN
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_tuples_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
-- Khóa chính phức hợp tối ưu cho việc truy vấn từ Object sang Subject
PRIMARY KEY (tenant_id, namespace, object_id, relation, subject_namespace, subject_id)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index đảo ngược (Reverse Lookup Index)
-- Hỗ trợ trả lời cực nhanh câu hỏi: "Người dùng A có quyền xem những tài liệu nào?"
CREATE INDEX idx_tuples_reverse_lookup
ON relationship_tuples (tenant_id, subject_id, relation, namespace);
-- Index hỗ trợ kiểm tra quyền theo loại tài nguyên (Namespace)
CREATE INDEX idx_tuples_namespace_lookup
ON relationship_tuples (tenant_id, namespace, relation);
```
Các điểm nhấn kỹ thuật quan trọng:
• **Mô hình Bộ ba (Tuples):** Cấu trúc này cho phép hệ thống phân quyền không chỉ cho người dùng (`user`) mà còn cho cả các nhóm (`group`) hoặc các tài nguyên khác (`folder`), tạo ra khả năng thừa kế quyền hạn (VD: Nếu bạn là editor của Folder A, và Folder A là parent của Doc B, bạn tự động có quyền trên Doc B)13.
• **UUID v7 & Sharding:** Việc sử dụng UUID v7 cho các định danh giúp dữ liệu được sắp xếp tuần tự theo thời gian nhưng vẫn phân tán đều trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai (hotspot) khi có hàng triệu quan hệ được tạo ra45.
• **Hiệu năng thực thi:** Nhờ vào Khóa chính phức hợp và Index đảo ngược, hệ thống có thể thực hiện các phép kiểm tra quyền (Check) và tìm kiếm (Expand) với độ trễ cực thấp ngay cả khi dữ liệu lên tới hàng tỷ bản ghi3.
• **Bảo mật & Toàn vẹn:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một tổ chức (`tenant`) bị xóa, toàn bộ bản đồ quan hệ phức tạp của họ cũng sẽ được dọn dẹp sạch sẽ để đảm bảo an toàn dữ liệu2.
**Sự ví von:** Bảng `relationship_tuples` giống như một **bản đồ các sợi dây liên kết** trong một thư viện khổng lồ. Thay vì dán nhãn tên người lên từng cuốn sách, hệ thống này tạo ra các sợi dây nối giữa "Người" và "Sách", hoặc giữa "Sách" và "Kệ sách". Khi bạn có chìa khóa của "Kệ sách", bạn mặc nhiên có quyền chạm vào mọi cuốn "Sách" được nối với kệ đó qua sợi dây "parent".
thiết kế chi tiết bảng access\_control\_lists dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh và phân quyền (IAM) dành cho Enterprise SaaS trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **access\_control\_lists** (ACL) sử dụng YugabyteDB (YSQL).
Bảng này đóng vai trò quan trọng trong việc cho phép phân quyền chi tiết tới từng tài nguyên cụ thể (như Folder X, Dashboard Y), vượt xa khả năng của mô hình RBAC (Role-based) thông thường1.
1\. Thiết kế chi tiết bảng `access_control_lists`
Bảng được thiết kế theo quy chuẩn **snake\_case**, sử dụng **UUID v7** để tối ưu hóa hiệu năng chèn dữ liệu và sắp xếp theo thời gian trong môi trường phân tán23.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding3. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation)14. |
| **resource\_type** | VARCHAR(50) | NO | | `CHECK (LENGTH(resource_type) > 0)` | Loại tài nguyên (VD: 'DASHBOARD', 'REPORT', 'FOLDER')1. |
| **resource\_id** | UUID | NO | | | ID cụ thể của tài nguyên được phân quyền1. |
| **subject\_type** | VARCHAR(20) | NO | | `CHECK (subject_type IN ('MEMBER', 'GROUP', 'ROLE'))` | Loại đối tượng nhận quyền (Thành viên, Nhóm, hoặc Vai trò)1. |
| **subject\_id** | UUID | NO | | | ID của đối tượng nhận quyền (Member ID hoặc Group ID)1. |
| **action** | VARCHAR(50) | NO | | `CHECK (action IN ('READ', 'WRITE', 'DELETE', 'SHARE'))` | Hành động được phép thực hiện trên tài nguyên1. |
| **is\_allowed** | BOOLEAN | NO | `TRUE` | | `TRUE` là cho phép, `FALSE` là chặn cụ thể (Deny)5. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC) phục vụ truy vết46. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này sử dụng **Composite Unique Constraint** để đảm bảo tính toàn vẹn, tránh việc trùng lặp các quy tắc phân quyền cho cùng một đối tượng5.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_control_lists (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
tenant_id UUID NOT NULL,
-- II. THÔNG TIN TÀI NGUYÊN (RESOURCE)
resource_type VARCHAR(50) NOT NULL,
resource_id UUID NOT NULL,
-- III. THÔNG TIN ĐỐI TƯỢNG (SUBJECT)
subject_type VARCHAR(20) NOT NULL,
subject_id UUID NOT NULL,
-- IV. QUYỀN HẠN
action VARCHAR(50) NOT NULL,
is_allowed BOOLEAN NOT NULL DEFAULT TRUE,
-- V. TRUY VẾT
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- VI. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_acl_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT uq_acl_entry UNIQUE (tenant_id, resource_type, resource_id, subject_type, subject_id, action),
CONSTRAINT chk_acl_subject_type CHECK (subject_type IN ('MEMBER', 'GROUP', 'ROLE')),
CONSTRAINT chk_acl_action CHECK (action IN ('READ', 'WRITE', 'DELETE', 'SHARE'))
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ kiểm tra quyền của một Member đối với một tài nguyên cụ thể (AuthZ Check)
CREATE INDEX idx_acl_lookup
ON access_control_lists (tenant_id, resource_id, subject_id);
-- Index hỗ trợ việc lấy danh sách tất cả các tài nguyên mà một Member/Group có quyền truy cập
CREATE INDEX idx_acl_subject_search
ON access_control_lists (tenant_id, subject_id, subject_type);
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7 và Sharding:** Việc sử dụng UUID v7 làm khóa chính giúp các bản ghi phân quyền mới được phân tán đều trên các node (tablets) của YugabyteDB, tránh hiện tượng "hotspot" khi hệ thống thực hiện cấp quyền hàng loạt78.
• **Phân quyền Tài nguyên (Resource-level):** Bảng này cho phép xây dựng các tính năng như "Chia sẻ thư mục" hay "Phân quyền báo cáo" cho từng cá nhân, điều mà các vai trò hệ thống (Global Roles) không làm được15.
• **Tính nhất quán mạnh (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant hoặc Member bị xóa, các bản ghi quyền hạn liên quan sẽ bị xóa bỏ ngay lập tức, tránh dữ liệu rác và đảm bảo an ninh910.
• **Hiệu năng truy vấn:** Bằng cách sử dụng **Composite Index**, hệ thống có thể kiểm tra quyền hạn của người dùng (AuthZ) với độ trễ cực thấp ngay cả khi bảng chứa hàng triệu quy tắc phân quyền1112.
**Ví von:** Bảng `access_control_lists` giống như một **danh sách khách mời chi tiết cho từng phòng** trong một khách sạn lớn (Tenant). Thay vì chỉ có chìa khóa tổng (Role), danh sách này ghi rõ: "Anh An (Subject) được phép vào (Action) phòng 101 (Resource)". Mỗi khi có ai đó định mở cửa, bảo vệ (API Gateway) chỉ cần liếc nhanh qua danh sách này để quyết định có cho qua hay không.
thiết kế chi tiết bảng tenant\_domains dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho doanh nghiệp và quy chuẩn thiết kế SaaS từ các nguồn dữ liệu, bảng **tenant\_domains** đóng vai trò cực kỳ quan trọng trong việc quản lý chủ quyền dữ liệu, giải quyết vấn đề **"Shadow IT"** và bắt buộc thực thi các chính sách bảo mật như SSO trên toàn bộ tên miền của tổ chức12.
Việc sử dụng **UUID v7** giúp hệ thống tối ưu hóa việc sắp xếp theo thời gian và phân tán dữ liệu hiệu quả trên các node của YugabyteDB34.
1\. Thiết kế chi tiết bảng `tenant_domains`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" khi chèn dữ liệu phân tán23. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết đến tổ chức sở hữu tên miền này2. |
| **domain** | VARCHAR(255) | NO | | `UNIQUE`, `CHECK (domain ~ '^[a-z0-9.-]+$')` | Tên miền (VD: `fpt.com`). Phải là duy nhất trên toàn hệ thống để xác định chủ quyền5. |
| **verification\_status** | VARCHAR(20) | NO | `'PENDING'` | `CHECK (status IN ('PENDING', 'VERIFIED'))` | Trạng thái xác minh chủ sở hữu tên miền2. |
| **verification\_method** | VARCHAR(20) | YES | `NULL` | `CHECK (method IN ('DNS_TXT', 'HTML_FILE'))` | Phương thức khách hàng chọn để chứng minh quyền sở hữu (DNS hoặc file HTML)5. |
| **verification\_token** | VARCHAR(100) | YES | `NULL` | | Mã bí mật khách hàng phải cấu hình vào DNS/Web server để hệ thống đối soát2. |
| **policy** | VARCHAR(20) | NO | `'NONE'` | `CHECK (policy IN ('NONE', 'CAPTURE', 'ENFORCE_SSO'))` | **CAPTURE**: Tự động đưa user đăng ký bằng email đuôi này vào Tenant. **ENFORCE\_SSO**: Bắt buộc đăng nhập qua SSO5. |
| **verified\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm xác thực thành công (UTC)56. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm bản ghi được tạo (UTC)26. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Thiết kế này sử dụng các chuẩn mực về kiểu dữ liệu và ràng buộc để đảm bảo tính nhất quán mạnh (Strong Consistency) theo yêu cầu của hệ thống lõi SaaS78.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_domains (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
-- II. THÔNG TIN TÊN MIỀN
domain VARCHAR(255) NOT NULL,
-- III. QUY TRÌNH XÁC THỰC
verification_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
verification_method VARCHAR(20),
verification_token VARCHAR(100),
-- IV. CHÍNH SÁCH HÀNH VI
policy VARCHAR(20) NOT NULL DEFAULT 'NONE',
-- V. TRUY VẾT THỜI GIAN
verified_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- VI. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_domain_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT uq_tenant_domain_name UNIQUE (domain), -- Một domain chỉ thuộc về 1 Tenant duy nhất
CONSTRAINT chk_domain_status CHECK (verification_status IN ('PENDING', 'VERIFIED')),
CONSTRAINT chk_domain_method CHECK (verification_method IN ('DNS_TXT', 'HTML_FILE')),
CONSTRAINT chk_domain_policy CHECK (policy IN ('NONE', 'CAPTURE', 'ENFORCE_SSO')),
CONSTRAINT chk_domain_fmt CHECK (domain ~ '^[a-z0-9.-]+$') -- Chỉ cho phép chữ thường, số, dấu chấm và gạch ngang
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm nhanh Tenant sở hữu một tên miền khi User đăng ký hoặc đăng nhập
CREATE UNIQUE INDEX idx_tenant_domain_lookup
ON tenant_domains (domain)
WHERE verification_status = 'VERIFIED';
-- Index hỗ trợ việc quản lý danh sách domain của một Tenant cụ thể
CREATE INDEX idx_tenant_domain_list
ON tenant_domains (tenant_id);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **Giải quyết Shadow IT:** Thông qua chính sách `CAPTURE`, hệ thống giúp doanh nghiệp kiểm soát mọi tài khoản cá nhân đăng ký bằng email công ty, tự động quy hoạch họ về dưới sự quản lý của tổ chức12.
• **Thực thi SSO (Enforce SSO):** Đây là tính năng "Enterprise-grade". Khi một tên miền đã xác thực được đặt chính sách `ENFORCE_SSO`, bất kỳ người dùng nào sử dụng email thuộc tên miền đó sẽ bị hệ thống chặn đăng nhập bằng mật khẩu thông thường và bắt buộc phải qua cổng SSO (Azure AD, Okta...)59.
• **Tính nhất quán của YugabyteDB:** Việc sử dụng các ràng buộc `UNIQUE` và `CHECK` trực tiếp ở tầng Database đảm bảo rằng dù trong môi trường phân tán, không bao giờ xảy ra tình trạng hai tổ chức khác nhau tranh chấp cùng một tên miền1011.
**Ví von:** Bảng `tenant_domains` giống như một **quyển sổ đỏ xác nhận chủ quyền đất đai** trên không gian số. Khi một tổ chức đã "cắm cọc" và xác thực thành công mảnh đất tên miền của mình, họ có toàn quyền quyết định ai được phép vào (Capture) và phải đi vào bằng cửa nào (SSO), ngăn chặn việc người lạ hoặc nhân viên tự ý "xây nhà" trái phép trên email công ty25.
thiết kế chi tiết bảng tenant\_invitations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho doanh nghiệp và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, bảng **tenant\_invitations** đóng vai trò quản lý quy trình mời người dùng mới tham gia vào tổ chức (Onboarding) một cách an toàn và chuyên nghiệp1,2.
Việc sử dụng **UUID v7** cho định danh giúp tối ưu hóa việc phân tán dữ liệu trên các node của YugabyteDB và đảm bảo tính tuần tự theo thời gian3,4.
1\. Thiết kế chi tiết bảng `tenant_invitations`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp thời gian3,5. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định lời mời thuộc về tổ chức nào (SaaS Isolation)2,6. |
| **email** | VARCHAR(255) | NO | | `CHECK (email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$')` | Email của người nhận lời mời2,6. |
| **role\_ids** | TEXT\[\] | YES | `'{}'` | | Mảng chứa các mã vai trò (Roles) dự kiến gán cho người dùng sau khi chấp nhận2,6. |
| **department\_id** | UUID | YES | `NULL` | | Phòng ban dự kiến người mới sẽ tham gia2,6. |
| **token** | VARCHAR(100) | NO | | `UNIQUE` | Mã bí mật duy nhất đính kèm trong link mời gửi qua email2,6. |
| **status** | VARCHAR(20) | NO | `'PENDING'` | `CHECK (status IN ('PENDING', 'ACCEPTED', 'EXPIRED', 'REVOKED'))` | Trạng thái của lời mời (Chờ, Đã nhận, Hết hạn hoặc Bị thu hồi)2,6. |
| **expires\_at** | TIMESTAMPTZ | NO | | `CHECK (expires_at > created_at)` | Thời điểm link hết hạn (UTC)7,6. |
| **invited\_by** | UUID | YES | `NULL` | | ID của người gửi lời mời để phục vụ truy vết (Audit)2,6. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo lời mời (UTC)2. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Dưới đây là các câu lệnh SQL được thiết kế tối ưu cho môi trường YugabyteDB, tuân thủ quy tắc đặt tên `snake_case` và tính toàn vẹn dữ liệu8,9.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_invitations (
-- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINKING)
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
tenant_id UUID NOT NULL,
-- II. THÔNG TIN NGƯỜI NHẬN & VAI TRÒ
email VARCHAR(255) NOT NULL,
role_ids TEXT[] DEFAULT '{}',
department_id UUID,
-- III. KIỂM SOÁT XÁC THỰC & TRẠNG THÁI
token VARCHAR(100) NOT NULL,
status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
expires_at TIMESTAMPTZ NOT NULL,
-- IV. TRUY VẾT (AUDIT)
invited_by UUID,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_invitation_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT uq_invitation_token UNIQUE (token),
CONSTRAINT chk_invitation_status CHECK (status IN ('PENDING', 'ACCEPTED', 'EXPIRED', 'REVOKED')),
CONSTRAINT chk_invitation_email_fmt CHECK (email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$'),
CONSTRAINT chk_invitation_expiry CHECK (expires_at > created_at)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm kiếm nhanh khi người dùng click vào link mời (Token Lookup)
CREATE UNIQUE INDEX idx_invitation_token_lookup
ON tenant_invitations (token)
WHERE status = 'PENDING';
-- Index hỗ trợ Admin quản lý danh sách lời mời của một Tenant (Theo dõi tiến độ Onboarding)
CREATE INDEX idx_invitation_tenant_list
ON tenant_invitations (tenant_id, created_at DESC);
-- Index hỗ trợ Job dọn dẹp hoặc tự động cập nhật trạng thái hết hạn
CREATE INDEX idx_invitation_expiry_cleanup
ON tenant_invitations (expires_at)
WHERE status = 'PENDING' AND expires_at < NOW();
```
Các lưu ý kỹ thuật từ nguồn dữ liệu:
• **Bảo mật Token:** Trường `token` cần được sinh ngẫu nhiên với độ phức tạp cao để tránh bị tấn công đoán mã (brute-force).2.
• **Quy trình Onboarding:** Theo phân tích, khi một lời mời được chuyển sang trạng thái `ACCEPTED`, hệ thống nên sử dụng dữ liệu từ `role_ids` và `department_id` để tự động tạo bản ghi trong bảng `tenant_members` và `user_roles`.2,10.
• **SaaS Isolation:** Việc bắt buộc có `tenant_id` và ràng buộc `ON DELETE CASCADE` đảm bảo rằng nếu một tổ chức ngừng sử dụng dịch vụ và bị xóa, tất cả các lời mời chưa được chấp nhận sẽ bị xóa sạch theo để đảm bảo an toàn dữ liệu.11,12.
**Sự ví von:** Bảng `tenant_invitations` giống như một **tấm vé mời tham quan VIP** của một tòa nhà văn phòng. Tấm vé ghi rõ người nhận (`email`), những phòng được phép vào (`role_ids`) và có một mã vạch duy nhất (`token`). Nếu người cầm vé không đến trước giờ đóng cửa (`expires_at`), tấm vé sẽ tự động vô hiệu hóa để bảo vệ an ninh cho tòa nhà.
thiết kế chi tiết bảng access\_reviews dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh và tuân thủ bảo mật (Governance & Compliance) cho Enterprise SaaS như ISO 27001/SOC2 trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **access\_reviews** sử dụng YugabyteDB (YSQL)1,2.
Bảng này đóng vai trò quản lý các đợt rà soát quyền hạn định kỳ, giúp các trưởng bộ phận (Manager) kiểm tra và xác nhận xem nhân viên còn cần các quyền hạn hiện tại hay không, từ đó giảm thiểu rủi ro "thừa quyền"1.
1\. Thiết kế chi tiết bảng `access_reviews`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh đợt rà soát. Sử dụng **UUID v7** (sinh từ tầng App) để tối ưu hóa sắp xếp và sharding3,4,1. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation). Mỗi Tenant quản lý các đợt rà soát riêng5,1. |
| **name** | VARCHAR(255) | NO | | `CHECK (LENGTH(name) > 0)` | Tên đợt rà soát (VD: "Rà soát quyền hạn Q4/2024")1. |
| **description** | TEXT | YES | `NULL` | | Mô tả chi tiết mục tiêu hoặc phạm vi của đợt rà soát này. |
| **status** | VARCHAR(20) | NO | `'PENDING'` | `CHECK (status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'))` | Trạng thái của đợt rà soát1. |
| **deadline** | TIMESTAMPTZ | NO | | | Thời hạn cuối cùng phải hoàn thành việc rà soát1. |
| **created\_by** | UUID | NO | | `REFERENCES users(_id)` | Người khởi tạo đợt rà soát (thường là Security Admin)6. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo đợt rà soát (UTC)7,5. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật trạng thái gần nhất6. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để tránh xung đột khi nhiều Admin cùng điều chỉnh cấu hình8. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Thiết kế này tuân thủ các quy tắc về kiểu dữ liệu (TIMESTAMPTZ, UUID) và quy tắc đặt tên `snake_case` từ các nguồn dữ liệu9,4,10.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_reviews (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application để tối ưu hiệu năng ghi
tenant_id UUID NOT NULL,
-- II. THÔNG TIN NGHIỆP VỤ
name VARCHAR(255) NOT NULL,
description TEXT,
status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
-- III. KIỂM SOÁT THỜI GIAN & PHIÊN BẢN
deadline TIMESTAMPTZ NOT NULL,
created_by UUID NOT NULL,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_access_review_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_access_review_creator FOREIGN KEY (created_by) REFERENCES users(_id),
CONSTRAINT chk_review_status CHECK (status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED')),
CONSTRAINT chk_review_dates CHECK (updated_at >= created_at),
CONSTRAINT chk_review_version CHECK (version >= 1),
CONSTRAINT chk_review_name_len CHECK (LENGTH(name) > 0)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm kiếm các đợt rà soát của một Tenant (Sắp xếp theo thời gian mới nhất)
CREATE INDEX idx_access_reviews_tenant_lookup
ON access_reviews (tenant_id, created_at DESC);
-- Index hỗ trợ hệ thống quản trị theo dõi các đợt rà soát sắp đến hạn
-- Giúp chạy các Background Jobs gửi thông báo nhắc nhở (Reminder)
CREATE INDEX idx_access_reviews_deadline
ON access_reviews (status, deadline)
WHERE status IN ('PENDING', 'IN_PROGRESS');
```
Các điểm nhấn kỹ thuật theo nguồn dữ liệu:
• **UUID v7 cho Khóa chính:** Việc sử dụng UUID v7 giúp các bản ghi được sắp xếp tuần tự theo thời gian, tránh hiện tượng "hotspot" trong kiến trúc Distributed SQL của YugabyteDB, giúp tốc độ chèn dữ liệu nhanh hơn so với UUID v44,11.
• **Tính nhất quán mạnh (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant ngừng sử dụng dịch vụ và bị xóa, tất cả dữ liệu rà soát nhạy cảm của họ cũng sẽ được dọn dẹp sạch sẽ để tuân thủ bảo mật12.
• **Audit Trail:** Cột `created_by` và `updated_at` kết hợp với các bảng log ở ClickHouse sẽ tạo thành một bằng chứng pháp lý vững chắc khi doanh nghiệp thực hiện các cuộc kiểm toán (Audit) hàng năm5,13.
• **SaaS Isolation:** Trường `tenant_id` được đưa vào đầu của các Index phức hợp (Composite Index) để đảm bảo mọi truy vấn của khách hàng luôn được giới hạn trong phạm vi dữ liệu của họ, tối ưu hiệu năng sharding5,14.
**Ví dụ trực quan:** Bảng `access_reviews` giống như một **"Lịch tổng kiểm kho"** của một trung tâm thương mại (Tenant). Nó không ghi chi tiết từng món đồ, mà ghi lại kế hoạch: Ai thực hiện kiểm kê (`created_by`), tên đợt kiểm kê là gì (`name`), và khi nào thì phải nộp báo cáo xong (`deadline`). Nếu kế hoạch thay đổi, hệ thống sẽ tự động cập nhật phiên bản (`version`) để đảm bảo các quản lý không làm việc trên các dữ liệu cũ.
thiết kế chi tiết bảng access\_review\_items dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và tuân thủ bảo mật (ISO 27001/SOC2) dành cho Enterprise SaaS, dưới đây là thiết kế chi tiết cho bảng **access\_review\_items** sử dụng YugabyteDB (YSQL)1,2.
Bảng này lưu trữ chi tiết từng mục cần rà soát trong một đợt kiểm tra quyền hạn, giúp các cấp quản lý xác định liệu một nhân viên có nên tiếp tục giữ vai trò hiện tại hay không3,4.
1\. Thiết kế chi tiết bảng `access_review_items`
Việc sử dụng **UUID v7** làm khóa chính đảm bảo tính phân tán, tránh hiện tượng "hotspot" trên các node dữ liệu và hỗ trợ sắp xếp theo thời gian một cách tự nhiên5,6.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**5,7. |
| **review\_id** | UUID | NO | | `REFERENCES access_reviews(_id) ON DELETE CASCADE` | Liên kết với đợt rà soát tổng thể3. |
| **reviewer\_id** | UUID | NO | | `REFERENCES tenant_members(_id)` | Người chịu trách nhiệm rà soát (thường là Manager trực tiếp)3. |
| **target\_member\_id** | UUID | NO | | `REFERENCES tenant_members(_id)` | Nhân viên đang được kiểm tra quyền hạn3. |
| **role\_id** | UUID | NO | | `REFERENCES roles(_id)` | Vai trò cụ thể đang được xem xét để giữ lại hoặc thu hồi3. |
| **decision** | VARCHAR(20) | NO | `'PENDING'` | `CHECK (decision IN ('PENDING', 'KEEP', 'REVOKE'))` | Quyết định: Đang chờ, Giữ lại, hoặc Thu hồi quyền3. |
| **reason** | TEXT | YES | `NULL` | | Lý do cho quyết định (bắt buộc nếu chọn `REVOKE`)3. |
| **reviewed\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm người rà soát thực hiện xác nhận8,3. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm mục rà soát được tạo (UTC)9. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật trạng thái mục rà soát10. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh này tuân thủ quy chuẩn `snake_case` và các ràng buộc toàn vẹn dữ liệu để đảm bảo tính nhất quán mạnh (Strong Consistency) trong môi trường phân tán11,2.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_review_items (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
review_id UUID NOT NULL,
reviewer_id UUID NOT NULL,
target_member_id UUID NOT NULL,
role_id UUID NOT NULL,
-- II. QUYẾT ĐỊNH RÀ SOÁT
decision VARCHAR(20) NOT NULL DEFAULT 'PENDING',
reason TEXT,
reviewed_at TIMESTAMPTZ,
-- III. TRUY VẾT THỜI GIAN
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_item_review FOREIGN KEY (review_id) REFERENCES access_reviews(_id) ON DELETE CASCADE,
CONSTRAINT fk_item_reviewer FOREIGN KEY (reviewer_id) REFERENCES tenant_members(_id),
CONSTRAINT fk_item_target FOREIGN KEY (target_member_id) REFERENCES tenant_members(_id),
CONSTRAINT fk_item_role FOREIGN KEY (role_id) REFERENCES roles(_id),
CONSTRAINT chk_item_decision CHECK (decision IN ('PENDING', 'KEEP', 'REVOKE')),
CONSTRAINT chk_item_dates CHECK (updated_at >= created_at)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ trang Dashboard của người rà soát: "Lấy tất cả mục tôi cần xử lý trong đợt này"
CREATE INDEX idx_review_items_reviewer_task
ON access_review_items (reviewer_id, review_id)
WHERE decision = 'PENDING';
-- Index hỗ trợ báo cáo tiến độ: "Có bao nhiêu mục đã hoàn thành trong đợt rà soát X?"
CREATE INDEX idx_review_items_status
ON access_review_items (review_id, decision);
-- Index hỗ trợ lịch sử nhân viên: "Nhân viên A đã từng bị thu hồi những quyền gì trong quá khứ?"
CREATE INDEX idx_review_items_target_history
ON access_review_items (target_member_id)
WHERE decision = 'REVOKE';
```
Các lưu ý kỹ thuật quan trọng từ nguồn dữ liệu:
• **Tính toàn vẹn (ACID):** Việc sử dụng YugabyteDB giúp đảm bảo rằng khi một đợt rà soát bị hủy, tất cả các mục (`items`) liên quan sẽ bị xóa sạch thông qua ràng buộc `ON DELETE CASCADE`, tránh dữ liệu rác trong hệ thống2,12.
• **Tuân thủ (Compliance):** Trường `reviewed_at` và `reviewer_id` cung cấp bằng chứng pháp lý (Audit Trail) cho các cuộc kiểm toán bảo mật, xác định rõ ai là người đã phê duyệt quyền hạn vào thời điểm nào13,14.
• **Hiệu năng Sharding:** Sử dụng UUID v7 làm khóa chính giúp phân tán các mục rà soát đều trên toàn bộ cluster, cực kỳ hữu ích khi một doanh nghiệp lớn thực hiện rà soát quyền cho hàng vạn nhân viên cùng lúc6,7.
• **Phân tách mối quan tâm:** Bảng này chỉ tập trung vào việc "phê duyệt" quyền, trong khi logic thực thi (thu hồi quyền thực tế) thường được xử lý bởi một Worker chạy ngầm sau khi đợt rà soát kết thúc15,16.
**Sự ví von:** Bảng `access_review_items` giống như một **danh sách kiểm tra (checklist) trong một kỳ thi**. Đợt rà soát (`review_id`) là kỳ thi tổng thể, còn mỗi dòng trong bảng là một câu hỏi dành cho giám thị (`reviewer_id`) về việc một thí sinh cụ thể (`target_member_id`) có đủ tư cách sử dụng một loại tài liệu (`role_id`) hay không. Mọi câu trả lời và lý do đều được ghi lại vĩnh viễn để phục vụ thanh tra về sau.
thiết kế chi tiết bảng scim\_directories dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh doanh nghiệp (IdP) và chuẩn SCIM 2.0 (System for Cross-domain Identity Management) dành cho phân khúc Enterprise SaaS từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **scim\_directories** sử dụng YugabyteDB (YSQL).
Bảng này đóng vai trò là "cổng chờ" tiếp nhận các yêu cầu đồng bộ hóa người dùng tự động từ các hệ thống như Azure AD, Okta hay OneLogin vào hệ thống SaaS của bạn1,2.
1\. Thiết kế chi tiết bảng `scim_directories` (YSQL)
Việc sử dụng **UUID v7** giúp tối ưu hóa hiệu năng ghi phân tán trên YugabyteDB bằng cách duy trì tính tuần tự theo thời gian, tránh hiện tượng "hotspot" khi có nhiều khách hàng Enterprise cùng thiết lập kết nối3,4.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp dữ liệu theo thời gian thực3,2. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu kết nối thư mục này (SaaS Isolation)5,2. |
| **provider\_type** | VARCHAR(20) | NO | | `CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'ONELOGIN', 'CUSTOM'))` | Loại nhà cung cấp định danh (IdP) như Azure AD, Okta...2. |
| **scim\_token\_hash** | TEXT | NO | | `UNIQUE` | **Bản băm** của Bearer Token dùng để xác thực các request SCIM từ IdP gửi đến2. |
| **is\_active** | BOOLEAN | NO | `TRUE` | | Trạng thái kích hoạt của kết nối2. |
| **last\_synced\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm cuối cùng IdP thực hiện đồng bộ dữ liệu2. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo cấu hình kết nối (UTC)6,2. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** khi cập nhật cấu hình7. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Dưới đây là mã lệnh YSQL để triển khai bảng và các chỉ mục chiến lược. Lưu ý rằng `scim_token_hash` cần được đánh chỉ mục để hệ thống xác thực nhanh các request API SCIM đổ vào2.
```
-- 1. Câu lệnh tạo bảng scim_directories
CREATE TABLE scim_directories (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
-- II. CẤU HÌNH KẾT NỐI
provider_type VARCHAR(20) NOT NULL,
scim_token_hash TEXT NOT NULL,
-- III. TRẠNG THÁI & TRUY VẾT
is_active BOOLEAN NOT NULL DEFAULT TRUE,
last_synced_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_scim_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT uq_scim_token_hash UNIQUE (scim_token_hash),
CONSTRAINT chk_scim_provider CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'ONELOGIN', 'CUSTOM')),
CONSTRAINT chk_scim_version CHECK (version >= 1)
);
-- 2. Chiến lược đánh Index (Indexing Strategy)
-- Index hỗ trợ xác thực cực nhanh khi IdP gọi API SCIM (Bearer Token Lookup)
-- Truy vấn: SELECT tenant_id FROM scim_directories WHERE scim_token_hash = ? AND is_active = TRUE;
CREATE INDEX idx_scim_auth_lookup
ON scim_directories (scim_token_hash)
WHERE is_active = TRUE;
-- Index hỗ trợ trang quản trị: Hiển thị danh sách kết nối thư mục của một Tenant
CREATE INDEX idx_scim_tenant_list
ON scim_directories (tenant_id);
```
Các điểm nhấn kỹ thuật quan trọng:
• **Security (Bảo mật):** Tương tự như mật khẩu, chúng ta chỉ lưu `scim_token_hash`. Hệ thống sẽ không bao giờ hiển thị lại token gốc sau khi tạo để đảm bảo an toàn2.
• **SCIM Provisioning:** Bảng này là nền tảng để hỗ trợ tính năng tự động tạo/xóa người dùng từ Azure AD/Okta. Khi một nhân viên nghỉ việc ở phía khách hàng, hệ thống của họ sẽ tự động gọi đến endpoint SCIM của bạn, và bảng này giúp định tuyến request đó về đúng `tenant_id`1,2.
• **Performance (Hiệu năng):** Việc sử dụng `TIMESTAMPTZ` đảm bảo tính chính xác về thời gian đồng bộ hóa trên toàn cầu, đặc biệt quan trọng cho các tập đoàn đa quốc gia sử dụng các Shard dữ liệu khác nhau6,8.
**Sự ví von để dễ hiểu:** Bảng `scim_directories` giống như một **"tổng đài nội bộ"** kết nối trực tiếp với văn phòng chính (IdP của khách hàng). Khi văn phòng chính có nhân viên mới hoặc ai đó nghỉ việc, họ chỉ cần nhấc máy gọi qua "đường dây riêng" này (SCIM Token), và tổng đài sẽ tự động cập nhật danh sách nhân sự trong tòa nhà của bạn mà bạn không cần phải làm gì thủ công.
thiết kế chi tiết bảng scim\_mappings dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống SCIM 2.0 (System for Cross-domain Identity Management) dành cho phân khúc Enterprise SaaS và các quy chuẩn kỹ thuật YSQL từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **scim\_mappings**.
Bảng này đóng vai trò là "bản đồ ánh xạ" giữa định danh của hệ thống bên ngoài (như Azure AD, Okta) và định danh nội bộ của hệ thống SaaS, giúp tự động hóa quy trình cung cấp (Provisioning) và thu hồi (Deprovisioning) tài khoản1,2.
1\. Thiết kế chi tiết bảng `scim_mappings` (YSQL)
Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa việc sắp xếp theo thời gian và hiệu năng ghi phân tán trên YugabyteDB3,4.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**5,3. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu ánh xạ này để đảm bảo cô lập dữ liệu (SaaS Isolation)6,7. |
| **directory\_id** | UUID | NO | | `REFERENCES scim_directories(_id) ON DELETE CASCADE` | Liên kết với cấu hình kết nối thư mục SCIM cụ thể2. |
| **external\_id** | VARCHAR(255) | NO | | | ID của đối tượng (User/Group) được cung cấp bởi hệ thống IdP bên ngoài (Azure AD/Okta)2. |
| **internal\_entity\_type** | VARCHAR(20) | NO | | `CHECK (internal_entity_type IN ('USER', 'GROUP'))` | Phân loại đối tượng ánh xạ là Người dùng hoặc Nhóm2. |
| **internal\_entity\_id** | UUID | NO | | | ID của đối tượng tương ứng trong hệ thống nội bộ (trỏ đến `users` hoặc `user_groups`)2. |
| **data\_hash** | VARCHAR(64) | YES | `NULL` | | Mã băm (Checksum) để so sánh và phát hiện thay đổi dữ liệu từ lần đồng bộ trước2. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật ánh xạ lần cuối (UTC)8,2. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn trong môi trường phân tán của YugabyteDB9,10.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE scim_mappings (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
directory_id UUID NOT NULL,
-- II. THÔNG TIN ÁNH XẠ (MAPPING DATA)
external_id VARCHAR(255) NOT NULL,
internal_entity_type VARCHAR(20) NOT NULL,
internal_entity_id UUID NOT NULL,
-- III. TRUY VẾT & ĐỒNG BỘ
data_hash VARCHAR(64),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_scim_map_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_scim_map_dir FOREIGN KEY (directory_id) REFERENCES scim_directories(_id) ON DELETE CASCADE,
CONSTRAINT chk_scim_entity_type CHECK (internal_entity_type IN ('USER', 'GROUP')),
-- Đảm bảo một đối tượng ngoại không bị ánh xạ trùng lặp cho một thư mục
CONSTRAINT uq_scim_external_lookup UNIQUE (directory_id, external_id, internal_entity_type)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm nhanh thực thể nội bộ khi nhận được request từ IdP (Provisioning)
-- Query: SELECT internal_entity_id FROM scim_mappings WHERE directory_id = ? AND external_id = ?;
CREATE UNIQUE INDEX idx_scim_external_sync
ON scim_mappings (directory_id, external_id, internal_entity_type);
-- Index hỗ trợ tìm ngược từ hệ thống nội bộ để gửi update sang IdP (Deprovisioning)
-- Query: SELECT external_id FROM scim_mappings WHERE internal_entity_id = ?;
CREATE INDEX idx_scim_internal_lookup
ON scim_mappings (internal_entity_id);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **UUID v7 làm Khóa chính:** Giúp các bản ghi ánh xạ mới được tạo ra (thường là hàng loạt khi bắt đầu đồng bộ thư mục) được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ tính chất tuần tự theo thời gian để tối ưu hóa việc lưu trữ và lập chỉ mục3,4.
• **Unique Constraint (uq\_scim\_external\_lookup):** Đây là ràng buộc "sinh tử" để ngăn chặn tình trạng một User bên Azure AD bị ánh xạ nhầm vào hai User khác nhau trong hệ thống SaaS, đảm bảo tính nhất quán mạnh (Strong Consistency)11.
• **Khả năng mở rộng (Scalability):** Bằng cách lưu `data_hash`, hệ thống có thể thực hiện "Delta Sync" – chỉ cập nhật những đối tượng có thay đổi thực sự, giúp giảm tải đáng kể cho API và Database trong các đợt đồng bộ quy mô lớn (hàng chục ngàn nhân viên)2.
• **Cô lập Tenant:** Ràng buộc `ON DELETE CASCADE` với `tenant_id` đảm bảo tuân thủ quyền được quên và dọn dẹp dữ liệu sạch sẽ khi khách hàng Enterprise ngừng sử dụng dịch vụ12,2.
**Sự ví von:** Bảng `scim_mappings` giống như một **cuốn sổ hộ chiếu (Passport Log)**. Khi một người từ quốc gia khác (IdP bên ngoài) nhập cảnh vào "quốc gia SaaS" của bạn, cuốn sổ này sẽ ghi nhận: "Số hộ chiếu X của Azure AD tương ứng với Mã công dân Y của hệ thống chúng ta". Mỗi khi người này thay đổi thông tin ở quê nhà, hệ thống chỉ cần tra sổ này để cập nhật đúng cho "công dân" đó mà không bị nhầm lẫn với người khác2,11.
thiết kế chi tiết bảng tenant\_security\_policies dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống bảo mật dành cho Enterprise SaaS và quy chuẩn kỹ thuật YSQL (YugabyteDB) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenant\_security\_policies**.
Bảng này đóng vai trò quan trọng trong việc cho phép từng khách hàng doanh nghiệp (Tenant) tự định nghĩa các tiêu chuẩn an ninh riêng biệt, đáp ứng các yêu cầu khắt khe về tuân thủ bảo mật như NIST, HIPAA hoặc các chính sách nội bộ của ngân hàng1.
1\. Thiết kế chi tiết bảng `tenant_security_policies`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO | | `PRIMARY KEY`, `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu chính sách. Sử dụng làm Khóa chính để đảm bảo mỗi Tenant chỉ có một bộ quy tắc1. |
| **pwd\_min\_length** | INT | NO | `8` | `CHECK (pwd_min_length >= 6)` | Độ dài tối thiểu của mật khẩu1. |
| **pwd\_require\_special\_char** | BOOLEAN | NO | `TRUE` | | Bắt buộc mật khẩu phải chứa ký tự đặc biệt1. |
| **pwd\_expiry\_days** | INT | NO | `0` | `CHECK (pwd_expiry_days >= 0)` | Số ngày mật khẩu hết hạn (0 là không bao giờ hết hạn)1. |
| **pwd\_history\_limit** | INT | NO | `3` | `CHECK (pwd_history_limit >= 0)` | Số lượng mật khẩu cũ gần nhất không được phép trùng lặp khi đổi mới12. |
| **session\_timeout\_minutes** | INT | NO | `1440` | `CHECK (session_timeout_minutes > 0)` | Thời gian hết hạn phiên làm việc (mặc định 24h)1. |
| **max\_login\_attempts** | INT | NO | `5` | `CHECK (max_login_attempts > 0)` | Số lần đăng nhập sai tối đa trước khi bị khóa tài khoản1. |
| **lockout\_duration\_minutes** | INT | NO | `30` | `CHECK (lockout_duration_minutes >= 0)` | Thời gian tài khoản bị khóa sau khi thử sai quá số lần quy định1. |
| **mfa\_enforced** | BOOLEAN | NO | `FALSE` | | Cờ bắt buộc tất cả thành viên trong Tenant phải bật xác thực 2 yếu tố1. |
| **allowed\_ip\_ranges** | CIDR\[\] | YES | `NULL` | | Mảng danh sách các dải IP được phép truy cập (IP Whitelist)2. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật chính sách gần nhất (UTC)1. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này sử dụng các kiểu dữ liệu tối ưu của YugabyteDB như **TIMESTAMPTZ** cho thời gian và **CIDR\[\]** cho mạng, giúp hệ thống kiểm tra quyền truy cập nhanh chóng ngay tại tầng cơ sở dữ liệu23.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_security_policies (
-- I. ĐỊNH DANH (IDENTITY)
-- Sử dụng chính tenant_id làm PK để thực thi quan hệ 1-1 và tối ưu sharding theo Tenant
tenant_id UUID PRIMARY KEY,
-- II. CHÍNH SÁCH MẬT KHẨU (PASSWORD POLICY)
pwd_min_length INT NOT NULL DEFAULT 8,
pwd_require_special_char BOOLEAN NOT NULL DEFAULT TRUE,
pwd_expiry_days INT NOT NULL DEFAULT 0,
pwd_history_limit INT NOT NULL DEFAULT 3,
-- III. CHÍNH SÁCH PHIÊN & ĐĂNG NHẬP (LOGIN & SESSION)
session_timeout_minutes INT NOT NULL DEFAULT 1440,
max_login_attempts INT NOT NULL DEFAULT 5,
lockout_duration_minutes INT NOT NULL DEFAULT 30,
-- IV. BẢO MẬT NÂNG CAO (ADVANCED SECURITY)
mfa_enforced BOOLEAN NOT NULL DEFAULT FALSE,
allowed_ip_ranges CIDR[], -- Lưu mảng dải IP Whitelist
-- V. TRUY VẾT (AUDIT)
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- VI. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_policy_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT chk_pwd_len CHECK (pwd_min_length >= 6),
CONSTRAINT chk_pwd_expiry CHECK (pwd_expiry_days >= 0),
CONSTRAINT chk_login_attempts CHECK (max_login_attempts > 0),
CONSTRAINT chk_session_timeout CHECK (session_timeout_minutes > 0)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Do tenant_id là PRIMARY KEY, YugabyteDB đã tự động tạo Index B-tree tối ưu.
-- Thêm index cho cập nhật thời gian nếu cần thực hiện các báo cáo tuân thủ (Compliance Audit)
CREATE INDEX idx_security_policies_updated ON tenant_security_policies (updated_at DESC);
```
Giải thích kỹ thuật bổ sung từ nguồn dữ liệu:
• **UUID v7 và Sharding:** Việc sử dụng UUID cho `tenant_id` (vốn đã được sinh theo chuẩn v7 từ bảng `tenants`) giúp dữ liệu chính sách được phân tán đều trên các máy chủ trong cụm YugabyteDB, tránh hiện tượng "Hotspot" khi nhiều Tenant cùng truy cập cấu hình bảo mật lúc đăng nhập45.
• **Cơ chế Whitelist IP:** Sử dụng kiểu dữ liệu `CIDR[]` cho phép hệ thống kiểm tra nhanh chóng địa chỉ IP của người dùng bằng các toán tử mạng của PostgreSQL/YSQL (như `>>=` hoặc `<<=`), giúp ngăn chặn truy cập trái phép từ các vùng mạng lạ ngay tại cổng vào2.
• **Tính nhất quán mạnh (ACID):** Mọi thay đổi về chính sách mật khẩu hoặc bắt buộc MFA được thực thi với tính nhất quán cao, đảm bảo rằng ngay khi Admin lưu cấu hình, tất cả các node trong hệ thống phân tán đều áp dụng quy tắc mới ngay lập tức cho các lần đăng nhập tiếp theo6.
**Ví dụ trực quan:** Bảng `tenant_security_policies` giống như một **"Bộ nội quy ra vào tòa nhà"** dành riêng cho mỗi văn phòng trong một cao ốc lớn. Thay vì dùng chung một quy định, mỗi công ty có thể tự quyết định khóa cửa sau bao lâu (Session timeout), chìa khóa phải dài bao nhiêu (Password length) và có bắt buộc phải quẹt thẻ vân tay (MFA) hay không.
thiết kế chi tiết bảng legal\_documents dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và tuân thủ pháp lý (Legal Compliance) cho Enterprise SaaS từ các nguồn dữ liệu, bảng **legal\_documents** đóng vai trò lưu trữ các phiên bản văn bản pháp lý như Điều khoản sử dụng (ToS) hoặc Chính sách bảo mật (Privacy Policy)1.
Việc thiết kế bảng này yêu cầu tính nhất quán cao và khả năng truy vết chính xác để chứng minh sự đồng ý của người dùng đối với một phiên bản cụ thể tại một thời điểm nhất định12.
1\. Thiết kế chi tiết bảng `legal_documents`
Bảng sử dụng chuẩn **UUID v7** cho khóa chính để tối ưu hóa việc sắp xếp theo thời gian và hiệu năng ghi phân tán trên YugabyteDB13.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian thực34. |
| **type** | VARCHAR(50) | NO | | `CHECK (type IN ('TERMS_OF_SERVICE', 'PRIVACY_POLICY', 'COOKIE_POLICY', 'EULA'))` | Phân loại loại văn bản pháp lý1. |
| **version** | VARCHAR(20) | NO | | | Phiên bản của văn bản (VD: 'v1.0', '2024-JAN')1. |
| **title** | TEXT | NO | | `CHECK (LENGTH(title) > 0)` | Tiêu đề hiển thị của văn bản. |
| **content\_url** | TEXT | NO | | `CHECK (content_url ~* '^https?://')` | Đường dẫn đến nội dung văn bản trên Object Storage. Dùng **TEXT** thay vì VARCHAR(255) để tránh rủi ro URL dài1.... |
| **is\_active** | BOOLEAN | NO | `FALSE` | | Đánh dấu phiên bản hiện hành. Chỉ một phiên bản trên mỗi loại được là TRUE1. |
| **published\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm công bố văn bản chính thức (UTC)17. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi trong hệ thống8. |
| **version\_locking** | BIGINT | NO | `1` | | Cơ chế **Optimistic Locking** để tránh xung đột khi cập nhật9. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và Index
Thiết kế này sử dụng **Partial Index** và **Unique Constraint** phức hợp để đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cao nhất cho hệ thống SaaS110.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE legal_documents (
-- I. ĐỊNH DANH & PHIÊN BẢN
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
type VARCHAR(50) NOT NULL,
version VARCHAR(20) NOT NULL,
-- II. NỘI DUNG
title TEXT NOT NULL,
content_url TEXT NOT NULL,
-- III. TRẠNG THÁI & THỜI GIAN
is_active BOOLEAN NOT NULL DEFAULT FALSE,
published_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version_locking BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
-- Đảm bảo không trùng lặp phiên bản cho cùng một loại văn bản
CONSTRAINT uq_doc_type_version UNIQUE (type, version),
-- Kiểm tra loại văn bản hợp lệ
CONSTRAINT chk_legal_type CHECK (type IN ('TERMS_OF_SERVICE', 'PRIVACY_POLICY', 'COOKIE_POLICY', 'EULA')),
-- Kiểm tra định dạng URL cơ bản
CONSTRAINT chk_legal_url_fmt CHECK (content_url ~* '^https?://')
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ lấy nhanh phiên bản đang hoạt động (Partial Index)
-- Query: SELECT * FROM legal_documents WHERE type = 'TERMS_OF_SERVICE' AND is_active = TRUE;
CREATE UNIQUE INDEX idx_legal_active_version
ON legal_documents (type)
WHERE is_active = TRUE;
-- Index hỗ trợ tra cứu lịch sử thay đổi của một loại văn bản theo thời gian
CREATE INDEX idx_legal_history_lookup
ON legal_documents (type, published_at DESC);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **Tuân thủ Legal & Compliance:** Việc lưu trữ rõ ràng `type` và `version` kết hợp với bảng `user_consents` (sau này) cho phép doanh nghiệp cung cấp bằng chứng kỹ thuật (Audit Trail) rằng người dùng đã đồng ý với phiên bản pháp lý nào tại thời điểm nào12.
• **UUID v7 và Phân tán:** Sử dụng UUID v7 làm khóa chính giúp dữ liệu được sắp xếp tuần tự theo thời gian tạo, giảm thiểu hiện tượng "chẻ trang" (page splitting) và tối ưu hóa việc truy vấn các văn bản mới nhất trong cụm YugabyteDB311.
• **Lưu trữ URL linh hoạt:** Sử dụng kiểu dữ liệu **TEXT** cho `content_url` đảm bảo hệ thống không bị lỗi khi sử dụng các Presigned URL hoặc CDN URL có độ dài vượt quá 255 ký tự thường gặp trong môi trường Cloud512.
• **Tối ưu truy vấn bằng Partial Index:** Chỉ mục `idx_legal_active_version` cực kỳ nhỏ gọn vì nó chỉ chứa các bản ghi đang kích hoạt, giúp ứng dụng xác định nhanh văn bản pháp lý cần hiển thị khi người dùng đăng nhập1013.
**Sự ví von để dễ hiểu:** Bảng `legal_documents` giống như một **thư viện lưu trữ các bộ quy tắc ứng xử** của một tòa nhà. Mỗi khi quy tắc thay đổi, một cuốn sách mới (phiên bản) được xuất bản. Thư viện luôn giữ lại các cuốn sách cũ để đối chiếu, nhưng chỉ duy nhất một cuốn sách được treo ở đại sảnh (is\_active = TRUE) để mọi người cùng tuân thủ tại thời điểm đó.
thiết kế chi tiết bảng user\_consents dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và yêu cầu tuân thủ pháp lý (Legal Compliance) cho Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_consents** đóng vai trò là bằng chứng kỹ thuật xác nhận việc người dùng đã đồng ý với các điều khoản dịch vụ (TOS) hoặc chính sách bảo mật cụ thể1,2.
Việc sử dụng **UUID v7** giúp tối ưu hóa hiệu năng ghi trong môi trường phân tán của YugabyteDB và đảm bảo các bản ghi được sắp xếp theo thời gian một cách tự nhiên3,2.
1\. Thiết kế chi tiết bảng `user_consents`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian thực3,2. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | ID của người dùng thực hiện đồng ý4. |
| **document\_id** | UUID | NO | | `REFERENCES legal_documents(_id)` | Liên kết đến phiên bản văn bản pháp lý cụ thể4. |
| **agreed\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm chính xác người dùng bấm nút đồng ý (UTC)5,4. |
| **ip\_address** | INET | NO | | | Địa chỉ IP của người dùng tại thời điểm đồng ý (Phục vụ truy vết/Audit)6,4. |
| **user\_agent** | TEXT | YES | `NULL` | | Thông tin trình duyệt/thiết bị của người dùng để tăng tính pháp lý4,7. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để quản lý phiên bản dòng dữ liệu8,9. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Thiết kế này sử dụng các ràng buộc để đảm bảo một người dùng không thể có hai bản ghi đồng ý cho cùng một phiên bản văn bản, đồng thời tối ưu hóa việc truy vấn lịch sử chấp thuận2,4.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_consents (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application [3]
user_id UUID NOT NULL,
document_id UUID NOT NULL,
-- II. THÔNG TIN XÁC THỰC (EVIDENCE)
agreed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
ip_address INET NOT NULL,
user_agent TEXT,
-- III. QUẢN TRỊ
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_consent_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT fk_consent_doc FOREIGN KEY (document_id) REFERENCES legal_documents(_id),
-- Đảm bảo mỗi user chỉ đồng ý một lần với một phiên bản tài liệu nhất định [4]
CONSTRAINT uq_user_document_consent UNIQUE (user_id, document_id),
CONSTRAINT chk_consent_version CHECK (version >= 1)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ kiểm tra nhanh: "Người dùng này đã đồng ý với phiên bản TOS hiện tại chưa?"
-- Query: SELECT 1 FROM user_consents WHERE user_id = ? AND document_id = ?;
CREATE UNIQUE INDEX idx_consent_lookup
ON user_consents (user_id, document_id);
-- Index hỗ trợ báo cáo tuân thủ và truy vết pháp lý (Audit Trail)
-- Query: SELECT * FROM user_consents WHERE agreed_at BETWEEN ? AND ?;
CREATE INDEX idx_consent_audit_history
ON user_consents (agreed_at DESC);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **Bằng chứng pháp lý (Audit Trail):** Việc lưu trữ `ip_address` (kiểu INET) và `user_agent` cung cấp một "dấu chân kỹ thuật" vững chắc giúp doanh nghiệp chứng minh sự đồng ý của người dùng trong trường hợp có tranh chấp hoặc thanh tra bảo mật4,7.
• **UUID v7 và Hiệu năng:** Sử dụng UUID v7 cho khóa chính thay vì các loại UUID ngẫu nhiên giúp dữ liệu được chèn vào các node của YugabyteDB một cách tuần tự hơn, giảm thiểu việc phân mảnh chỉ mục và tăng tốc độ ghi3,10.
• **Toàn vẹn dữ liệu:** Ràng buộc `UNIQUE` trên cặp `(user_id, document_id)` ngăn chặn các dữ liệu rác hoặc trùng lặp, đảm bảo tính duy nhất của mỗi lần chấp thuận4.
• **Tối ưu hóa dung lượng:** Sử dụng kiểu dữ liệu `TEXT` cho `user_agent` thay vì `VARCHAR(255)` để linh hoạt lưu trữ các chuỗi thông tin trình duyệt dài mà không làm giảm hiệu năng của YugabyteDB11,12.
**Sự ví von:** Bảng `user_consents` giống như một **quyển sổ ký nhận tại cổng an ninh**. Mỗi khi hệ thống cập nhật "nội quy" mới (Legal Documents), người dùng đi qua cổng phải ký tên vào sổ. Quyển sổ này không chỉ lưu tên (user\_id) mà còn ghi lại cả hình ảnh camera (ip\_address) và thiết bị họ mang theo (user\_agent) để làm bằng chứng xác thực rằng họ đã thực sự đọc và đồng ý với nội quy đó.
thiết kế chi tiết bảng user\_delegations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về quản trị định danh (IAM) và cơ chế ủy quyền dành cho hệ thống Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_delegations** đóng vai trò quan trọng trong việc cho phép một người dùng hành động thay mặt người khác (ví dụ: Thư ký làm việc thay Giám đốc hoặc Nhân viên hỗ trợ xử lý lỗi thay khách hàng) mà không cần chia sẻ mật khẩu12.
Dưới đây là thiết kế chi tiết sử dụng YugabyteDB (YSQL) với định danh **UUID v7** để tối ưu hóa hiệu năng trong môi trường phân tán34.
1\. Thiết kế chi tiết bảng `user_delegations`
Bảng này được thiết kế để đảm bảo tính minh bạch (Audit) và kiểm soát quyền hạn chặt chẽ theo thời gian25.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp theo thời gian và tối ưu sharding34. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu giữa các tổ chức (SaaS Isolation)24. |
| **delegator\_id** | UUID | NO | | `REFERENCES users(_id)` | ID của người ủy quyền (người cho đi quyền hạn - ví dụ: Giám đốc)2. |
| **delegatee\_id** | UUID | NO | | `REFERENCES users(_id)` | ID của người được ủy quyền (người nhận quyền - ví dụ: Thư ký)2. |
| **scopes** | TEXT\[\] | NO | `'{}'` | | Mảng danh sách các quyền được phép thực hiện (VD: `['calendar:read', 'email:send']`)2. |
| **starts\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm việc ủy quyền bắt đầu có hiệu lực26. |
| **expires\_at** | TIMESTAMPTZ | NO | | `CHECK (expires_at > starts_at)` | Thời điểm hết hạn ủy quyền (bắt buộc phải có hạn để đảm bảo an ninh)2. |
| **is\_active** | BOOLEAN | NO | `TRUE` | | Trạng thái kích hoạt, cho phép thu hồi quyền nhanh chóng bằng tay27. |
| **reason** | TEXT | YES | `NULL` | | Lý do ủy quyền (phục vụ mục đích tra soát/audit)5. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm bản ghi được tạo (UTC)47. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL để tạo bảng và chỉ mục (Indexes)
Thiết kế này sử dụng các ràng buộc (Constraints) để đảm bảo tính toàn vẹn dữ liệu và các chỉ mục (Indexes) giúp tra cứu quyền hạn cực nhanh khi người dùng đăng nhập5.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_delegations (
-- I. ĐỊNH DANH & TENANCY
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
tenant_id UUID NOT NULL,
-- II. THÔNG TIN ỦY QUYỀN
delegator_id UUID NOT NULL,
delegatee_id UUID NOT NULL,
-- III. PHẠM VI & THỜI GIAN
scopes TEXT[] NOT NULL DEFAULT '{}',
starts_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
expires_at TIMESTAMPTZ NOT NULL,
-- IV. TRẠNG THÁI & AUDIT
is_active BOOLEAN NOT NULL DEFAULT TRUE,
reason TEXT,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- V. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_delegation_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_delegator FOREIGN KEY (delegator_id) REFERENCES users(_id),
CONSTRAINT fk_delegatee FOREIGN KEY (delegatee_id) REFERENCES users(_id),
CONSTRAINT chk_delegation_expiry CHECK (expires_at > starts_at)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm nhanh các tài khoản mà người dùng hiện tại có thể "nhập vai" (Switch account)
-- Truy vấn: SELECT delegator_id FROM user_delegations WHERE delegatee_id = ? AND is_active = TRUE AND expires_at > NOW();
CREATE INDEX idx_delegation_lookup_delegatee
ON user_delegations (tenant_id, delegatee_id)
WHERE is_active = TRUE AND expires_at > NOW();
-- Index hỗ trợ người ủy quyền kiểm tra xem mình đã cấp quyền cho những ai
CREATE INDEX idx_delegation_lookup_delegator
ON user_delegations (tenant_id, delegator_id);
```
Các điểm nhấn kỹ thuật quan trọng:
• **UUID v7 cho Sharding:** Việc sử dụng UUID v7 làm khóa chính giúp các bản ghi ủy quyền mới (thường phát sinh nhiều trong các đợt rà soát hoặc hỗ trợ kỹ thuật) được phân bổ đều trên cụm YugabyteDB, tránh hiện tượng "hotspot" ghi38.
• **Mô hình "On-behalf-of":** Cơ chế này cho phép hệ thống ghi lại chính xác ai là người thực hiện hành động (`actor_id`) và họ đang thực hiện thay mặt cho ai (`on_behalf_of`), đảm bảo tính minh bạch tuyệt đối trong các báo cáo tra soát (Audit Logs)59.
• **Kiểm soát thời hạn (Security):** Ràng buộc `CHECK` và yêu cầu `expires_at` bắt buộc giúp ngăn chặn tình trạng "quyền hạn vĩnh viễn" bị bỏ quên, một trong những lỗ hổng bảo mật phổ biến trong các hệ thống lớn2.
• **Hiệu năng truy vấn:** Với chỉ mục `idx_delegation_lookup_delegatee`, hệ thống chỉ mất vài mili-giây để xác định danh sách các tài khoản mà một nhân viên hỗ trợ (Support) có thể truy cập khi xử lý ticket510.
**Ví von:** Bảng `user_delegations` giống như một **"giấy ủy quyền có thời hạn"** trong văn phòng. Thay vì cho thư ký mượn chìa khóa gốc (mật khẩu), Giám đốc cấp một tấm thẻ phụ chỉ có quyền mở một số ngăn tủ nhất định (`scopes`) và tấm thẻ này sẽ tự động vô hiệu hóa sau một khoảng thời gian cụ thể (`expires_at`).
bảng tenant\_security\_policies có nên gộp vào trường metadata của bảng tenants không?
Dựa trên các quy chuẩn kiến trúc và phân tích dữ liệu từ các nguồn tài liệu, việc có nên gộp bảng `tenant_security_policies` vào trường metadata (thường được gọi là `profile` hoặc `settings` dưới dạng **JSONB**) của bảng `tenants` hay không phụ thuộc vào sự cân bằng giữa hiệu năng truy vấn và tính chặt chẽ của dữ liệu.
Dưới đây là phân tích chi tiết dựa trên các nguồn dữ liệu để bạn đưa ra quyết định:
1\. Tại sao NÊN GỘP (Sử dụng cột JSONB trong bảng `tenants`)
Theo các nguồn tài liệu, xu hướng thiết kế SaaS hiện đại ưu tiên việc giảm thiểu các phép JOIN không cần thiết trong hệ quản trị cơ sở dữ liệu phân tán như YugabyteDB:
• **Tối ưu hiệu năng (Distributed Join Overhead):** Trong YugabyteDB, dữ liệu của bảng `tenants` và một bảng tách rời `tenant_security_policies` có thể nằm ở hai node vật lý khác nhau1. Việc gộp chung giúp hệ thống lấy được toàn bộ thông tin định danh và chính sách bảo mật chỉ trong **một lần truy vấn duy nhất (Single seek)**, giúp giảm độ trễ (latency) mạng12.
• **Bản chất của dữ liệu cấu hình (Configs vs. Features):** Các chính sách như độ dài mật khẩu, MFA hay session timeout được phân loại là **Configs** (quy định sở thích vận hành - "Làm như thế nào?")3. Nguồn tài liệu khuyên nên lưu các Configs này trong các cột JSONB để đảm bảo tính linh hoạt3....
• **Schema linh hoạt:** Mỗi doanh nghiệp (Tenant) có thể có các yêu cầu bảo mật khác nhau. Sử dụng JSONB cho phép bạn thêm các chính sách mới (ví dụ: yêu cầu sinh trắc học mới phát sinh) mà không cần thực hiện lệnh `ALTER TABLE`, vốn có thể gây khóa bảng trong các hệ thống SQL truyền thống26.
• **Mối quan hệ 1-1:** Nguồn tài liệu khẳng định **KHÔNG NÊN tách bảng 1-1** trừ khi có lý do đặc biệt về bảo mật, vì việc tách bảng này thường mang lại nhiều tác hại về hiệu năng và làm phức tạp hóa mã nguồn (phải bọc trong Transaction để đảm bảo ghi cả 2 bảng thành công)78.
2\. Tại sao KHÔNG NÊN GỘP (Giữ bảng riêng)
Mặc dù việc gộp mang lại hiệu năng, nhưng có những trường hợp việc tách bảng lại cần thiết:
• **Ràng buộc dữ liệu cứng (Strict Constraints):** Nếu bạn cần các logic kiểm tra (CHECK constraints) cực kỳ phức tạp và khắt khe ngay tại tầng Database (ví dụ: dải IP phải tuân thủ định dạng CIDR nghiêm ngặt hoặc các quy tắc số học phức tạp), việc dùng cột riêng trong bảng tách biệt sẽ dễ quản lý hơn so với việc kiểm tra bên trong một đối tượng JSONB910.
• **Tính bảo mật và phân quyền:** Nếu bạn muốn áp dụng các chính sách bảo mật khác nhau cho việc truy cập thông tin định danh (tên, logo) và thông tin chính sách bảo mật (MFA, IP Whitelist) ở mức database, việc tách bảng sẽ giúp phân quyền dễ dàng hơn.
• **Kích thước bản ghi:** Mặc dù YugabyteDB/Postgres có cơ chế TOAST để xử lý các bản ghi lớn, nhưng nếu bảng `tenants` chứa quá nhiều thông tin metadata quá tải, nó có thể làm chậm các truy vấn quét toàn bảng (Full table scan) nếu không được đánh index cẩn thận8.
3\. Giải pháp khuyến nghị từ nguồn dữ liệu
Dựa trên nguyên tắc **"Sự chính xác và minh bạch ưu tiên hơn dung lượng lưu trữ"**11, giải pháp tối ưu nhất cho hệ thống SaaS Enterprise là:
1\. **Gộp các chính sách bảo mật vào một cột đặt tên là** **settings** **hoặc** **security\_configs** **kiểu JSONB ngay trong bảng** **tenants**5....
2\. **Cấu trúc mẫu trong cột JSONB:**
3\. **Đánh Index GIN:** Nếu bạn thường xuyên cần lọc các Tenant dựa trên một chính sách nào đó (ví dụ: tìm các Tenant bắt buộc MFA), hãy tạo **GIN Index** cho cột JSONB này để đảm bảo tốc độ truy vấn14.
**Kết luận:** Bạn **nên gộp** các chính sách bảo mật vào bảng `tenants` dưới dạng một cột **JSONB**. Điều này giúp hệ thống của bạn "Bắt đầu chặt chẽ, mở rộng linh hoạt" đúng như lời khuyên từ nguồn tài liệu15, đồng thời tối ưu hóa được sức mạnh của cơ sở dữ liệu phân tán YugabyteDB bằng cách giảm thiểu các phép Join liên node116.
**Ví dụ trực quan:** Việc gộp này giống như việc bạn dán **tờ hướng dẫn sử dụng** trực tiếp lên **vỏ hộp thiết bị**. Thay vì phải đi tìm cuốn sách hướng dẫn ở một ngăn tủ khác (bảng riêng), người dùng (ứng dụng) chỉ cần nhìn vào hộp (bảng tenants) là biết ngay cách vận hành an toàn.
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân chuẩn thiết kế hệ thống SaaS "World-class" và kiến trúc phân tán của YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants**. Đây là bảng quan trọng nhất, đóng vai trò là "trái tim" của hệ thống, nơi lưu trữ thông tin định danh, cấu hình hạ tầng và trạng thái thực thể của từng khách hàng doanh nghiệp1,2.
Việc sử dụng **UUID v7** làm khóa chính là một lựa chọn chiến lược, giúp dữ liệu được phân tán đều trên các node (Sharding) mà vẫn giữ được tính tuần tự theo thời gian, tối ưu hóa hiệu suất ghi và truy vấn so với các loại UUID ngẫu nhiên truyền thống3,4.
1\. Thiết kế chi tiết bảng `tenants`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất toàn cục chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian3,4. |
| **data\_region** | VARCHAR(50) | NO | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | Quy định vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning) để tuân thủ pháp lý (GDPR/Luật ANM)5,6. |
| **code** | VARCHAR(64) | NO | | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số và gạch ngang7,8. |
| **compliance\_level** | VARCHAR(20) | NO | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định logic xử lý dữ liệu nhạy cảm9,6. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty/tổ chức7,10. |
| **parent\_tenant\_id** | UUID | YES | `NULL` | `REFERENCES tenants(_id)` | Hỗ trợ mô hình tập đoàn (Holding - Subsidiaries)11,12. |
| **profile** | JSONB | NO | `'{}'` | | Chứa thông tin bổ sung (Logo, Website, Tax info...). Giúp schema linh hoạt mà không cần JOIN bảng13,14. |
| **status** | VARCHAR(20) | NO | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))` | Trạng thái vòng đời của khách hàng trên hệ thống15,6. |
| **active\_apps** | TEXT\[\] | YES | `'{}'` | | Cache danh sách mã ứng dụng mà tenant được quyền sử dụng để check quyền nhanh16,17. |
| **owner\_id** | UUID | YES | `NULL` | `REFERENCES users(_id)` | ID của người dùng đóng vai trò chủ sở hữu (Super Admin)16,18. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC)19,20. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng21,22. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | Cờ xóa mềm (Soft Delete) phục vụ việc khôi phục dữ liệu21,23. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** chống ghi đè dữ liệu đồng thời24,25. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh này được thiết kế để tận dụng tối đa sức mạnh của **Distributed SQL** trong YugabyteDB, đảm bảo tính nhất quán mạnh (ACID) và khả năng mở rộng ngang26,27.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenants (
-- I. ĐỊNH DANH & HẠ TẦNG (IDENTITY & INFRASTRUCTURE)
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application layer
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
code VARCHAR(64) NOT NULL,
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',
-- II. THÔNG TIN CƠ BẢN & MỞ RỘNG
name TEXT NOT NULL,
parent_tenant_id UUID,
profile JSONB NOT NULL DEFAULT '{}',
-- III. TRẠNG THÁI & QUYỀN HẠN
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
active_apps TEXT[] DEFAULT '{}',
owner_id UUID,
-- IV. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
version BIGINT NOT NULL DEFAULT 1,
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_tenants_code UNIQUE (code),
CONSTRAINT fk_tenants_parent FOREIGN KEY (parent_tenant_id) REFERENCES tenants(_id),
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')),
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
CONSTRAINT chk_tenants_name_len CHECK (LENGTH(name) > 0),
CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at),
CONSTRAINT chk_tenants_version CHECK (version >= 1)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ tìm kiếm Tenant theo domain/slug cực nhanh (Login/Routing)
CREATE UNIQUE INDEX idx_tenants_code_active
ON tenants (code)
WHERE deleted_at IS NULL;
-- Index hỗ trợ tìm tất cả các Tenant do một User quản lý
CREATE INDEX idx_tenants_owner
ON tenants (owner_id)
WHERE deleted_at IS NULL;
-- Index hỗ trợ quản trị hệ thống lọc khách hàng theo vùng và trạng thái
CREATE INDEX idx_tenants_region_status
ON tenants (data_region, status);
-- Index GIN hỗ trợ tìm nhanh các Tenant đang sử dụng một ứng dụng cụ thể
-- Giúp query: WHERE 'HRM' = ANY(active_apps)
CREATE INDEX idx_tenants_active_apps
ON tenants USING GIN (active_apps);
```
Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:
• **Kiểu dữ liệu TEXT thay vì VARCHAR(255):** Đối với các trường như `name` và `profile`, YugabyteDB xử lý `TEXT` hiệu quả tương đương `VARCHAR` nhưng linh hoạt hơn, không lo bị tràn dữ liệu khi tên doanh nghiệp hoặc URL logo quá dài28,7.
• **Tính nhất quán trong Geo-Partitioning:** Cột `data_region` kết hợp với `_id` có thể được cấu hình làm **Partition Key** để đảm bảo dữ liệu của khách hàng Châu Âu nằm đúng ở server tại Châu Âu, đáp ứng các tiêu chuẩn khắt khe về chủ quyền dữ liệu29,30.
• **Cơ chế Xóa mềm (Soft Delete):** Việc sử dụng `deleted_at` thay vì lệnh `DELETE` vật lý cho phép hệ thống khôi phục dữ liệu khi khách hàng lỡ tay xóa hoặc khi cần tra soát pháp lý sau khi chấm dứt hợp đồng21,23.
• **Sử dụng JSONB cho Profile:** Theo triết lý thiết kế SaaS hiện đại, các thông tin "mềm" như logo, mạng xã hội nên được gom vào JSONB để tối ưu hiệu năng đọc (Single Seek) và tránh việc phải thay đổi cấu trúc bảng liên tục khi thêm các trường phụ31,13.
**Sự ví von:** Bảng `tenants` giống như **cuốn sổ hộ khẩu gốc** của một tòa nhà văn phòng thông minh. Nó không chỉ ghi tên công ty thuê phòng, mà còn chứa thông tin về các tiêu chuẩn an ninh riêng biệt của họ (`compliance_level`), họ được phép ra vào những tầng nào (`active_apps`), và quan trọng nhất là "vị trí ngăn kéo" chứa hồ sơ chi tiết của họ (`data_region`).
sao không có trường settings?
Trường **settings** thực chất là một thành phần cốt lõi trong thiết kế bảng `tenants` dành cho Enterprise SaaS, nhưng tùy vào giai đoạn thiết kế và triết lý phân tách dữ liệu mà nó có thể xuất hiện dưới các tên gọi khác nhau hoặc được tách ra để tối ưu hiệu năng.
Dưới đây là lý do chi tiết và cách đưa trường này vào bảng theo đúng các nguồn dữ liệu:
1\. Sự phân tách giữa `profile` và `settings`
Trong các thiết kế chuẩn Enterprise (End-game), các nguồn dữ liệu khuyến nghị tách biệt hai loại thông tin này để quản lý rõ ràng1,2:
• **profile** **(JSONB):** Chứa các thông tin về bộ nhận diện và thông tin công khai như Logo, Website, Mô tả công ty, Mạng xã hội3,4.
• **settings** **(JSONB):** Chứa các cấu hình vận hành và logic hệ thống như: Vùng dữ liệu (Region), Mức độ tuân thủ (Compliance level), Múi giờ (Timezone), và các chính sách bảo mật mà chúng ta đã thảo luận1,2.
2\. Tại sao thiết kế trước đó có thể "thiếu" hoặc gộp?
• **Triết lý "Gộp để tối ưu":** Một số nguồn tài liệu khuyên nên gộp tất cả metadata (bao gồm cả settings) vào một cột JSONB duy nhất (thường gọi là `profile` hoặc `metadata`) để giảm thiểu số lượng cột và giúp schema linh hoạt hơn, tránh việc phải `ALTER TABLE` thường xuyên5,6.
• **Phân loại Configs vs. Features:** Theo nguồn dữ liệu, các cấu hình mang tính chất "Sở thích vận hành" (như màu sắc giao diện, quy trình workflow) thường được tách ra lưu tại **MongoDB** trong bảng `tenant_app_configs` để tận dụng tính linh hoạt tuyệt đối của NoSQL7,8.
3\. Thiết kế bảng `tenants` hoàn thiện (Bao gồm cả `settings`)
Để đáp ứng yêu cầu về sự minh bạch và chính xác cao nhất cho hệ thống Enterprise, dưới đây là bảng `tenants` đã được cập nhật đầy đủ cả trường `profile` và `settings`1,2,9:
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh UUID v710,11. |
| **code** | VARCHAR(64) | NO | | `UNIQUE`, `CHECK` regex | Mã định danh/Subdomain11,12. |
| **name** | TEXT | NO | | | Tên hiển thị công ty11,13. |
| **profile** | JSONB | NO | `'{}'` | | Thông tin thương hiệu (Logo, Website, Socials)3,2. |
| **settings** | JSONB | NO | `'{}'` | | **Cấu hình vận hành (Region, Compliance, Security policies)**1**,**2**.** |
| **status** | VARCHAR(20) | NO | `'TRIAL'` | `CHECK` enum | Trạng thái: TRIAL, ACTIVE, SUSPENDED...14,15. |
| **active\_apps** | TEXT\[\] | YES | `'{}'` | | Cache danh sách ứng dụng được phép dùng16,17. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Chống ghi đè đồng thời (Optimistic Locking)18,19. |
\--------------------------------------------------------------------------------
4\. Câu lệnh YSQL cập nhật
```
CREATE TABLE tenants (
_id UUID PRIMARY KEY,
code VARCHAR(64) NOT NULL,
name TEXT NOT NULL,
-- Phân tách rõ ràng Profile và Settings
profile JSONB NOT NULL DEFAULT '{}', -- Thông tin thương hiệu
settings JSONB NOT NULL DEFAULT '{}', -- Cấu hình logic & bảo mật
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
active_apps TEXT[] DEFAULT '{}',
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
CONSTRAINT uq_tenants_code UNIQUE (code),
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))
);
-- Index hỗ trợ tìm kiếm nhanh trong Settings (ví dụ: tìm theo vùng dữ liệu)
CREATE INDEX idx_tenants_settings ON tenants USING GIN (settings);
```
**Tóm lại:** Trường **settings** cực kỳ quan trọng để lưu trữ các tham số điều khiển logic mà không muốn JOIN bảng nhiều lần20,21. Nếu bạn muốn hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt", việc tách riêng `settings` ra khỏi `profile` sẽ giúp các lập trình viên Backend và Frontend dễ dàng phân biệt đâu là dữ liệu hiển thị (UI) và đâu là dữ liệu điều khiển (Logic)22,1.
thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả cần có đầy đủ các trường profile, settings, deleted\_at, data\_region, compliance\_level, tier, billing\_type, timezone, mô tả chi tiết trường profile, settings viết câu lệnh ysql để tạo bảng và index
Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và kiến trúc cơ sở dữ liệu phân tán YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants**. Đây là bảng hạt nhân lưu trữ định danh, trạng thái và các cấu hình cốt lõi của khách hàng doanh nghiệp12.
Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa hiệu năng ghi bằng cách duy trì tính tuần tự theo thời gian, tránh hiện tượng "hotspot" trong môi trường phân tán và hỗ trợ sắp xếp dữ liệu tự nhiên3....
1\. Thiết kế chi tiết bảng `tenants` (YSQL)
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**56. |
| **code** | VARCHAR(64) | NO | | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số, gạch ngang78. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty910. |
| **data\_region** | VARCHAR(50) | NO | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | Vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning) để tuân thủ pháp lý1112. |
| **compliance\_level** | VARCHAR(20) | NO | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định quy trình xử lý dữ liệu1213. |
| **tier** | VARCHAR(50) | NO | `'FREE'` | | Cấp độ gói dịch vụ (VD: FREE, PRO, ENTERPRISE)1415. |
| **billing\_type** | VARCHAR(20) | NO | `'POSTPAID'` | `CHECK (billing_type IN ('PREPAID', 'POSTPAID'))` | Hình thức thanh toán: Trả trước hoặc trả sau1617. |
| **timezone** | VARCHAR(50) | NO | `'UTC'` | | Múi giờ hành chính để tính toán thời hạn gói và báo cáo1418. |
| **profile** | JSONB | NO | `'{}'` | | Thông tin thương hiệu và bộ nhận diện (Metadata hiển thị)1519. |
| **settings** | JSONB | NO | `'{}'` | | Cấu hình vận hành và chính sách bảo mật (Metadata logic)1920. |
| **status** | VARCHAR(20) | NO | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED'))` | Trạng thái vòng đời của tenant1821. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo bản ghi (UTC)2223. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng2324. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` | | Cờ xóa mềm (Soft Delete) phục vụ truy vết và khôi phục24.... |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè dữ liệu đồng thời2627. |
\--------------------------------------------------------------------------------
2\. Mô tả chi tiết trường `profile` và `settings`
Việc sử dụng **JSONB** cho hai trường này giúp hệ thống linh hoạt (Schema-less), cho phép thêm thông tin mới mà không cần thực hiện `ALTER TABLE` gây khóa bảng2829.
• **profile** **(Metadata hiển thị):** Chứa các thông tin dùng để cá nhân hóa giao diện và thông tin liên hệ1519.
◦ _Ví dụ cấu trúc:_ `logo_url`, `website_url`, `description`, `social_links` (Facebook, LinkedIn), `tax_info` (Mã số thuế, địa chỉ pháp lý)2029. ◦ _Mục đích:_ Phục vụ hiển thị trên UI/UX và các thông tin phi nghiệp vụ30.
• **settings** **(Metadata vận hành):** Chứa các cấu hình điều khiển logic hệ thống và các chính sách bảo mật riêng biệt cho từng Tenant1931.
◦ _Ví dụ cấu trúc:_ `password_policy` (độ dài tối thiểu, ký tự đặc biệt), `mfa_enforced` (bắt buộc 2FA), `session_timeout`, `ip_whitelist` (dải IP được phép truy cập), `feature_flags` riêng cho tenant20.... ◦ _Mục đích:_ Điều hướng hành vi của ứng dụng mà không cần JOIN nhiều bảng cấu hình rời rạc29.
\--------------------------------------------------------------------------------
3\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenants (
-- I. ĐỊNH DANH & HẠ TẦNG
_id UUID PRIMARY KEY, -- Sinh UUID v7 từ tầng Application
code VARCHAR(64) NOT NULL,
data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',
-- II. THÔNG TIN NGHIỆP VỤ & ĐỊA PHƯƠNG HÓA
name TEXT NOT NULL,
tier VARCHAR(50) NOT NULL DEFAULT 'FREE',
billing_type VARCHAR(20) NOT NULL DEFAULT 'POSTPAID',
timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
-- III. DỮ LIỆU ĐỘNG (JSONB)
profile JSONB NOT NULL DEFAULT '{}',
settings JSONB NOT NULL DEFAULT '{}',
-- IV. TRẠNG THÁI & TRUY VẾT
status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
deleted_at TIMESTAMPTZ,
version BIGINT NOT NULL DEFAULT 1,
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_tenants_code UNIQUE (code),
CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED')),
CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
CONSTRAINT chk_tenants_billing CHECK (billing_type IN ('PREPAID', 'POSTPAID')),
CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at),
CONSTRAINT chk_tenants_version CHECK (version >= 1)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ xác thực và điều hướng (Login/Routing) theo subdomain/slug
CREATE UNIQUE INDEX idx_tenants_code_active
ON tenants (code)
WHERE deleted_at IS NULL;
-- Index GIN hỗ trợ tìm kiếm linh hoạt bên trong cấu hình Settings (Ví dụ: tìm tenant bắt buộc MFA)
CREATE INDEX idx_tenants_settings_gin
ON tenants USING GIN (settings);
-- Index GIN hỗ trợ tìm kiếm trong Profile (Ví dụ: tìm theo Mã số thuế trong JSON)
CREATE INDEX idx_tenants_profile_gin
ON tenants USING GIN (profile);
-- Index hỗ trợ báo cáo quản trị hệ thống theo khu vực và gói cước
CREATE INDEX idx_tenants_infra_stats
ON tenants (data_region, tier, status);
```
**Sự ví von:** Bảng `tenants` giống như **"Hồ sơ gốc của một tòa nhà văn phòng"**. Khóa chính UUID v7 là mã số căn hộ được sắp xếp theo thời gian xây dựng. Trường `profile` là bảng tên và logo công ty treo ở sảnh, trong khi `settings` là bộ nội quy riêng (như giờ đóng cửa, yêu cầu thẻ từ) mà mỗi văn phòng có thể tự thiết lập để phù hợp với đặc thù an ninh của họ31.
liệt kê chi tiết các thuộc tính của trường profile
Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn thiết kế cơ sở dữ liệu YugabyteDB trong các nguồn tài liệu, trường **profile** trong bảng `tenants` được thiết kế dưới dạng kiểu dữ liệu **JSONB** để lưu trữ các thông tin mang tính chất "Metadata hiển thị" (UI Metadata)1,2.
Dưới đây là danh sách chi tiết các thuộc tính thường được chứa trong trường `profile`:
1\. Thông tin thương hiệu và nhận diện (Branding)
Đây là nhóm thông tin chính dùng để cá nhân hóa giao diện người dùng (UI/UX) cho từng khách hàng doanh nghiệp:
• **description**: Mô tả ngắn gọn về hoạt động kinh doanh hoặc giới thiệu về công ty3,4. Thông tin này thường hiển thị trên trang hồ sơ công khai hoặc trang quản trị nội bộ5.
• **logo\_url**: Đường dẫn đến tệp ảnh logo của công ty3,4. Do các URL này có thể rất dài (đặc biệt khi sử dụng Presigned URL từ S3 hoặc các dịch vụ CDN), việc lưu trong JSONB giúp linh hoạt hơn so với các cột VARCHAR giới hạn6,7.
• **website\_url** (hoặc **website**): Địa chỉ trang chủ chính thức của doanh nghiệp3,4.
2\. Thông tin pháp lý và thuế (Tax & Legal)
Nhóm này lưu trữ các dữ liệu cần thiết cho việc xuất hóa đơn hoặc xác minh danh tính doanh nghiệp mà không cần tạo quá nhiều cột rời rạc:
• **tax\_info**: Một đối tượng lồng nhau (nested object) bao gồm:
◦ **tax\_code**: Mã số thuế của doanh nghiệp3,4. ◦ **address**: Địa chỉ pháp lý đăng ký trên giấy phép kinh doanh (khác với địa chỉ văn phòng thực tế có thể thay đổi)3,4.
3\. Liên kết mạng xã hội (Social Links)
Trường `profile` cho phép lưu trữ không giới hạn các liên kết mạng xã hội tùy theo nhu cầu của từng Tenant3:
• **socials** (hoặc **social\_links**): Một đối tượng chứa các khóa như:
◦ `facebook`: Link trang Fanpage. ◦ `linkedin`: Link hồ sơ doanh nghiệp trên LinkedIn. ◦ `twitter`, `tiktok`, hoặc các nền tảng khác phát sinh sau này3,4.
4\. Các thuộc tính tùy biến khác
Vì tính chất schema-less của JSONB, trường `profile` có thể mở rộng thêm các thuộc tính mà không cần sửa đổi cấu trúc bảng (ALTER TABLE)3,2:
• **industry**: Ngành nghề kinh doanh cụ thể.
• **founded\_year**: Năm thành lập.
• **contact\_person**: Thông tin người liên hệ bổ sung (nếu không nằm trong các bảng chuyên biệt).
Tại sao các thuộc tính này được gom vào `profile`?
• **Tối ưu hiệu năng:** Việc gom các thông tin hiển thị vào một cột JSONB giúp ứng dụng lấy được toàn bộ dữ liệu cần thiết cho trang Profile chỉ trong một lần truy vấn duy nhất (**Single Seek**), tránh việc phải thực hiện các phép JOIN phức tạp trong môi trường cơ sở dữ liệu phân tán8,3.
• **Sự linh hoạt:** Khách hàng doanh nghiệp A có thể cần lưu link TikTok, nhưng khách hàng B thì không. JSONB cho phép cấu trúc dữ liệu khác nhau giữa các Tenant mà vẫn đảm bảo tính nhất quán của bảng chính3.
• **Phân tách mối quan tâm:** Nguồn tài liệu nhấn mạnh việc tách biệt giữa **profile** (thông tin hiển thị, ít thay đổi) và **settings** (thông tin cấu hình logic, chính sách bảo mật) để quản lý hệ thống chuyên nghiệp và an toàn hơn9,4.
\--------------------------------------------------------------------------------
**Ví dụ về cấu trúc dữ liệu hoàn chỉnh của trường** **profile****:**
````
{
"description": "Tập đoàn công nghệ đa quốc gia",
"website_url": "https://fpt.com.vn",
"logo_url": "https://s3.region.amazonaws.com/tenant-logos/fpt-logo.png",
"tax_info": {
"tax_code": "0101234567",
"address": "Số 1 Duy Tân, Cầu Giấy, Hà Nội"
},
"socials": {
"facebook": "fb.com/fpt",
"linkedin": "linkedin.com/company/fpt"
}
}
``` [4]
````
liệt kê chi tiết các thuộc tính của trường settings
Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn thiết kế cơ sở dữ liệu phân tán YugabyteDB từ các nguồn dữ liệu, trường **settings** trong bảng `tenants` được thiết kế dưới dạng kiểu dữ liệu **JSONB**1. Trường này đóng vai trò là "Metadata vận hành", chứa các cấu hình điều hướng hành vi của ứng dụng và các chính sách bảo mật riêng biệt cho từng tổ chức23.
Dưới đây là chi tiết các thuộc tính cốt lõi nằm trong trường **settings**:
1\. Chính sách bảo mật (Security Policies)
Đây là nhóm thuộc tính quan trọng nhất, giúp thực thi các tiêu chuẩn an ninh khắt khe của doanh nghiệp4.
• **password\_policy**: Đối tượng cấu hình mật khẩu, bao gồm:
◦ `min_length`: Độ dài tối thiểu của mật khẩu (thường >= 8)4. ◦ `require_special_char`: Bắt buộc mật khẩu có ký tự đặc biệt4. ◦ `expiry_days`: Số ngày mật khẩu hết hạn (0 là không bao giờ)4. ◦ `history_limit`: Số lượng mật khẩu cũ không được phép trùng lại4.
• **mfa\_enforced**: Cờ BOOLEAN bắt buộc tất cả người dùng thuộc Tenant này phải bật xác thực 2 yếu tố (MFA)4.
• **ip\_whitelist** (hoặc `allowed_ip_ranges`): Mảng chứa các dải địa chỉ IP (CIDR) được phép truy cập vào hệ thống45.
• **session\_policy**: Cấu hình phiên làm việc:
◦ `timeout_minutes`: Thời gian tự động đăng xuất khi không hoạt động4. ◦ `max_login_attempts`: Số lần thử sai tối đa trước khi khóa tài khoản4.
2\. Cấu hình vận hành và Hạ tầng (Operational & Infrastructure)
Nhóm này quy định cách hệ thống xử lý dữ liệu và định tuyến cho Tenant36.
• **compliance**: Mức độ tuân thủ bảo mật (ví dụ: `GDPR`, `HIPAA`, `PCI-DSS`), quyết định quy trình xóa vĩnh viễn hoặc lưu vết dữ liệu67.
• **data\_residency**: Quy định vùng địa lý lưu trữ dữ liệu để đảm bảo tuân thủ luật pháp quốc gia (ví dụ: `ap-southeast-1`)89.
• **rate\_limiting**: Hạn ngạch gọi API cho từng Tenant để chống DDoS nội bộ và quá tải hệ thống1011.
◦ `requests_per_minute`: Số lượng request tối đa trong một phút11. ◦ `burst_size`: Số lượng request tối đa cho phép bùng phát trong thời gian ngắn11.
3\. Chính sách lưu trữ và Phê duyệt (Governance)
Dành cho các yêu cầu quản trị chuyên sâu của khách hàng Enterprise1213.
• **archival\_policy**: Quy định thời gian dữ liệu được giữ lại trong DB trước khi đẩy vào kho lưu trữ lạnh (S3)12.
◦ `audit_log_retention_days`: Số ngày lưu giữ nhật ký truy vết12. ◦ `invoice_retention_days`: Số ngày lưu giữ hóa đơn trong hệ thống12.
• **approval\_required**: Cờ bắt buộc các hành động nhạy cảm (như xóa dữ liệu, xuất file) phải qua quy trình phê duyệt (Maker-Checker)13.
Ví dụ cấu trúc mẫu của trường `settings`:
```
{
"security": {
"password_policy": {
"min_length": 12,
"require_special_char": true,
"expiry_days": 90
},
"mfa_enforced": true,
"ip_whitelist": ["1.2.3.4/32", "118.0.0.0/24"],
"session_timeout": 1440
},
"operational": {
"compliance_level": "GDPR",
"rate_limit": {
"rpm": 1000,
"burst": 50
}
},
"archival": {
"audit_log_days": 90
}
}
```
Việc gom tất cả các tham số điều khiển này vào một cột **JSONB** duy nhất giúp hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt"14. Điều này cho phép ứng dụng lấy toàn bộ cấu hình chỉ trong **một lần truy vấn duy nhất (Single Seek)**, tối ưu hóa hiệu năng đáng kể trên môi trường YugabyteDB phân tán bằng cách giảm thiểu các phép JOIN phức tạp1516.
liệt kê các bảng của phần Access & Security
Dựa trên các nguồn tài liệu và lịch sử thiết kế hệ thống SaaS Enterprise, phân hệ **Access & Security** (truy cập và bảo mật) được chia thành các nhóm bảng chức năng để quản lý từ định danh cốt lõi, xác thực đa yếu tố đến phân quyền chuyên sâu1,2,3.
Dưới đây là danh sách chi tiết các bảng thuộc phần này:
1\. Nhóm Xác thực & Định danh (Authentication & Identity)
Nhóm này quản lý "Căn cước công dân" số của người dùng trên toàn hệ thống và các phương thức để họ chứng minh danh tính4,5.
• **users**: Lưu trữ thông tin định danh toàn cục của một con người thực (Email, Password Hash, Avatar)6,7,4.
• **user\_linked\_identities**: Quản lý việc liên kết tài khoản với các nguồn khác nhau như Google, GitHub hoặc mật khẩu truyền thống8,9,4.
• **user\_profiles**: Lưu trữ thông tin "mềm" và các cấu hình hiển thị cá nhân (Bio, mạng xã hội, giao diện) để giữ bảng `users` nhẹ và tối ưu10,11,4.
• **tenant\_sso\_configs**: Cấu hình đăng nhập doanh nghiệp qua các chuẩn SAML/OIDC (như Azure AD, Okta) dành cho khách hàng Enterprise12,13,14,4.
2\. Nhóm Quản lý Truy cập (Access Management)
Nhóm này quản lý cách thức máy móc hoặc con người duy trì phiên làm việc và tích hợp hệ thống15,16.
• **api\_keys**: Cung cấp mã truy cập dành cho các tích hợp máy-với-máy (Machine-to-Machine)17,18,19.
• **personal\_access\_tokens** **(PATs)**: Mã truy cập dành cho lập trình viên hoặc các script tự động hóa mà không cần qua giao diện20,21,4.
• **service\_accounts**: Tài khoản dành riêng cho các dịch vụ tự động (Bot, CI/CD), được quản lý quyền hạn tương tự như một thành viên22,23.
• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động, thông tin thiết bị, địa chỉ IP và vị trí địa lý để kiểm soát an ninh thiết bị24,25,15.
• **user\_devices**: Lưu vết các thiết bị tin cậy đã được xác minh để phát hiện các đăng nhập lạ26,27,3.
3\. Nhóm Bảo mật Nâng cao (Advanced Security & MFA)
Các bảng này thực thi các lớp phòng thủ bổ sung như xác thực 2 lớp và cơ chế đăng nhập không mật khẩu28.
• **user\_mfa\_methods**: Lưu trữ các phương thức xác thực bước 2 (TOTP, SMS, Email) của người dùng29,30,28.
• **user\_backup\_codes**: Các mã khôi phục dự phòng khi người dùng mất thiết bị xác thực MFA31,28.
• **user\_webauthn\_credentials**: Quản lý thông tin đăng nhập bằng vân tay, FaceID hoặc khóa vật lý (Passkeys/FIDO2)32,33,28.
• **auth\_verification\_codes**: Các mã OTP ngắn hạn hoặc Magic Links phục vụ việc quên mật khẩu hoặc xác thực email33,34,28.
• **auth\_logs**: Nhật ký chi tiết các lần đăng nhập thành công hoặc thất bại để phát hiện tấn công Brute-force35,4,3.
4\. Nhóm Phân quyền (Authorization - IAM)
Nhóm này quyết định một người dùng sau khi đăng nhập thành công sẽ được phép thực hiện những hành động gì trên tài nguyên nào25,16.
• **permissions**: Danh mục các mã quyền hệ thống do lập trình viên định nghĩa cứng (ví dụ: `invoice:create`)36,25,23.
• **roles**: Định nghĩa các vai trò (như Admin, Manager, Viewer) chứa mảng các mã quyền tương ứng36,25,23.
• **user\_roles** **(hoặc** **member\_roles****)**: Gán vai trò cho thành viên, hỗ trợ phân vùng dữ liệu (Data Scoping)37,38,25,15.
• **user\_groups**: Nhóm người dùng để gán quyền hàng loạt hoặc quản lý theo dự án/phòng ban39,40,15.
• **access\_control\_lists** **(ACL)**: Phân quyền chi tiết trên từng tài nguyên cụ thể (ví dụ: chia sẻ thư mục X cho người B)41,23,15.
• **relationship\_tuples**: Mô hình phân quyền dựa trên mối quan hệ (ReBAC) giúp xử lý các cấu hình chia sẻ dữ liệu phức tạp kiểu Google Drive42,43,16.
• **user\_delegations**: Quản lý việc ủy quyền cho phép một người hành động thay mặt người khác trong thời gian ngắn44,16.
5\. Nhóm Chính sách & Tuân thủ (Policies & Compliance)
Các bảng quản lý các quy tắc an ninh chung của tổ chức và các yêu cầu pháp lý3.
• **tenant\_security\_policies**: Quy định về độ dài mật khẩu, thời gian hết hạn phiên, IP Whitelist và bắt buộc MFA cho toàn tổ chức45,25,3.
• **tenant\_domains**: Xác thực tên miền sở hữu của doanh nghiệp để ngăn chặn Shadow IT và bắt buộc SSO46,47,48.
• **legal\_documents**: Lưu trữ các phiên bản Điều khoản sử dụng và Chính sách bảo mật49,3.
• **user\_consents**: Lưu vết bằng chứng kỹ thuật về việc người dùng đã đồng ý với phiên bản pháp lý nào tại thời điểm nào50,51,3.
• **security\_audit\_logs**: Nhật ký các hành động nhạy cảm liên quan đến cấu hình hệ thống và an ninh52,3.
Việc tách biệt các bảng này giúp hệ thống SaaS đảm bảo tính **Nhất quán mạnh (ACID)** cho các giao dịch quan trọng và tuân thủ các chuẩn bảo mật khắt khe như **ISO 27001** hay **SOC2**53,54,55.
thiết kế chi tiết bảng api\_keys dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và yêu cầu về bảo mật tích hợp máy-với-máy (Machine-to-Machine - M2M) từ các nguồn dữ liệu, bảng **api\_keys** được thiết kế để cung cấp mã truy cập cho các tích hợp tự động mà không cần thông qua giao diện người dùng12.
Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa hiệu năng trong môi trường cơ sở dữ liệu phân tán YugabyteDB nhờ tính chất sắp xếp theo thời gian, đồng thời đảm bảo tính duy nhất toàn cầu34.
1\. Thiết kế chi tiết bảng `api_keys`
Bảng này tuân thủ quy chuẩn đặt tên `snake_case` và các kiểu dữ liệu chuẩn PostgreSQL/YSQL được khuyến nghị trong các nguồn tài liệu56.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian thực37. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết đến tổ chức (Tenant) sở hữu API Key này2. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên gợi nhớ cho Key (Ví dụ: "Tích hợp ERP", "Sync dữ liệu")28. |
| **key\_prefix** | VARCHAR(10) | NO | | | 10 ký tự đầu của Key để hiển thị trên giao diện quản trị (VD: `sk_live_...`)28. |
| **key\_hash** | TEXT | NO | | `UNIQUE` | **Tuyệt đối không lưu Key gốc**. Chỉ lưu bản băm (Hash) để đối soát khi xác thực28. |
| **scopes** | TEXT\[\] | NO | `'{}'` | | Mảng danh sách các quyền hạn được cấp (VD: `['crm:read', 'hrm:write']`)89. |
| **allowed\_ips** | CIDR\[\] | YES | `NULL` | | Giới hạn các dải IP được phép truy cập (IP Whitelist) để tăng cường bảo mật9. |
| **expires\_at** | TIMESTAMPTZ | YES | `NULL` | | Thời điểm Key hết hạn. Nếu NULL là vô hạn (không khuyến nghị cho Enterprise)910. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` | | Ghi lại thời điểm cuối cùng Key này được sử dụng để truy cập hệ thống8. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo Key911. |
| **created\_by** | UUID | YES | `NULL` | `REFERENCES users(_id)` | ID của người dùng thực hiện tạo Key này910. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để quản lý phiên bản dòng dữ liệu12. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Câu lệnh DDL dưới đây được tối ưu hóa cho YugabyteDB, đảm bảo tính nhất quán mạnh (ACID) và khả năng truy vấn nhanh chóng cho lớp xác thực Gateway1314.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE api_keys (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application layer
tenant_id UUID NOT NULL,
-- II. THÔNG TIN ĐỊNH DANH (IDENTIFICATION)
name TEXT NOT NULL,
key_prefix VARCHAR(10) NOT NULL,
key_hash TEXT NOT NULL,
-- III. QUYỀN HẠN & BẢO MẬT (SECURITY)
scopes TEXT[] NOT NULL DEFAULT '{}',
allowed_ips CIDR[], -- Kiểu dữ liệu chuyên dụng cho IP/Mạng trong Postgres
-- IV. TRẠNG THÁI & TRUY VẾT (AUDIT)
expires_at TIMESTAMPTZ,
last_used_at TIMESTAMPTZ,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
created_by UUID,
version BIGINT NOT NULL DEFAULT 1,
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_api_key_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_api_key_creator FOREIGN KEY (created_by) REFERENCES users(_id),
CONSTRAINT uq_api_key_hash UNIQUE (key_hash),
CONSTRAINT chk_api_key_name CHECK (LENGTH(name) > 0),
CONSTRAINT chk_api_key_version CHECK (version >= 1)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index quan trọng nhất: Hỗ trợ API Gateway tra cứu Key cực nhanh khi xác thực request
-- Query: SELECT tenant_id, scopes, allowed_ips FROM api_keys WHERE key_hash = ? AND (expires_at IS NULL OR expires_at > NOW());
CREATE INDEX idx_api_key_lookup
ON api_keys (key_hash)
WHERE expires_at IS NULL OR expires_at > NOW();
-- Index hỗ trợ Tenant quản lý danh sách Key của mình trong trang cấu hình
CREATE INDEX idx_api_key_tenant_list
ON api_keys (tenant_id, created_at DESC);
-- Index GIN hỗ trợ tìm kiếm các Key có quyền (scope) cụ thể
CREATE INDEX idx_api_key_scopes
ON api_keys USING GIN (scopes);
```
Các phân tích kỹ thuật từ nguồn dữ liệu:
• **Bảo mật tuyệt đối (Zero Trust):** Theo nguồn tài liệu, hệ thống chỉ lưu `key_hash` và không bao giờ lưu Key gốc28. Điều này đảm bảo rằng ngay cả khi cơ sở dữ liệu bị xâm nhập, kẻ tấn công cũng không thể sử dụng các API Key này8.
• **IP Whitelisting:** Việc sử dụng kiểu dữ liệu `CIDR[]` cho `allowed_ips` cho phép doanh nghiệp cấu hình chính xác dải IP của server đối tác, ngăn chặn các truy cập từ các nguồn lạ kể cả khi Key bị lộ9.
• **Hiệu năng xác thực:** Chỉ mục `idx_api_key_lookup` được thiết kế để API Gateway có thể xác định quyền hạn của request trong thời gian dưới 1ms, đặc biệt hiệu quả khi kết hợp với bộ nhớ đệm Redis như đã phân tích trong kiến trúc tổng thể1516.
• **Khả năng mở rộng:** Sử dụng `TEXT[]` cho `scopes` giúp hệ thống linh hoạt bổ sung các quyền hạn mới mà không cần thay đổi cấu trúc bảng1718.
**Ví von để dễ hiểu:** Bảng `api_keys` giống như một **danh sách thẻ ra vào đặc biệt dành cho robot**. Mỗi chiếc thẻ không có ảnh mặt người (không mật khẩu), nhưng có một mã số định danh mà máy quét (Gateway) nhận diện được. Tòa nhà (hệ thống) không giữ bản sao chìa khóa, chỉ giữ một bản in dấu vân tay của chìa (Hash). Nếu robot mang thẻ đến từ một hành lang lạ (IP không thuộc whitelist) hoặc thẻ đã quá hạn, cửa sẽ không mở.
thiết kế chi tiết bảng service\_accounts dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho Enterprise SaaS và mô hình quản lý "tài khoản máy" từ các nguồn dữ liệu, bảng **service\_accounts** được thiết kế để quản lý các thực thể không phải con người (như Bot, CI/CD, hoặc các dịch vụ tích hợp bên thứ ba)1,2.
Việc sử dụng **UUID v7** cho khóa chính giúp tối ưu hóa việc phân tán dữ liệu trên các node của YugabyteDB và đảm bảo các bản ghi được sắp xếp theo thời gian thực một cách tự nhiên3,1.
1\. Thiết kế chi tiết bảng `service_accounts`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding3. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định tài khoản này thuộc về tổ chức nào4,1. |
| **name** | TEXT | NO | | `CHECK (LENGTH(name) > 0)` | Tên hiển thị (VD: "GitHub Action Bot", "ERP Sync")1. |
| **description** | TEXT | YES | `NULL` | | Mô tả chi tiết mục đích sử dụng của tài khoản1. |
| **client\_id** | VARCHAR(64) | NO | | `UNIQUE` | Mã định danh duy nhất dùng để xác thực thay cho email1. |
| **client\_secret\_hash** | TEXT | NO | | | Bản băm mật khẩu của tài khoản máy1. |
| **member\_id** | UUID | NO | | `REFERENCES tenant_members(_id)` | Liên kết sang bảng thành viên để gán quyền RBAC như người thật5. |
| **is\_active** | BOOLEAN | NO | `TRUE` | | Trạng thái kích hoạt của tài khoản1. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo tài khoản (UTC)6. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật cuối cùng7. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè đồng thời8. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Thiết kế này tuân thủ quy tắc `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho YugabyteDB như `TEXT` và `TIMESTAMPTZ`9,6.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE service_accounts (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
tenant_id UUID NOT NULL,
member_id UUID NOT NULL,
-- II. THÔNG TIN XÁC THỰC
name TEXT NOT NULL,
description TEXT,
client_id VARCHAR(64) NOT NULL,
client_secret_hash TEXT NOT NULL,
-- III. TRẠNG THÁI & AUDIT
is_active BOOLEAN NOT NULL DEFAULT TRUE,
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT uq_service_account_client_id UNIQUE (client_id),
CONSTRAINT fk_service_account_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT fk_service_account_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id),
CONSTRAINT chk_service_account_name CHECK (LENGTH(name) > 0),
CONSTRAINT chk_service_account_version CHECK (version >= 1)
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ xác thực cực nhanh khi Bot gọi API
-- Query: SELECT * FROM service_accounts WHERE client_id = ? AND is_active = TRUE;
CREATE INDEX idx_service_account_auth
ON service_accounts (client_id)
WHERE is_active = TRUE;
-- Index hỗ trợ quản trị viên liệt kê các tài khoản máy theo Tenant
CREATE INDEX idx_service_account_tenant_list
ON service_accounts (tenant_id, created_at DESC);
```
Các phân tích kỹ thuật quan trọng từ nguồn dữ liệu:
• **Hợp nhất phân quyền (Unified RBAC):** Thông qua cột `member_id`, hệ thống phân quyền (RBAC) có thể xử lý Bot và Người một cách thống nhất5. Khi tạo một `service_account`, hệ thống sẽ tự động tạo một bản ghi tương ứng trong `tenant_members` để gán vai trò (Roles)5.
• **Bảo mật:** Tương tự như mật khẩu người dùng, hệ thống chỉ lưu `client_secret_hash` chứ không lưu mật khẩu gốc để đảm bảo an toàn dữ liệu1.
• **Hiệu năng phân tán:** Việc sử dụng UUID v7 làm khóa chính giúp tránh hiện tượng "hotspot" (quá tải cục bộ) trên một node duy nhất khi có nhiều tài khoản được tạo mới đồng thời trong hệ thống phân tán của YugabyteDB3,10.
**Ví von:** Bảng `service_accounts` giống như việc cấp **thẻ ra vào cho robot tự hành** trong một tòa nhà văn phòng. Thay vì dùng dấu vân tay (mật khẩu con người), robot dùng mã quét (client\_id) và mã bảo mật (client\_secret). Tuy nhiên, để biết robot được phép vào phòng nào, nó vẫn cần được đăng ký như một "nhân viên" (member\_id) trong danh sách quản lý của tòa nhà.
thiết kế chi tiết bảng user\_devices dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Dựa trên các phân tích về hệ thống quản trị định danh và bảo mật cho Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_devices** đóng vai trò là một lớp phòng thủ chiều sâu (Defense-in-Depth)1. Bảng này giúp hệ thống nhận diện các thiết bị tin cậy, phát hiện đăng nhập lạ và ngăn chặn các cuộc tấn công chiếm quyền điều khiển tài khoản23.
Việc sử dụng **UUID v7** cho khóa chính là lựa chọn tối ưu cho YugabyteDB vì tính chất sắp xếp theo thời gian giúp giảm thiểu hiện tượng "hotspot" và tăng hiệu suất ghi trong môi trường phân tán45.
1\. Thiết kế chi tiết bảng `user_devices`
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian thực46. |
| **user\_id** | UUID | NO | | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết với tài khoản người dùng chủ sở hữu thiết bị6. |
| **device\_fingerprint** | VARCHAR(255) | NO | | `UNIQUE` | Mã định danh thiết bị (được tạo từ trình duyệt, OS và phần cứng)6. |
| **name** | TEXT | YES | `NULL` | | Tên gợi nhớ do người dùng đặt (VD: "Macbook Pro của An")6. |
| **user\_agent\_parsed** | JSONB | NO | `'{}'` | | Chứa thông tin chi tiết đã phân tách từ User Agent (OS, phiên bản trình duyệt)6. |
| **trust\_status** | VARCHAR(20) | NO | `'UNTRUSTED'` | `CHECK (trust_status IN ('UNTRUSTED', 'TRUSTED', 'BLOCKED'))` | Trạng thái tin cậy của thiết bị để quyết định có cần yêu cầu MFA hay không6. |
| **last\_ip** | INET | YES | `NULL` | | Địa chỉ IP cuối cùng thiết bị này sử dụng để truy cập6. |
| **last\_active\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cuối cùng thiết bị hoạt động trên hệ thống67. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm thiết bị lần đầu được ghi nhận7. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL để tạo bảng và chỉ mục (Indexes)
Thiết kế này tận dụng kiểu dữ liệu `INET` chuyên dụng cho địa chỉ IP và `JSONB` để lưu trữ linh hoạt thông tin thiết bị mà không làm giảm hiệu năng truy vấn89.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_devices (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
user_id UUID NOT NULL,
-- II. THÔNG TIN THIẾT BỊ (DEVICE INFO)
device_fingerprint VARCHAR(255) NOT NULL,
name TEXT,
user_agent_parsed JSONB NOT NULL DEFAULT '{}',
-- III. TRẠNG THÁI BẢO MẬT (SECURITY STATUS)
trust_status VARCHAR(20) NOT NULL DEFAULT 'UNTRUSTED',
last_ip INET,
-- IV. TRUY VẾT THỜI GIAN (AUDIT)
last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
-- V. CÁC RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_device_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
CONSTRAINT uq_device_fingerprint UNIQUE (device_fingerprint),
CONSTRAINT chk_device_trust_status CHECK (trust_status IN ('UNTRUSTED', 'TRUSTED', 'BLOCKED'))
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index hỗ trợ xác thực nhanh thiết bị khi người dùng đăng nhập
-- Truy vấn: SELECT trust_status FROM user_devices WHERE user_id = ? AND device_fingerprint = ?;
CREATE INDEX idx_user_device_lookup
ON user_devices (user_id, device_fingerprint);
-- Index hỗ trợ người dùng quản lý danh sách thiết bị của mình (Để thu hồi/Logout)
CREATE INDEX idx_user_devices_list
ON user_devices (user_id, last_active_at DESC);
-- Index hỗ trợ Admin hệ thống tìm kiếm các thiết bị đang bị chặn (BLOCKED)
CREATE INDEX idx_blocked_devices
ON user_devices (trust_status)
WHERE trust_status = 'BLOCKED';
```
Phân tích sâu về kiến trúc từ các nguồn dữ liệu:
• **Tối ưu hóa Sharding với UUID v7:** Việc sử dụng UUID v7 làm khóa chính giúp các thiết bị mới được tạo ra được phân bổ đều trên các node trong cụm YugabyteDB, tránh hiện tượng nghẽn cổ chai khi có lượng lớn người dùng đăng nhập cùng lúc từ thiết bị mới45.
• **Cơ chế Tin cậy (Trust Mechanism):** Theo nguồn3, khi phát hiện một `device_fingerprint` mới chưa có trong DB, hệ thống sẽ tự động gửi cảnh báo "Đăng nhập thiết bị lạ" và yêu cầu xác thực MFA. Ngược lại, nếu trạng thái là `TRUSTED`, trải nghiệm người dùng sẽ mượt mà hơn vì có thể bỏ qua bước MFA1011.
• **Xử lý dữ liệu linh hoạt với JSONB:** Trường `user_agent_parsed` cho phép hệ thống lưu trữ các thuộc tính biến động của thiết bị (phiên bản trình duyệt nâng cấp, độ phân giải màn hình) mà không cần thay đổi cấu trúc bảng thường xuyên912.
• **Bảo mật dữ liệu:** Kết hợp với bảng `auth_logs`, dữ liệu từ `user_devices` giúp phát hiện các cuộc tấn công Brute-force hoặc chiếm đoạt tài khoản khi một User ID được sử dụng liên tục trên nhiều thiết bị lạ trong thời gian ngắn13.
**Ví von:** Bảng `user_devices` giống như một **"Sổ đăng ký phương tiện"** tại cổng an ninh của một tòa nhà doanh nghiệp. Khi bạn đến bằng một chiếc xe quen thuộc đã được đăng ký (`TRUSTED`), bảo vệ sẽ cho bạn vào nhanh. Nếu bạn đi một chiếc xe lạ (`UNTRUSTED`), bạn buộc phải xuất trình thêm giấy tờ (MFA). Nếu chiếc xe đó nằm trong danh sách đen (`BLOCKED`), cổng sẽ không bao giờ mở.
trong các bảng của phần Access & Security bảng nào nên lưu vào ClickHouse, bảng nào nên lưu vào MongoDB
Dựa trên triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) được đề cập trong các nguồn tài liệu, việc phân bổ các bảng thuộc phân hệ **Access & Security** vào ClickHouse hay MongoDB phụ thuộc vào tính chất của dữ liệu: là dữ liệu vận hành (Operational), dữ liệu quan hệ (ACID), hay dữ liệu phân tích/nhật ký (Analytics/Logs)12.
Dưới đây là phân tích chi tiết về việc lưu trữ các bảng này:
1\. Các bảng nên lưu vào ClickHouse (Dữ liệu Lớn & Phân tích)
ClickHouse đóng vai trò là **"Bộ nhớ vĩnh cửu"**, chuyên xử lý dữ liệu lịch sử, sự kiện với khối lượng khổng lồ, chỉ ghi thêm (Append-only) và ít khi sửa/xóa34. Trong phần Access & Security, các bảng sau đây thuộc diện này:
• **security\_audit\_logs** **(hoặc** **audit\_logs****):** Lưu trữ dấu vết "Ai làm gì, lúc nào?". Với hệ thống lớn, bảng này có thể lên tới hàng tỷ bản ghi, việc lưu vào ClickHouse giúp nén dữ liệu cực tốt (tỷ lệ 10:1) và truy vấn thống kê nhanh chóng4....
• **auth\_logs****:** Nhật ký chi tiết các lần đăng nhập thành công hoặc thất bại. Dữ liệu này cần thiết để phát hiện các cuộc tấn công Brute-force hoặc các hành vi đăng nhập bất thường theo thời gian78.
• **api\_usage\_logs****:** Ghi lại lịch sử sử dụng của các `api_keys`, bao gồm số lượng request, dung lượng bandwidth để phục vụ việc tính tiền (Billing) hoặc giới hạn băng thông (Rate Limit)910.
• **webhook\_delivery\_logs****:** Lưu lịch sử các lần hệ thống bắn thông báo đến các bên thứ ba, bao gồm kết quả thành công hay thất bại và phản hồi từ server đối tác1112.
**Lý do chọn ClickHouse:** Các bảng này mang tính chất bất biến (Immutable), không bao giờ cập nhật (Update) mà chỉ chèn mới (Insert). ClickHouse tối ưu hóa cho các truy vấn tổng hợp (SUM, COUNT) trên tập dữ liệu lớn mà các DB quan hệ hay Document sẽ bị quá tải413.
\--------------------------------------------------------------------------------
2\. Các bảng nên lưu vào MongoDB (Dữ liệu Động & Cấu hình)
MongoDB được coi là **"Bộ não linh hoạt"**, phù hợp với các dữ liệu có cấu trúc lồng nhau, thay đổi thường xuyên và khác biệt tùy theo ngữ cảnh của từng khách hàng (Tenant)14.
• **tenant\_app\_configs** **(phần liên quan đến bảo mật):** Nếu khách hàng muốn tự định nghĩa các quy trình phê duyệt động (Workflow definitions) hoặc các cài đặt bảo mật mang tính "sở thích" riêng biệt không nằm trong schema chuẩn, MongoDB là nơi lưu trữ lý tưởng nhờ tính schema-less1415.
• **custom\_fields****:** Định nghĩa các trường dữ liệu bổ sung mà Tenant tự thêm vào hồ sơ người dùng (ví dụ: "Mã số thẻ nhân viên", "Nhóm máu") phục vụ cho mục đích định danh nội bộ516.
• **user\_ui\_preferences****:** Lưu trữ các cấu hình giao diện bảo mật cá nhân của người dùng, như cài đặt chế độ hiển thị, ẩn/hiện các cột thông tin nhạy cảm trên Dashboard17.
**Lý do chọn MongoDB:** Các dữ liệu này thường được lấy ra trọn gói dưới dạng một đối tượng (Get whole object), giúp giảm thiểu việc JOIN nhiều bảng và linh hoạt khi mỗi Tenant có một yêu cầu cấu hình khác nhau mà không cần thực hiện lệnh `ALTER TABLE` gây khóa bảng14....
\--------------------------------------------------------------------------------
3\. Lưu ý quan trọng: Những bảng KHÔNG NÊN lưu vào ClickHouse/MongoDB
Theo nguồn tài liệu, các dữ liệu **Core Identity** yêu cầu tính nhất quán tuyệt đối (ACID) và quan hệ chặt chẽ thì bắt buộc phải lưu ở **YugabyteDB (Postgres)** thay vì ClickHouse hay MongoDB2021:
• **Dữ liệu định danh lõi:** `users`, `tenants`, `tenant_members`, `passwords` (hash). Các dữ liệu này nếu bị sai lệch (eventual consistency) sẽ dẫn đến rủi ro bảo mật nghiêm trọng1920.
• **Dữ liệu phân quyền:** `roles`, `permissions`, `user_roles`, `access_control_lists`, `tenant_security_policies`. Việc gán quyền và kiểm tra quyền yêu cầu tính nhất quán mạnh để đảm bảo người dùng không thể truy cập trái phép ngay sau khi bị thu hồi quyền20....
• **Dữ liệu xác thực:** `user_sessions`, `user_mfa_methods`, `api_keys`. Các bảng này cần sự an toàn tuyệt đối của một "Két sắt an toàn" như YugabyteDB2024.
Tóm tắt chiến lược dòng chảy dữ liệu (Data Flow)
Để hệ thống vận hành trơn tru, bạn nên áp dụng mô hình sau:
1\. **Ghi (Write):** Các hành động xác thực và cấu hình được ghi vào YugabyteDB hoặc MongoDB (tùy tính chất)25.
2\. **Đồng bộ (Sync):** Sử dụng **Kafka + Debezium (CDC)** để lắng nghe thay đổi từ YugabyteDB/MongoDB và đẩy dữ liệu sang ClickHouse để phân tích, tránh việc ứng dụng phải ghi đồng thời vào cả hai DB (Dual Write)1326.
3\. **Đọc (Read):** Ứng dụng truy vấn trực tiếp ClickHouse khi cần xem báo cáo hoặc tra cứu nhật ký audit để đảm bảo hiệu suất27.
**Sự ví von:** Việc phân chia này giống như trong một bệnh viện: **YugabyteDB** là hồ sơ bệnh án gốc và két sắt thuốc (phải cực kỳ chính xác và bảo mật), **MongoDB** là sơ đồ phòng bệnh và yêu cầu cá nhân của bệnh nhân (thay đổi linh hoạt tùy người), còn **ClickHouse** là nhật ký đo nhịp tim và camera an ninh (lưu trữ lượng dữ liệu khổng lồ theo thời gian để tra cứu khi có sự cố)4....
Phân biệt vai trò của bảng Features và bảng Configs trong SaaS.
Trong kiến trúc hệ thống SaaS quy mô lớn, việc phân tách rõ ràng giữa **Features** (Tính năng/Quyền lợi) và **Configs** (Cấu hình vận hành) là một quy tắc vàng để đảm bảo hệ thống vừa chặt chẽ về mặt thương mại, vừa linh hoạt về mặt vận hành1,2. Dưới đây là sự phân biệt chi tiết dựa trên các nguồn tài liệu:
1\. Bản chất và Mục đích sử dụng
• **Features (Tính năng - Quyền lợi thương mại):** Đây là các thuộc tính quy định **"Quyền lợi"** của khách hàng gắn liền với gói dịch vụ (Service Package) mà họ đã mua1. Nó trả lời cho câu hỏi: **"Tenant được phép làm gì?"** và **"Được dùng bao nhiêu?"**1. Features mang tính chất pháp lý và thương mại, là cơ sở để hệ thống kiểm tra quyền (Entitlement Check)3.
• **Configs (Cấu hình - Sở thích vận hành):** Đây là các thuộc tính quy định **"Sở thích vận hành"** hoặc logic xử lý riêng biệt của từng khách hàng1. Nó trả lời cho câu hỏi: **"Tenant muốn hệ thống hoạt động như thế nào?"**1. Configs mang tính chất tùy biến trải nghiệm và quy trình làm việc (Workflow) của người dùng4.
2\. So sánh chi tiết
| Đặc điểm | Features (Quyền lợi) | Configs (Cấu hình) |
| --- | --- | --- |
| **Câu hỏi đại diện** | "Được làm gì?" / "Được bao nhiêu?"1 | "Làm như thế nào?" / "Giao diện ra sao?"1 |
| **Ví dụ điển hình** | `max_users: 10`, `allow_export_excel: true`, `storage_gb: 50`1,5 | `theme_color: #blue`, `workflow_steps`, `language: vi-VN`1,6 |
| **Vị trí lưu trữ** | Thường lưu tại **YugabyteDB** (Postgres) trong bảng `service_packages` và được snapshot vào `tenant_subscriptions`1,7. | Thường lưu tại **MongoDB** trong bảng `tenant_app_configs` để tận dụng tính linh hoạt (Schema-less)8,4. |
| **Tính chất thay đổi** | Thay đổi khi khách hàng nâng cấp gói, mua thêm add-on hoặc gia hạn7,9. | Thay đổi khi Admin của Tenant vào trang cài đặt để chỉnh sửa theo ý muốn6. |
| **Tác động hệ thống** | Ảnh hưởng đến việc chặn/mở quyền truy cập hoặc giới hạn số lượng tài nguyên10. | Ảnh hưởng đến logic xử lý code, luồng phê duyệt hoặc hiển thị UI/UX4,6. |
3\. Chiến lược lưu trữ và Kỹ thuật
• **Đối với Features:** Do liên quan trực tiếp đến tiền nong và quyền lợi (Billing & Entitlement), dữ liệu này yêu cầu tính **nhất quán tuyệt đối (ACID)**8,11. Khi một Tenant mua gói, hệ thống phải thực hiện **Snapshot** (sao chép) toàn bộ Features từ gói gốc vào bảng đăng ký của khách hàng để tránh việc thay đổi giá hay quyền lợi ở gói gốc làm ảnh hưởng đến các hợp đồng cũ đang hiệu lực12,7.
• **Đối với Configs:** Vì mỗi khách hàng có thể có những cấu hình hoàn toàn khác nhau (Tenant A cần thêm trường dữ liệu X, Tenant B không cần), việc dùng **MongoDB** là tối ưu để tránh việc phải thực hiện lệnh `ALTER TABLE` gây khóa bảng trong SQL truyền thống mỗi khi có yêu cầu tùy biến mới4,11.
4\. Luồng xử lý dữ liệu (Data Flow)
• Khi người dùng đăng nhập, hệ thống sẽ kiểm tra **Features** từ cache (thường là Redis) để biết họ có quyền vào module đó không12,13.
• Sau khi đã vào được module, hệ thống mới tải các **Configs** từ MongoDB để biết phải hiển thị màu sắc gì, ngôn ngữ nào và quy trình phê duyệt gồm những bước nào cho người dùng đó4,6.
**Sự ví von để dễ hiểu:** Hãy tưởng tượng Tenant thuê một căn hộ trong tòa nhà SaaS. **Features** chính là các điều khoản trong hợp đồng thuê: căn hộ rộng bao nhiêu mét vuông, được ở tối đa mấy người, có được gửi xe hay không. Trong khi đó, **Configs** chính là cách Tenant bài trí căn hộ đó: sơn tường màu gì, đặt lịch bật đèn lúc mấy giờ, hay sắp xếp đồ đạc trong phòng ra sao. Chủ tòa nhà (Provider) kiểm soát Features, nhưng khách thuê (Tenant) có toàn quyền quyết định Configs trong phạm vi căn hộ của mình.
thiết kế chi tiết bảng auth\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index
Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn lưu trữ dữ liệu lớn (OLAP), bảng **auth\_logs** được thiết kế để lưu trữ trong **ClickHouse**. Đây là nơi đóng vai trò "Bộ nhớ vĩnh cửu", chuyên xử lý nhật ký truy cập với khối lượng khổng lồ (hàng tỷ bản ghi) nhờ vào khả năng nén dữ liệu cực tốt và tốc độ truy vấn tổng hợp vượt trội1,2.
Việc sử dụng **UUID v7** cho phép các bản ghi nhật ký được sắp xếp tự nhiên theo thời gian, giúp tối ưu hóa việc chèn dữ liệu (Insert) và tra cứu lịch sử trong môi trường phân tán3.
1\. Thiết kế chi tiết bảng `auth_logs` (ClickHouse)
Trong ClickHouse, chúng ta ưu tiên sử dụng các kiểu dữ liệu chuyên biệt như `IPv6` (hỗ trợ cả IPv4) và `Enum` để tối ưu hóa hiệu năng và dung lượng lưu trữ4,5.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**3. |
| **tenant\_id** | UUID | NO | | | Định danh tổ chức sở hữu log này (Dùng để lọc dữ liệu)6,7. |
| **user\_id** | Nullable(UUID) | YES | `NULL` | | ID người dùng nếu đăng nhập thành công hoặc email tồn tại8. |
| **impersonator\_id** | Nullable(UUID) | YES | `NULL` | | ID nhân viên Support nếu đang sử dụng tính năng "Impersonation"9,10. |
| **email\_attempted** | String | NO | | | Email người dùng đã nhập vào khi thử đăng nhập8. |
| **ip\_address** | IPv6 | NO | | | Địa chỉ IP truy cập (Lưu chuẩn IPv6 để bao quát cả IPv4)8. |
| **user\_agent** | String | NO | | | Thông tin trình duyệt và hệ điều hành (User Agent)8. |
| **is\_success** | Bool | NO | | | `true` nếu thành công, `false` nếu thất bại5,8. |
| **login\_method** | Enum8(...) | NO | `'PASSWORD'` | `PASSWORD`, `GOOGLE`, `SSO`, `MAGIC_LINK` | Phương thức xác thực được sử dụng4,8. |
| **failure\_reason** | Enum8(...) | NO | `'NONE'` | `NONE`, `WRONG_PW`, `MFA_FAIL`, `LOCKED` | Lý do thất bại (nếu có) để phục vụ phân tích bảo mật8. |
| **created\_at** | DateTime64(3) | NO | `now()` | UTC | Thời điểm phát sinh sự kiện, chính xác đến mili giây4,5. |
\--------------------------------------------------------------------------------
2\. Mô tả chi tiết các thuộc tính kỹ thuật
• **UUID v7:** Giúp ClickHouse index dữ liệu tốt hơn vì các ID được sinh ra có tính tuần tự theo thời gian, tránh việc ghi dữ liệu ngẫu nhiên vào các phần (parts) khác nhau của ổ đĩa3.
• **Enum8:** Thay vì lưu chuỗi "PASSWORD" tốn nhiều byte, ClickHouse lưu dưới dạng số nguyên 8-bit giúp nén dữ liệu cực mạnh và tăng tốc độ lọc (Filtering)4,5.
• **Partitioning (Phân vùng):** Dữ liệu được chia theo tháng (`toYYYYMM`) để dễ dàng xóa dữ liệu cũ (Cold data) và tăng tốc độ truy vấn cho các báo cáo trong tháng7,11.
\--------------------------------------------------------------------------------
3\. Câu lệnh tạo bảng và Index trong ClickHouse
Trong ClickHouse, `ORDER BY` chính là chỉ mục chính (Primary Index). Chúng ta chọn `tenant_id` và `created_at` làm khóa sắp xếp để tối ưu cho truy vấn: "Lấy lịch sử đăng nhập của công ty A trong khoảng thời gian X"7.
```
CREATE TABLE auth_logs (
-- I. ĐỊNH DANH & TENANCY
_id UUID,
tenant_id UUID,
user_id Nullable(UUID),
impersonator_id Nullable(UUID),
-- II. CHI TIẾT ĐĂNG NHẬP
email_attempted String,
ip_address IPv6,
user_agent String,
-- III. KẾT QUẢ & PHƯƠNG THỨC (Dùng Enum để tối ưu)
is_success Bool,
login_method Enum8(
'PASSWORD' = 1,
'GOOGLE' = 2,
'SSO' = 3,
'MAGIC_LINK' = 4,
'PASSKEY' = 5
),
failure_reason Enum8(
'NONE' = 0,
'WRONG_PASSWORD' = 1,
'MFA_FAILED' = 2,
'USER_LOCKED' = 3,
'INVALID_TOKEN' = 4
),
-- IV. THỜI GIAN
created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng quản lý vòng đời (Retention Policy)
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant trước, thời gian sau để tối ưu truy vấn SaaS
ORDER BY (tenant_id, created_at, _id)
-- Cấu hình lưu trữ bổ sung (Tùy chọn)
SETTINGS index_granularity = 8192;
-- Tạo Index Bloom Filter cho trường email_attempted để tìm kiếm nhanh khi bị tấn công Brute-force
ALTER TABLE auth_logs ADD INDEX idx_email_search email_attempted TYPE bloom_filter(0.01) GRANULARITY 1;
```
**Sự ví von:** Bảng `auth_logs` trong ClickHouse giống như **"Camera an ninh ghi hình liên tục"** của tòa nhà SaaS2. Nó không dùng để điều khiển cửa ra vào (đó là việc của YugabyteDB), nhưng nó lưu lại mọi lượt ra vào. Khi có sự cố, bạn có thể tua lại băng ghi hình của hàng triệu lượt khách chỉ trong vài giây để tìm ra kẻ đột nhập nhờ cách sắp xếp ngăn nắp theo thời gian và khu vực (Tenant)12,7.
thiết kế chi tiết bảng security\_audit\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index
Dựa trên các quy chuẩn thiết kế hệ thống SaaS dành cho dữ liệu lớn và kiến trúc "Polyglot Persistence", bảng **security\_audit\_logs** được lưu trữ tại **ClickHouse** để tận dụng khả năng nén dữ liệu vượt trội và tốc độ truy vấn phân tích trên hàng tỷ bản ghi1,2.
Việc sử dụng **UUID v7** làm khóa chính giúp các bản ghi được sắp xếp tuần tự theo thời gian ngay từ tầng định danh, hỗ trợ ClickHouse tối ưu hóa việc ghi dữ liệu vào các ổ đĩa3,4.
1\. Thiết kế chi tiết bảng `security_audit_logs` (ClickHouse)
Bảng này tập trung vào việc trả lời câu hỏi: "Ai đã làm gì, vào lúc nào, trên đối tượng nào và thông qua thiết bị gì?"5,6.
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian3,4. |
| **tenant\_id** | UUID | NO | | | Định danh tổ chức sở hữu hành động này để phân vùng dữ liệu7,8. |
| **actor\_id** | UUID | NO | | | ID của người dùng thực hiện hành động6. |
| **impersonator\_id** | Nullable(UUID) | YES | `NULL` | | ID nhân viên hỗ trợ nếu đang sử dụng tính năng "Impersonation" (giả danh)9,10. |
| **event\_category** | Enum8(...) | NO | | `IAM`, `AUTH`, `BILLING`, `DATA` | Nhóm sự kiện chính để lọc nhanh (Ví dụ: Bảo mật, Thanh toán)11,6. |
| **event\_action** | String | NO | | | Hành động cụ thể (Ví dụ: `ROLE_ASSIGNED`, `API_KEY_CREATED`)6. |
| **target\_id** | Nullable(UUID) | YES | `NULL` | | ID của đối tượng bị tác động (Ví dụ: ID của User bị khóa)6. |
| **resource\_type** | String | NO | | | Loại tài nguyên bị tác động (Ví dụ: `USER`, `INVOICE`, `ROLE`)12. |
| **ip\_address** | IPv6 | NO | | | Địa chỉ IP của người thực hiện (Lưu IPv6 để bao quát cả IPv4)6. |
| **user\_agent** | String | NO | | | Thông tin trình duyệt và hệ điều hành6. |
| **details** | String | NO | `'{}'` | | Lưu chi tiết thay đổi dưới dạng **JSON String** (Dùng `JSONExtract` khi truy vấn)13,6. |
| **created\_at** | DateTime64(3) | NO | `now()` | UTC | Thời điểm xảy ra sự kiện, chính xác đến mili giây11,13. |
\--------------------------------------------------------------------------------
2\. Câu lệnh ClickHouse tạo bảng và chỉ mục (Index)
Trong ClickHouse, chỉ mục chính được định nghĩa qua `ORDER BY`. Chúng ta sẽ phân vùng dữ liệu theo tháng để dễ dàng quản lý vòng đời dữ liệu (Archiving)8,14.
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE security_audit_logs (
-- I. ĐỊNH DANH & TENANCY
_id UUID,
tenant_id UUID,
actor_id UUID,
impersonator_id Nullable(UUID),
-- II. CHI TIẾT SỰ KIỆN (Dùng Enum để nén dữ liệu cực tốt)
event_category Enum8(
'IAM' = 1,
'AUTH' = 2,
'BILLING' = 3,
'DATA' = 4,
'SYSTEM' = 5
),
event_action String,
target_id Nullable(UUID),
resource_type String,
-- III. THÔNG TIN MÔI TRƯỜNG
ip_address IPv6,
user_agent String,
details String, -- Lưu JSON thô
-- IV. THỜI GIAN
created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng theo tháng để tối ưu việc xóa dữ liệu cũ (Data Archiving)
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant và Thời gian để phục vụ query Dashboard SaaS nhanh nhất
ORDER BY (tenant_id, created_at, _id)
SETTINGS index_granularity = 8192;
-- 2. CHIẾN LƯỢC ĐÁNH INDEX BỔ SUNG (SKIPPING INDEX)
-- Index giúp tìm kiếm nhanh các hành động cụ thể trong hàng tỷ bản ghi
ALTER TABLE security_audit_logs
ADD INDEX idx_event_action event_action TYPE bloom_filter(0.01) GRANULARITY 1;
-- Index hỗ trợ tra cứu lịch sử tác động lên một tài nguyên cụ thể (target_id)
ALTER TABLE security_audit_logs
ADD INDEX idx_target_lookup target_id TYPE bloom_filter(0.01) GRANULARITY 1;
```
3\. Các lưu ý kỹ thuật quan trọng từ nguồn dữ liệu
• **Hiệu năng:** Việc sắp xếp dữ liệu theo `(tenant_id, created_at)` cho phép hệ thống lấy ra toàn bộ nhật ký của một khách hàng trong một khoảng thời gian cụ thể chỉ trong vài mili giây, thay vì phải quét toàn bộ ổ đĩa2,8.
• **Tính bất biến:** Dữ liệu trong ClickHouse là **Append-only** (chỉ ghi thêm), đảm bảo tính toàn vẹn cho mục đích pháp lý vì log không bị sửa đổi5,15.
• **Tiết kiệm chi phí:** Nhờ lưu trữ dạng cột và kiểu dữ liệu Enum, ClickHouse có thể nén dữ liệu audit lên đến 10 lần so với các cơ sở dữ liệu truyền thống, giúp tiết kiệm đáng kể chi phí lưu trữ S3/SSD2,16.
**Sự ví von:** Bảng `security_audit_logs` trong ClickHouse giống như một **"Hộp đen máy bay"** của hệ thống SaaS. Nó ghi lại mọi thông số kỹ thuật và hành vi của phi hành đoàn (người dùng) một cách cực kỳ chi tiết và không thể tẩy xóa, giúp bạn có thể phục dựng lại toàn bộ diễn biến sự cố an ninh bất cứ lúc nào5,17.
liệt kê các bảng nhóm tính năng Quản lý truy cập
Dựa trên các nguồn tài liệu về kiến trúc hệ thống Enterprise SaaS, nhóm tính năng **Quản lý truy cập (Access Management)** đóng vai trò quyết định cách thức máy móc, dịch vụ tự động và con người duy trì phiên làm việc hoặc tích hợp với hệ thống12.
Dưới đây là danh sách chi tiết các bảng thuộc nhóm này:
1\. Nhóm truy cập tự động (Machine & Developer Access)
Nhóm này dành cho các tích hợp không thông qua giao diện người dùng truyền thống:
• **api\_keys**: Lưu trữ mã truy cập dành cho các tích hợp **Máy-với-Máy (Machine-to-Machine)**23. Bảng này chỉ lưu bản băm (hash) của chìa khóa để đảm bảo bảo mật và hỗ trợ giới hạn theo dải IP (IP Whitelist)23.
• **personal\_access\_tokens** **(PATs)**: Tương tự như mã truy cập của GitHub, dành cho lập trình viên hoặc các script tự động hóa14. PATs giúp người dùng thực hiện các lệnh API mà không cần dùng mật khẩu hay qua xác thực 2 lớp (MFA) vốn dành cho người thật1.
• **service\_accounts**: Quản lý các tài khoản dành riêng cho bot, CI/CD hoặc các dịch vụ bên thứ ba56. Các tài khoản này được gán một `member_id` để có thể nhận các quyền hạn (RBAC) tương tự như một thành viên bình thường trong tổ chức7.
2\. Nhóm quản lý phiên và thiết bị (Session & Device Management)
Nhóm này tập trung vào việc giám sát và duy trì trạng thái đăng nhập của người dùng:
• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động, bao gồm thông tin về **địa chỉ IP, loại thiết bị (mobile/desktop), hệ điều hành và vị trí địa lý**48. Bảng này cho phép thực hiện các tính năng an ninh như "Đăng xuất khỏi tất cả thiết bị" hoặc thu hồi quyền truy cập ngay lập tức910.
• **user\_devices**: Lưu vết các thiết bị đã từng đăng nhập để xác định mức độ tin cậy (`trust_status`)1112. Dựa vào đây, hệ thống có thể quyết định yêu cầu MFA nếu phát hiện đăng nhập từ một thiết bị lạ (Fingerprint mới)1213.
3\. Nhóm định tuyến và hạ tầng truy cập (Access Infrastructure)
Nhóm này đóng vai trò là "bản đồ" để dẫn hướng các yêu cầu truy cập vào đúng đích:
• **tenant\_app\_routes**: Được coi là bảng quan trọng nhất cho lớp định tuyến (Routing)14. Nó quy định tên miền nào (`domain`) hoặc đường dẫn nào (`path_prefix`) sẽ trỏ vào khách hàng nào (`tenant_id`) và ứng dụng cụ thể nào1516. Dữ liệu này thường được cache lên Redis để đạt tốc độ xử lý dưới 1ms1718.
• **tenant\_sso\_configs**: Chứa cấu hình đăng nhập doanh nghiệp qua các chuẩn như **SAML 2.0 hoặc OIDC**1920. Bảng này cho phép nhân viên của khách hàng Enterprise dùng tài khoản công ty (Azure AD, Okta, Google Workspace) để truy cập hệ thống mà không cần tạo mật khẩu riêng1921.
Tóm tắt vai trò các bảng chính
| Tên bảng | Đối tượng phục vụ | Mục đích chính |
| --- | --- | --- |
| **api\_keys** | Hệ thống bên thứ ba | Tích hợp máy-với-máy (M2M)2. |
| **personal\_access\_tokens** | Lập trình viên | Chạy script, tự động hóa tác vụ1. |
| **service\_accounts** | Bot / Dịch vụ tự động | Thực hiện các tác vụ hệ thống nhân danh Tenant5. |
| **user\_sessions** | Người dùng thực | Duy trì và kiểm soát phiên làm việc trực tuyến8. |
| **tenant\_app\_routes** | Gateway / Reverse Proxy | Định tuyến yêu cầu từ URL vào đúng Tenant/App1416. |
Hệ thống quản lý truy cập này giúp tách biệt hoàn toàn giữa việc **Xác thực con người** (Human Auth) và **Xác thực máy móc** (Machine Auth), đồng thời đảm bảo tính minh bạch thông qua các bản ghi nhật ký chi tiết1222.
bổ sung thêm các bảng nhóm tính năng Quản lý truy cập
Dựa trên các nguồn tài liệu và lịch sử thiết kế hệ thống SaaS Enterprise, nhóm tính năng **Quản lý truy cập (Access Management)** đóng vai trò là "cửa ngõ" điều phối luồng truy cập của con người và máy móc vào tài nguyên hệ thống1,2.
Dưới đây là danh sách chi tiết các bảng bổ sung cho nhóm tính năng này, được phân loại theo mục đích sử dụng cụ thể:
1\. Nhóm Truy cập Tự động và Lập trình viên (Machine & Developer Access)
Nhóm này quản lý các phương thức truy cập không qua giao diện người dùng (Non-interactive), dành cho tích hợp hệ thống3,4.
• **api\_keys**: Lưu trữ mã truy cập cho các tích hợp Máy-với-Máy (M2M)5,6. Bảng này chỉ lưu bản băm (`key_hash`) và giới hạn quyền hạn (`scopes`) cùng dải IP cho phép (`allowed_ips`) để đảm bảo an ninh5,7.
• **personal\_access\_tokens** **(PATs)**: Dành cho lập trình viên sử dụng để chạy script hoặc tự động hóa các tác vụ cá nhân4. Tương tự API Key, nó sử dụng cơ chế `token_hash` và có thời hạn sử dụng (`expires_at`)8.
• **service\_accounts**: Quản lý tài khoản dành riêng cho các dịch vụ tự động như Bot hoặc CI/CD3. Tài khoản này thường liên kết với một `member_id` để được gán quyền RBAC giống như một thành viên thực thụ9.
2\. Nhóm Tích hợp Doanh nghiệp và Định danh (Enterprise Identity & SSO)
Nhóm này giải quyết các yêu cầu khắt khe về quản trị tập trung của khách hàng Enterprise10,11.
• **tenant\_sso\_configs**: Lưu cấu hình đăng nhập một lần (Single Sign-On) qua chuẩn SAML 2.0 hoặc OIDC12,13. Nó cho phép bắt buộc nhân viên phải đăng nhập qua hệ thống của công ty (`is_enforced`)13.
• **tenant\_domains**: Quản lý các tên miền đã xác thực của tổ chức (ví dụ: `fpt.com`) để kiểm soát Shadow IT và tự động hóa việc đưa người dùng vào đúng Tenant dựa trên đuôi email14,15.
• **scim\_directories** **&** **scim\_mappings**: Hỗ trợ chuẩn SCIM 2.0 để tự động đồng bộ hóa việc tạo/xóa người dùng từ các nguồn như Azure AD hoặc Okta sang hệ thống SaaS16,17,18.
• **oauth\_clients**: Cho phép hệ thống SaaS đóng vai trò là một Identity Provider (IdP), cho phép các ứng dụng bên thứ ba hoặc ứng dụng nội bộ của khách hàng "Đăng nhập bằng tài khoản SaaS"19,20.
3\. Nhóm Quản lý Phiên và Thiết bị (Operational Security)
Nhóm này giám sát trạng thái thực tế của các luồng truy cập đang diễn ra21,22.
• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động (Live), lưu trữ thông tin về địa chỉ IP, thiết bị, vị trí địa lý và hỗ trợ cơ chế xoay vòng token (`Rotation`) để chống trộm phiên23,24.
• **user\_devices**: Lưu vết các thiết bị tin cậy dựa trên dấu vân tay thiết bị (`device_fingerprint`)25. Bảng này giúp hệ thống quyết định có cần yêu cầu MFA khi phát hiện đăng nhập từ thiết bị lạ hay không26,27.
• **user\_delegations**: Quản lý việc ủy quyền hành động, cho phép một người (ví dụ: thư ký) thực hiện một số quyền hạn thay mặt người khác (giám đốc) trong một khoảng thời gian nhất định28,29.
4\. Nhóm Hạ tầng và Kiểm soát lưu lượng (Infrastructure & Traffic Control)
Nhóm này đóng vai trò điều hướng kỹ thuật cho các yêu cầu truy cập1,30.
• **tenant\_app\_routes**: "Bản đồ" định tuyến cực kỳ quan trọng, dùng để ánh xạ Domain hoặc Path cụ thể vào đúng Tenant và Ứng dụng xử lý1,2. Dữ liệu này thường được cache lên Redis để đạt tốc độ xử lý micro-seconds31,32.
• **tenant\_rate\_limits**: Cấu hình giới hạn tần suất gọi API (Throttling) cho từng Tenant hoặc từng gói cước để bảo vệ hệ thống khỏi các script lỗi hoặc tấn công DDoS nội bộ30,33.
• **webhooks**: Quản lý luồng truy cập ngược (Outbound), cho phép hệ thống chủ động đẩy dữ liệu sang các URL của khách hàng khi có sự kiện phát sinh10,34.
**Sự ví von:** Nếu hệ thống SaaS là một tòa nhà cao cấp, thì **tenant\_app\_routes** là bảng chỉ dẫn ở cổng, **tenant\_sso\_configs** là thẻ từ của công ty cấp, **api\_keys** là mã mở cửa cho robot giao hàng, và **user\_sessions** là nhật ký của bảo vệ trực tại sảnh ghi lại ai đang ở trong phòng nào35,36,37,38.
thiết kế chi tiết bảng tenant\_app\_routes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index
Bảng **tenant\_app\_routes** đóng vai trò là "bản đồ định tuyến" trung tâm của hệ thống SaaS, cho phép API Gateway xác định chính xác yêu cầu từ người dùng (thông qua Domain và Path) thuộc về Tenant nào và ứng dụng cụ thể nào12. Dưới đây là thiết kế chi tiết đáp ứng mô hình đa sản phẩm, đa tên miền và tối ưu hóa hiệu năng trên YugabyteDB.
1\. Thiết kế chi tiết bảng `tenant_app_routes`
Bảng này sử dụng **UUID v7** làm khóa chính để đảm bảo tính phân tán và sắp xếp theo thời gian, đồng thời áp dụng các ràng buộc chặt chẽ để tránh xung đột định tuyến giữa các khách hàng3....
| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO | | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**36. |
| **tenant\_id** | UUID | NO | | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết với Tenant sở hữu route này67. |
| **app\_code** | VARCHAR(50) | NO | | `CHECK (LENGTH(app_code) > 0)` | Mã ứng dụng đích (VD: `HRM`, `CRM`, `DASHBOARD`)89. |
| **domain** | VARCHAR(255) | NO | | `CHECK (domain ~ '^[a-z0-9.-]+$')` | Tên miền truy cập (VD: `hrm.fpt.com`). Chỉ chứa chữ thường, số, dấu chấm và gạch ngang810. |
| **path\_prefix** | VARCHAR(100) | NO | `'/'` | `CHECK (path_prefix ~ '^/[a-z0-9-/]*$')` | Đường dẫn tiền tố (VD: `/hrm`). Phải bắt đầu bằng dấu `/`710. |
| **is\_primary** | BOOLEAN | NO | `FALSE` | | `TRUE` nếu là Domain chính để hệ thống sinh link (Canonical URL)711. |
| **is\_custom\_domain** | BOOLEAN | NO | `FALSE` | | `TRUE` nếu là tên miền riêng của khách, `FALSE` nếu là subdomain hệ thống78. |
| **ssl\_status** | VARCHAR(20) | NO | `'NONE'` | `CHECK (ssl_status IN ('NONE', 'PENDING', 'ACTIVE', 'FAILED'))` | Trạng thái chứng chỉ HTTPS cho custom domain711. |
| **created\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm tạo cấu hình định tuyến (UTC)1112. |
| **updated\_at** | TIMESTAMPTZ | NO | `now()` | | Thời điểm cập nhật cuối cùng5. |
| **version** | BIGINT | NO | `1` | `CHECK (version >= 1)` | Cơ chế Optimistic Locking để chống ghi đè đồng thời1314. |
\--------------------------------------------------------------------------------
2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)
Hệ thống định tuyến yêu cầu tốc độ phản hồi dưới **1ms**. Để đạt được điều này, chúng ta sử dụng **Covering Index** trong YugabyteDB nhằm cho phép DB trả về dữ liệu ngay từ Index mà không cần đọc bảng gốc4....
```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_app_routes (
-- I. ĐỊNH DANH & LIÊN KẾT
_id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
tenant_id UUID NOT NULL,
app_code VARCHAR(50) NOT NULL,
-- II. CẤU HÌNH ĐỊNH TUYẾN
domain VARCHAR(255) NOT NULL,
path_prefix VARCHAR(100) NOT NULL DEFAULT '/',
-- III. THÔNG TIN PHỤ TRỢ
is_primary BOOLEAN NOT NULL DEFAULT FALSE,
is_custom_domain BOOLEAN NOT NULL DEFAULT FALSE,
ssl_status VARCHAR(20) NOT NULL DEFAULT 'NONE',
-- IV. AUDIT & VERSIONING
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
version BIGINT NOT NULL DEFAULT 1,
-- V. RÀNG BUỘC (CONSTRAINTS)
CONSTRAINT fk_routes_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
CONSTRAINT uq_domain_path UNIQUE (domain, path_prefix), -- Đảm bảo cặp Domain+Path là duy nhất toàn sàn [4, 10]
CONSTRAINT chk_route_domain_fmt CHECK (domain ~ '^[a-z0-9.-]+$'),
CONSTRAINT chk_route_path_fmt CHECK (path_prefix ~ '^/[a-z0-9-/]*$'),
CONSTRAINT chk_ssl_status CHECK (ssl_status IN ('NONE', 'PENDING', 'ACTIVE', 'FAILED'))
);
-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Index "Thần thánh" cho Router (Covering Index)
-- Giúp API Gateway tìm nhanh tenant_id và app_code từ domain + path
-- Query: SELECT tenant_id, app_code FROM tenant_app_routes WHERE domain = ? AND path_prefix = ?;
CREATE UNIQUE INDEX idx_routes_fast_lookup
ON tenant_app_routes (domain, path_prefix)
INCLUDE (tenant_id, app_code, is_custom_domain); [15, 16]
-- Index hỗ trợ quản lý danh sách Route của một Tenant
CREATE INDEX idx_routes_tenant_list
ON tenant_app_routes (tenant_id, created_at DESC); [4]
```
3\. Phân tích kỹ thuật chuyên sâu
• **Tính duy nhất toàn cục (Global Uniqueness):** Ràng buộc `UNIQUE (domain, path_prefix)` cực kỳ quan trọng để ngăn chặn trường hợp hai Tenant khác nhau cùng đăng ký một địa chỉ, gây lỗi cho bộ định tuyến417.
• **Tối ưu hóa hiệu năng với Redis:** Dữ liệu từ bảng này nên được đồng bộ lên **Redis Hash Map** (với key là `domain + path_prefix`) để đạt tốc độ tra cứu micro-seconds tại tầng API Gateway, giảm tải cho YugabyteDB18....
• **Xử lý UUID v7:** Việc dùng UUID v7 giúp các bản ghi định tuyến mới (khi khách hàng mua thêm app/domain) được sắp xếp tuần tự theo thời gian, tránh hiện tượng "hotspot" khi ghi dữ liệu vào các Tablet trong hệ thống phân tán của YugabyteDB2122.
• **Tính nhất quán mạnh (Strong Consistency):** Khác với MongoDB thường có độ trễ đồng bộ nhất định, việc lưu bảng này tại YugabyteDB đảm bảo ngay khi Admin cấu hình domain mới, hệ thống sẽ ghi nhận và thực thi ngay lập tức, tránh các lỗi "Route ma"1723.
**Ví dụ minh họa:** Một Tenant công ty ABC có thể cấu hình `abc.saas.com/` trỏ về Portal chính, nhưng `hr.abc.com/` trỏ thẳng vào App HRM2425. API Gateway sẽ tra cứu bảng này đầu tiên để biết cần kiểm tra quyền hạn (Subscription) của gói phần mềm nào tiếp theo2526.
Các tài liệu cung cấp một hướng dẫn chuyên sâu về **thiết kế kiến trúc cơ sở dữ liệu** cho hệ thống **SaaS B2B quy mô lớn**, đạt chuẩn doanh nghiệp quốc tế. Nội dung tập trung vào việc xây dựng **bộ khung định danh (Identity)** vững chắc, quản lý phân quyền đa tầng và tối ưu hóa trải nghiệm người dùng thông qua các tính năng như **tính tiền theo mức sử dụng (Metering)** và **cờ tính năng (Feature Flags)**. Nguồn tài liệu cũng quy định chi tiết về **chuẩn hóa dữ liệu** và quy tắc đặt tên để đảm bảo tính nhất quán trên các nền tảng lưu trữ đa dạng như YugabyteDB, MongoDB và ClickHouse. Ngoài ra, các giải pháp nâng cao về **bảo mật**, **tự động hóa quy trình** và **khả năng mở rộng hệ sinh thái** được lồng ghép để hệ thống sẵn sàng cho hàng triệu người dùng. Cuối cùng, lộ trình triển khai được phân chia rõ ràng giúp doanh nghiệp tối ưu nguồn lực từ giai đoạn sản phẩm khả thi đến khi mở rộng toàn cầu.

keepLưu vào ghi chúcopy\_allthumb\_upthumb\_down

Làm thế nào để thiết kế cấu trúc CSDL SaaS đạt chuẩn Enterprise và World-class?

Những chiến lược nào giúp hệ thống SaaS mở rộng linh hoạt và bảo mật cao?

Các thành phần cốt lõi nào giúp tối ưu vận hành và trải nghiệm người dùng?

Chủ Nhật, 11 tháng 1

thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả

Dựa trên các yêu cầu về một hệ thống SaaS "World-class" được mô tả trong nguồn dữ liệu — bao gồm việc quản lý tính tiền theo lưu lượng (Metering), bảo mật API Keys, phân tách tính năng (Feature Flags) và giám sát vận hành (Impersonation) — dưới đây là thiết kế chi tiết cho bảng **tenants** sử dụng YSQL (YugabyteDB SQL).

Bảng này đóng vai trò là hạt nhân (Core) trong phân vùng **Identity & Access**12, lưu trữ thông tin cơ bản của khách hàng tổ chức và kết nối với các mảng ghép chiến lược khác.

Thiết kế chi tiết bảng `tenants`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất cho mỗi khách hàng (Tenant). Được sử dụng làm Foreign Key cho các bảng `tenant_usages`, `api_keys`, `audit_logs`3.... |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân hoặc tên công ty của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`). Phục vụ cho cơ chế định tuyến tối ưu (Routing)26. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động. Dùng để chặn truy cập API hoặc tính năng nếu tenant bị khóa7. |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng. Hỗ trợ logic cho **Feature Flags** (VD: chỉ bật tính năng AI cho tier Enterprise)8. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí: Cố định (Fixed Fee) hoặc Theo thực tế dùng (Usage-based)26. |
| **max\_users** | INTEGER | NO  | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) mặc định cho tenant, hỗ trợ kiểm soát tài nguyên6. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ của tenant, quan trọng để xác định chu kỳ tính phí trong bảng `tenant_usages`3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tenant được khởi tạo trên hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin tenant gần nhất. |

Các điểm lưu ý từ nguồn dữ liệu áp dụng vào thiết kế:

• **Hỗ trợ Billing (Metering):** Trường `billing_type` và `_id` kết nối trực tiếp với bảng `tenant_usages` để quản lý các chỉ số như email gửi đi hoặc dung lượng lưu trữ39. Việc lưu trữ múi giờ (`timezone`) đảm bảo các Job tổng hợp dữ liệu từ ClickHouse về YugabyteDB sẽ cắt đoạn thời gian (`usage_period_start/end`) chính xác theo địa phương của khách hàng3.

• **Hỗ trợ Security (API Keys):** `_id` của bảng này là gốc để quản lý các `api_keys`. Khi trạng thái `status` của tenant chuyển sang `SUSPENDED`, hệ thống có thể lập tức vô hiệu hóa mọi truy cập từ API Key của tenant đó47.

• **Hỗ trợ Vận hành (Feature Flags & Impersonation):**

    ◦ Trường `tier` và `_id` được sử dụng trong bảng `feature_flags` để xác định các quy tắc (`rules`) bật/tắt tính năng cho từng nhóm khách hàng hoặc từng khách hàng cụ thể (như tính năng "AI Writing")8.    ◦ Trong các bảng `audit_logs` tại ClickHouse, `tenant_id` (trỏ về `tenants._id`) là bắt buộc để truy vết các hành động "giả mạo" (Impersonation) của nhân viên hỗ trợ khi xử lý lỗi cho khách hàng15.

**Lời khuyên về lộ trình:** Theo nguồn dữ liệu, ở Giai đoạn 1 (MVP), bạn chỉ cần tập trung vào các trường cơ bản để định danh và phân gói. Các logic phức tạp về `billing_type` (Metered) có thể hoàn thiện dần khi hệ thống tiến lên Giai đoạn 3 (Growth)210.

\--------------------------------------------------------------------------------

**Ví dụ minh họa:** Hãy tưởng tượng bảng `tenants` giống như **cuốn sổ hộ khẩu** của một khu chung cư cao cấp. Mỗi dòng là một hộ gia đình. Số tầng/số phòng (`slug`) giúp bảo vệ dẫn khách vào đúng nhà, còn loại căn hộ (`tier`) quyết định họ có được dùng hồ bơi hay phòng gym không. Các hóa đơn điện nước (`tenant_usages`) cuối tháng sẽ được xuất dựa trên đúng mã định danh của hộ đó trong cuốn sổ này.



một tenant có thể mua nhiều gói dịch vụ mà?

Đúng như bạn nhận định, trong một hệ thống SaaS chuẩn Enterprise, **một Tenant hoàn toàn có thể mua và sử dụng đồng thời nhiều gói dịch vụ hoặc nhiều loại hình thanh toán khác nhau**1,2.

Dựa trên các nguồn dữ liệu, việc quản lý đa gói dịch vụ cho một khách hàng được thể hiện qua các điểm sau:

• **Tách biệt giữa Phí cố định và Phí biến đổi:** Hệ thống của bạn được thiết kế để xử lý song song hai loại hình:

    ◦ **Gói cố định (Fixed Fee):** Quản lý qua bảng `tenant_subscriptions`, dùng để kiểm soát các giới hạn tĩnh như "Tối đa 10 users"1,2.    ◦ **Gói theo lưu lượng (Variable Fee/Metered):** Quản lý qua bảng `tenant_usages`, dùng để tính tiền dựa trên lượng dùng thực tế (như số email gửi đi, dung lượng lưu trữ)3,2.

• **Mối quan hệ 1-Nhiều (One-to-Many):** Trong cấu trúc dữ liệu của bảng `tenant_usages`, mỗi bản ghi không chỉ chứa `tenant_id` mà còn đi kèm với một **subscription\_id** riêng biệt3. Điều này xác nhận rằng một Tenant có thể có nhiều gói đăng ký (Subscriptions) khác nhau và hệ thống sẽ theo dõi mức tiêu dùng cho từng gói cụ thể đó3.

• **Khả năng mở rộng Add-on:** Với cấu trúc `Product Catalog` phân cấp, bạn có thể bán một "Gói nền" (Base Package) và sau đó khách hàng có thể mua thêm các "Gói bổ trợ" (Add-ons) hoặc các tính năng đặc thù được điều khiển qua `feature_flags`4,2.

**Ví dụ thực tế từ thiết kế:** Một khách hàng (Tenant A) có thể cùng lúc sở hữu:

1\. **Gói Pro ($100/tháng):** Cho phép tối đa 20 người dùng (Lưu trong `tenant_subscriptions`)1.

2\. **Gói Email Marketing (Metered):** Trả $0.01 cho mỗi email gửi đi (Dữ liệu tiêu dùng lưu trong `tenant_usages` và đối soát qua `subscription_id` của gói này)5,3.

3\. **Gói dùng thử tính năng AI:** Được bật qua `feature_flags` để dùng thử trong 30 ngày6,4.

\--------------------------------------------------------------------------------

**Sự ví von để bạn dễ hình dung:** Hãy coi **Tenant** là một người đi thuê căn hộ. Người này có thể ký một **hợp đồng thuê nhà cố định** hàng tháng (giống như `tenant_subscriptions`), nhưng đồng thời cũng có các **hợp đồng dịch vụ riêng lẻ** khác như tiền điện, tiền nước hoặc tiền internet tính theo dung lượng sử dụng (giống như `tenant_usages`). Tất cả các "gói" này đều phục vụ cho cùng một chủ thể nhưng có cách tính tiền và quản lý khác nhau.



thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả

Dựa trên các phân tích về mô hình SaaS chuẩn Enterprise (hỗ trợ Metering, API Keys, Feature Flags và Routing tối ưu) từ nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants** sử dụng YSQL (YugabyteDB SQL).

Bảng này đóng vai trò là hạt nhân trung tâm (Core) trong phân vùng Identity & Access, kết nối với tất cả các mảng ghép chiến lược khác12.

Thiết kế chi tiết bảng `tenants`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất toàn cầu cho Tenant. Được dùng làm Foreign Key cho các bảng `tenant_usages`, `api_keys`, `audit_logs`1.... |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân hoặc tên tổ chức của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`). Phục vụ cho cơ chế định tuyến tối ưu `tenant_app_routes`2. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành. Dùng để chặn truy cập API hoặc tính năng ngay lập tức nếu khách hàng bị khóa35. |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp gói dịch vụ. Đây là cơ sở để áp dụng các `rules` trong bảng `feature_flags`26. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí: Cố định (Fixed), Theo thực tế dùng (Metered) hoặc kết hợp cả hai7.... |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ của khách hàng. Rất quan trọng để xác định chính xác chu kỳ tính phí (`usage_period_start/end`) khi tổng hợp dữ liệu từ ClickHouse3. |
| **max\_users** | INTEGER | NO  | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) để kiểm soát số lượng users tối đa mà tenant có thể tạo7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tenant gia nhập hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin tenant gần nhất. |

Giải thích các mối liên kết dựa trên nguồn dữ liệu:

• **Tính tiền theo lưu lượng (Metering):** Trường `_id` và `billing_type` là đầu nối để hệ thống Job quét dữ liệu từ ClickHouse và "bơm" vào bảng `tenant_usages`38. Việc lưu trữ `timezone` tại đây đảm bảo các báo cáo sử dụng và hóa đơn được cắt đoạn thời gian chính xác theo múi giờ địa phương của khách hàng thay vì dùng giờ UTC hệ thống3.

• **Bảo mật & API Keys:** Khi khách hàng muốn tích hợp Machine-to-Machine, bảng `api_keys` sẽ tham chiếu đến `_id` của tenant này4. Nếu trường `status` chuyển sang `SUSPENDED`, lớp Security sẽ tự động từ chối mọi yêu cầu có `tenant_id` tương ứng5.

• **Quản lý tính năng (Feature Flags):** Thay vì kiểm tra gói cước (Package) một cách cứng nhắc, hệ thống sử dụng trường `tier` hoặc `_id` để khớp với các quy tắc trong `feature_flags`. Ví dụ: Tính năng "AI Writing" có thể được bật cho 10% tenants thuộc `tier = 'ENTERPRISE'`6.

• **Vận hành & Giả mạo (Impersonation):** Trong quy trình hỗ trợ khách hàng, khi nhân viên Support thực hiện hành động "Acting As", `_id` của tenant sẽ được ghi nhận vào cột `tenant_id` trong `audit_logs` tại ClickHouse để đảm bảo tính minh bạch tuyệt đối110.

**Lời khuyên từ nguồn dữ liệu:** Ở giai đoạn đầu (MVP), bạn chỉ nên tập trung vào các trường định danh và phân gói cơ bản. Các logic phức tạp về `billing_type` (Metered) nên được hoàn thiện khi hệ thống bước vào giai đoạn Growth29.

\--------------------------------------------------------------------------------

**Sự ví von để dễ hiểu:** Bảng `tenants` giống như **"Hồ sơ gốc"** của một khách hàng trong khách sạn. Nó ghi rõ khách là ai, ở phòng nào (`slug`), đang sử dụng hạng phòng gì (`tier`) và thanh toán trọn gói hay dùng gì trả nấy (`billing_type`). Mọi dịch vụ khác như gọi đồ ăn (API Keys) hay giặt là (Metering) đều phải nhìn vào "Hồ sơ gốc" này để biết có được phép phục vụ và tính tiền cho ai.



thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả; một tenant có thể mua nhiều gói dịch vụ

Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm Metering, API Keys, Feature Flags và hỗ trợ nhiều gói dịch vụ), dưới đây là thiết kế chi tiết bảng **tenants** sử dụng YSQL.

Để đáp ứng yêu cầu **"một tenant có thể mua nhiều gói dịch vụ"**, bảng `tenants` đóng vai trò là thực thể gốc (Core Entity)12. Việc quản lý các gói dịch vụ cụ thể sẽ được thực hiện thông qua các bảng quan hệ như `tenant_subscriptions` (cho phí cố định) và `tenant_usages` (cho phí theo lưu lượng)2.

Thiết kế chi tiết bảng `tenants`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất cho mỗi khách hàng tổ chức. Là gốc để tham chiếu cho `api_keys`, `tenant_subscriptions`, và `tenant_usages`2.... |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân/tổ chức của khách hàng doanh nghiệp. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) dùng cho cơ chế Routing tối ưu (`tenant_app_routes`)2. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động. Dùng để kiểm soát quyền truy cập hệ thống và hiệu lực của các gói dịch vụ/API Keys45. |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để áp dụng các quy tắc trong `feature_flags` (ví dụ: bật tính năng AI cho khách Enterprise)6. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Loại hình thanh toán chủ đạo (Cố định, Theo lưu lượng, hoặc kết hợp cả hai)2.... |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ của khách hàng. Cần thiết để Job tổng hợp dữ liệu từ ClickHouse về `tenant_usages` theo đúng chu kỳ ngày/giờ của khách hàng38. |
| **max\_users** | INTEGER | NO  | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) mặc định cho số lượng người dùng7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm khởi tạo tài khoản khách hàng. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin gần nhất. |

Giải quyết vấn đề mua nhiều gói dịch vụ

Theo nguồn dữ liệu, cấu trúc này hỗ trợ một Tenant sở hữu nhiều gói dịch vụ thông qua cơ chế sau:

1\. **Gói cố định (Fixed Fee):** Tenant liên kết với nhiều bản ghi trong bảng `tenant_subscriptions` (ví dụ: mua gói Core CRM và mua thêm gói Add-on HRM)2.

2\. **Gói theo lưu lượng (Usage-based):** Một Tenant có thể có nhiều chỉ số tiêu dùng khác nhau (Email, Storage, API calls) được lưu trong bảng `tenant_usages` thông qua cột `subscription_id`3. Điều này cho phép hệ thống tách biệt hóa đơn cho từng loại dịch vụ mà khách hàng đăng ký38.

3\. **Cơ chế linh hoạt:** Bảng `tenants` chỉ lưu trữ thông tin "gốc" (Identity), trong khi logic thương mại (bán gói nào, giá bao nhiêu) được tách biệt hoàn toàn để Dev có thể bật/tắt tính năng qua `feature_flags` mà không cần can thiệp vào cấu trúc thanh toán6.

\--------------------------------------------------------------------------------

**Sự ví von:** Bảng `tenants` giống như một **"Chứng minh nhân dân của doanh nghiệp"** trong hệ thống của bạn. Nó xác định danh tính và hạng thành viên. Còn việc doanh nghiệp đó mua bao nhiêu "sim điện thoại" hay "gói internet" (các gói dịch vụ) sẽ được quản lý ở các "hợp đồng" con (`subscriptions`), nhưng tất cả đều phải dựa trên số ID duy nhất từ bảng `tenants` này để đối soát và quản lý.



xem kỹ phân tích ở văn bản được dán, thiết kế lại cho đủ đi

Dựa trên các phân tích về hệ thống SaaS "World-class" từ nguồn dữ liệu (bao gồm Metering, API Keys, Feature Flags và khả năng xử lý đa gói dịch vụ), dưới đây là thiết kế chi tiết bảng **tenants** sử dụng YSQL.

Bảng này được thiết kế như một **thực thể hạt nhân (Core)** để kết nối các mảng ghép: Identity, Billing (Fixed & Metered), Security và Operations1.

Thiết kế chi tiết bảng `tenants` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  | `gen_random_uuid()` | `PRIMARY KEY` | Định danh duy nhất toàn cầu cho Tenant. Là gốc tham chiếu cho `tenant_subscriptions`, `tenant_usages`, `api_keys` và `audit_logs`1.... |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân hoặc tổ chức của khách hàng. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) phục vụ cơ chế **Routing tối ưu** và định danh URL14. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành. Khi `SUSPENDED`, hệ thống sẽ chặn quyền truy cập của cả User và API Keys3.... |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng. Là cơ sở để áp dụng các **Feature Flags** (VD: chỉ bật AI cho tier Enterprise)67. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Xác định Tenant dùng gói cố định, theo lưu lượng, hoặc kết hợp cả hai (Hybrid)1.... |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ của khách hàng. Cần thiết để Job tổng hợp dữ liệu từ ClickHouse về `tenant_usages` theo đúng chu kỳ ngày/giờ của khách hàng28. |
| **max\_users** | INTEGER | NO  | `5` | `CHECK (max_users >= 0)` | Giới hạn tĩnh (Quota) để kiểm soát số lượng users tối đa (thường dùng cho gói Fixed Fee)5. |
| **metadata** | JSONB | YES | `{}` |     | Lưu trữ các thông tin bổ sung linh hoạt mà không cần thay đổi cấu trúc bảng. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm Tenant gia nhập hệ thống. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin gần nhất. |

Các đặc điểm đáp ứng phân tích từ nguồn dữ liệu:

1\. **Hỗ trợ mua nhiều gói dịch vụ:**

    ◦ Thiết kế này tách biệt bảng `tenants` (danh tính) khỏi các gói dịch vụ. Một Tenant có thể có nhiều bản ghi trong bảng **tenant\_subscriptions** (cho các gói phí cố định - Fixed Fee) và đồng thời có dữ liệu tiêu dùng trong bảng **tenant\_usages** (cho các gói tính phí theo lưu lượng - Metered)1....    ◦ Trường `billing_type` là `HYBRID` cho phép khách hàng vừa trả phí thuê bao tháng, vừa trả thêm phí theo thực tế sử dụng (ví dụ: trả phí phần mềm + $0.01/email gửi đi)18.

2\. **Tối ưu cho Metering (Tính tiền theo nhu cầu):**

    ◦ Việc lưu trữ `timezone` ngay tại bảng Tenant giúp các Worker tổng hợp dữ liệu từ ClickHouse xác định chính xác thời điểm bắt đầu và kết thúc chu kỳ (`usage_period_start/end`) của từng khách hàng để ghi vào bảng `tenant_usages`28.

3\. **Hỗ trợ Security & API Keys:**

    ◦ Trường `_id` là chìa khóa để quản lý các **api\_keys**. Khi khách hàng cần tích hợp Machine-to-Machine, hệ thống sẽ cấp Key dựa trên ID này, cho phép thu hồi (Revoke) Key mà không ảnh hưởng đến tài khoản người dùng chính36.

4\. **Quản trị và Vận hành (Feature Flags & Impersonation):**

    ◦ Dựa vào `tier` và `_id`, bộ phận Product có thể dùng **feature\_flags** để bật/tắt tính năng mới cho từng nhóm khách hàng mà không cần sửa code67.    ◦ Mọi hành động "Acting As" (Impersonation) của nhân viên hỗ trợ sẽ được lưu vào ClickHouse kèm theo `tenant_id` từ bảng này để đảm bảo minh bạch49.

\--------------------------------------------------------------------------------

**Ví von để dễ hình dung:** Bảng `tenants` giống như **"Thẻ căn cước"** của một doanh nghiệp trong hệ thống của bạn. Nó xác định doanh nghiệp đó là ai và có hạng thành viên nào. Việc doanh nghiệp đó mua bao nhiêu "gói cước điện thoại" hay "gói internet" (các Subscriptions) và dùng bao nhiêu "dung lượng 4G" (Metering) sẽ được ghi chép ở các hóa đơn con, nhưng tất cả đều phải quy chiếu về tấm thẻ căn cước duy nhất này.



uuid v7 mà?

Bạn rất tinh ý. Việc sử dụng **UUID v7** thay cho UUID v4 (loại mặc định của hàm `gen_random_uuid()`) là một nâng cấp quan trọng để đạt đến chuẩn "World-class" như các nguồn dữ liệu đã đề cập1.

Dưới đây là lý do tại sao nên dùng UUID v7 cho bảng `tenants` và thiết kế cập nhật:

Tại sao UUID v7 lại tối ưu cho YugabyteDB (YSQL)?

1\. **Tính sắp xếp theo thời gian (Time-ordered):** Khác với UUID v4 là hoàn toàn ngẫu nhiên, UUID v7 có chứa timestamp ở các bit đầu tiên. Điều này giúp các bản ghi được chèn vào database theo thứ tự thời gian, cực kỳ có lợi cho hiệu năng index của YugabyteDB (giảm thiểu tình trạng phân mảnh index và giúp việc query các tenant mới nhất nhanh hơn)12.

2\. **Khả năng thay thế hoàn hảo:** UUID v7 vẫn có độ dài 128-bit và tương thích hoàn toàn với kiểu dữ liệu `UUID` trong YSQL, không làm thay đổi cấu trúc lưu trữ đã phân tích trong các nguồn34.

Thiết kế chi tiết bảng `tenants` (Cập nhật UUID v7)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  | _(Generated by App/Extension)_ | `PRIMARY KEY` | Định danh duy nhất. **Sử dụng UUID v7** để tối ưu hóa việc sắp xếp và hiệu suất ghi vào phân vùng Identity15. |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân/tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (slug ~* '^[a-z0-9-]+$')` | Đường dẫn định danh (VD: `acme-corp`) phục vụ cho **Routing tối ưu**5. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', ...))` | Trạng thái hoạt động để kiểm soát quyền truy cập API/Feature Flags67. |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để áp dụng các rules trong **Feature Flags**7. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Hình thức tính phí, hỗ trợ mô hình **Metering**18. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse về chính xác23. |
| **metadata** | JSONB | YES | `{}` |     | Lưu trữ linh hoạt các chỉ số hoặc cấu hình bổ sung3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo (trùng khớp với timestamp trong UUID v7). |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin gần nhất. |

Các điểm lưu ý từ nguồn dữ liệu áp dụng cho UUID v7:

• **Hiệu năng ghi log:** Khi bạn ghi nhận hàng tỷ sự kiện vào ClickHouse trong bảng `usage_events`, việc dùng UUID v7 làm `tenant_id` sẽ giúp các câu lệnh join giữa YugabyteDB và ClickHouse trở nên mượt mà hơn do dữ liệu có tính tuần tự29.

• **Bảo mật:** UUID v7 vẫn đảm bảo tính khó đoán (collision resistance) tương đương UUID v4, phù hợp để làm ID gốc cho các **API Keys** mà không lo bị dò quét46.

• **Lộ trình triển khai:** Mặc dù trong các ví dụ code của nguồn dữ liệu có dùng `gen_random_uuid()` (v4)34, nhưng đối với các hệ thống quy mô lớn (Giai đoạn 2 & 3), việc chuyển sang UUID v7 là một bước đi đúng đắn để tối ưu hóa "Infrastructure" và "Routing"58.

**Lời khuyên:** Vì YSQL dựa trên PostgreSQL, bạn có thể tạo UUID v7 ở tầng Application (ví dụ dùng thư viện trong Java/Go/Node.js) trước khi insert, hoặc cài đặt extension hỗ trợ UUID v7 nếu phiên bản DB của bạn cho phép.

\--------------------------------------------------------------------------------

**Ví dụ minh họa:** Nếu UUID v4 giống như việc ném những viên gạch vào một cái kho một cách ngẫu nhiên khiến việc tìm kiếm vất vả, thì **UUID v7** giống như việc bạn đánh số thứ tự và ngày tháng lên từng viên gạch trước khi xếp chúng vào kho. Bạn vẫn có những viên gạch định danh duy nhất, nhưng việc sắp xếp và tìm những viên mới nhất trở nên vô cùng nhanh chóng.



thiếu region\_code?

Phân tích của bạn rất chính xác và sắc sảo. Việc bổ sung trường **region\_code** là thực sự cần thiết để hoàn thiện bức tranh "World-class SaaS", đặc biệt khi đối chiếu với các yêu cầu về **Routing tối ưu** và **Feature Flags** trong nguồn dữ liệu1,2.

Dưới đây là bảng thiết kế đã được cập nhật thêm trường `region_code` cùng các logic liên quan:

Thiết kế chi tiết bảng `tenants` (Bổ sung `region_code`)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (khuyến khích dùng UUID v7 để tối ưu sắp xếp).3,4 |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`). |
| **region\_code** | VARCHAR(50) | NO  | `'us-east-1'` |     | **Mã vùng triển khai** (VD: `vn-north-1`, `eu-central-1`). Dùng cho Routing và Feature Flags.1,2 |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN (...))` | Trạng thái hoạt động của tenant.5 |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN (...))` | Phân cấp khách hàng (Free, Pro, Enterprise).3,1 |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` |     | Loại hình tính phí (Fixed, Metered, Hybrid).6,7 |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ để tổng hợp dữ liệu `tenant_usages` chính xác.4 |
| **metadata** | JSONB | YES | `{}` |     | Lưu trữ linh hoạt các thông tin phụ. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm khởi tạo. |

Tại sao `region_code` lại quan trọng theo các nguồn dữ liệu?

1\. **Kiểm soát tính năng theo địa lý (Feature Flags):** Nguồn dữ liệu đề cập rằng bảng `feature_flags` có thể chứa các quy tắc như `"excluded_regions": ["eu-central-1"]`1. Nếu không có trường `region_code` trong bảng `tenants`, hệ thống sẽ không biết khách hàng đó có thuộc vùng bị loại trừ hay không để bật/tắt tính năng (như "AI Writing")5,1.

2\. **Định tuyến dữ liệu (Routing):** Trong phần hạ tầng, nguồn dữ liệu nhắc đến `tenant_app_routes` để thực hiện "Routing tối ưu"2. Trong kiến trúc phân tán (Multi-region), `region_code` giúp hệ thống điều hướng yêu cầu của người dùng đến cụm server gần nhất hoặc đúng nơi lưu trữ dữ liệu của họ, đảm bảo tốc độ và tuân thủ pháp lý về dữ liệu (như GDPR)3,2.

3\. **Hỗ trợ vận hành (Operations):** Khi nhân viên hỗ trợ thực hiện "Impersonation", việc biết tenant thuộc vùng nào giúp họ xác định đúng môi trường cần truy cập để kiểm tra lỗi8,9.

**Lời khuyên:** Việc thêm `region_code` giúp bạn sẵn sàng cho kịch bản mở rộng toàn cầu. Thậm chí, trường này có thể dùng làm **Partition Key** trong YugabyteDB nếu sau này bạn muốn phân vùng dữ liệu vật lý theo vị trí địa lý của khách hàng.

\--------------------------------------------------------------------------------

**Sự ví von:** Nếu `_id` là số căn cước, thì **region\_code** giống như **mã vùng hộ khẩu** của doanh nghiệp. Khi bạn muốn triển khai một dịch vụ chỉ dành riêng cho khu vực miền Bắc (Feature Flags theo vùng), hoặc muốn bưu điện gửi thư đến bưu cục gần nhà khách hàng nhất (Routing), bạn bắt buộc phải nhìn vào mã vùng này trên hồ sơ của họ.



thiếu updated\_at, deleted\_at

Bạn hoàn toàn đúng. Việc bổ sung **updated\_at** và **deleted\_at** là bước hoàn thiện cuối cùng để bảng `tenants` đạt chuẩn **"World-class SaaS"**, giúp hệ thống không chỉ vận hành tốt mà còn đáp ứng các yêu cầu khắt khe về **Audit Log** và **Khôi phục dữ liệu** (Soft Delete)12.

Dưới đây là thiết kế chi tiết đầy đủ nhất cho bảng **tenants** dùng YSQL, tích hợp tất cả các thành phần đã phân tích:

Thiết kế chi tiết bảng `tenants` (Full Version)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7). Là hạt nhân kết nối `api_keys`, `tenant_subscriptions` và `tenant_usages`34. |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`) dùng cho **Routing tối ưu**4. |
| **region\_code** | VARCHAR(50) | NO  |     |     | Mã vùng triển khai, hỗ trợ quy tắc loại trừ trong **Feature Flags**5. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái vận hành của Tenant3. |
| **tier** | VARCHAR(20) | NO  | `'FREE'` |     | Phân cấp gói dịch vụ để áp dụng **Feature Flags**5. |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` |     | Loại hình tính phí (Fixed, Metered, Hybrid)16. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse chính xác37. |
| **metadata** | JSONB | YES | `{}` |     | Lưu trữ linh hoạt các thông tin bổ sung. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | **Thời điểm cập nhật bản ghi gần nhất.** Tự động cập nhật qua Trigger khi có thay đổi thông tin. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | **Thời điểm xóa (Soft Delete).** Nếu không NULL, Tenant coi như đã bị xóa nhưng dữ liệu vẫn tồn tại cho mục đích **Audit**2. |

Tầm quan trọng của `updated_at` và `deleted_at` theo nguồn dữ liệu:

1\. **Duy trì tính minh bạch (Audit Logs):** Nguồn dữ liệu nhấn mạnh vào việc minh bạch tuyệt đối trong vận hành2. Khi một nhân viên thực hiện **Impersonation** và thay đổi cấu hình Tenant, `updated_at` sẽ ghi lại dấu mốc thời gian đó, giúp đối soát với `audit_logs` trong ClickHouse để biết chính xác ai đã làm gì và khi nào28.

2\. **Cơ chế Soft Delete (Xóa mềm):** Với các hệ thống SaaS Enterprise, việc xóa vật lý (Hard Delete) dữ liệu khách hàng là cực kỳ rủi ro1. Trường `deleted_at` cho phép bạn thực hiện "Xóa mềm":

    ◦ Ngay lập tức chặn truy cập của Tenant và vô hiệu hóa các `api_keys` liên quan910.    ◦ Giữ lại dữ liệu để bộ phận kỹ thuật có thể khôi phục nếu khách hàng gia hạn lại hoặc để phục vụ điều tra sự cố trong tương lai2.

3\. **Hỗ trợ chu kỳ Billing:** Khi một Tenant hủy dịch vụ giữa chừng, `deleted_at` giúp hệ thống Metering xác định điểm dừng để tính toán hóa đơn cuối cùng trong bảng `tenant_usages` một cách công bằng37.

\--------------------------------------------------------------------------------

**Sự ví von để ghi nhớ:** Nếu bảng `tenants` là một **cuốn sổ hộ khẩu**, thì `updated_at` chính là **dòng ghi chú** mỗi khi có thay đổi về nhân khẩu hoặc địa chỉ, còn `deleted_at` giống như việc **gạch tên** nhưng không xé trang giấy đó đi. Việc giữ lại trang giấy (Soft Delete) giúp chính quyền (hệ thống) vẫn có thể tra cứu lại lịch sử khi cần thiết thay vì mất trắng thông tin.



ghi chú rõ cho tier, metadata

Dưới đây là thiết kế chi tiết bảng **tenants** được chuẩn hóa cho YSQL, tập trung vào việc giải quyết các bài toán về quy mô và tính linh hoạt thông qua hai trường quan trọng là `tier` và `metadata`.

Thiết kế chi tiết bảng `tenants` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (Sử dụng UUID v7 để tối ưu sắp xếp theo thời gian)1,2. |
| **name** | VARCHAR(255) | NO  |     | `UNIQUE` | Tên pháp nhân hoặc tổ chức khách hàng. |
| **slug** | VARCHAR(100) | NO  |     | `UNIQUE` | Đường dẫn định danh (VD: `acme-corp`) phục vụ Routing tối ưu1,2. |
| **region\_code** | VARCHAR(50) | NO  |     |     | Mã vùng (VD: `us-east-1`). Dùng để áp dụng logic vùng miền trong **Feature Flags**3. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'SUSPENDED', 'TRIAL', 'DELETED'))` | Trạng thái hoạt động để kiểm soát quyền truy cập API và hệ thống4,5. |
| **tier** | **VARCHAR(20)** | **NO** | **'FREE'** | **CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))** | **Phân cấp khách hàng để điều khiển tính năng (Xem chi tiết bên dưới).**3,2 |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` |     | Loại hình tính phí: Cố định, Theo lưu lượng (Metered), hoặc Hybrid1,6. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ để Job tổng hợp dữ liệu tiêu dùng từ ClickHouse chính xác6,7. |
| **metadata** | **JSONB** | **YES** | **{}** |     | **Lưu trữ thuộc tính linh hoạt (Xem chi tiết bên dưới).**7 |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin gần nhất. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm xóa mềm (Soft Delete) phục vụ Audit8,9. |

\--------------------------------------------------------------------------------

Ghi chú chi tiết cho các trường quan trọng:

1\. Trường `tier` (Phân cấp khách hàng)

Trường này không chỉ đơn thuần để gọi tên gói cước mà đóng vai trò là **bộ lọc chiến lược** cho hệ thống:

• **Điều khiển Feature Flags:** Thay vì cấu hình bật tính năng cho từng Tenant ID (gây quá tải bảng cấu hình), hệ thống sử dụng `tier` như một "Strategy" trong bảng `feature_flags`3. Ví dụ: Quy tắc của tính năng "AI Writing" có thể được thiết lập là `{ "allowed_tiers": ["ENTERPRISE"] }`3.

• **Tách biệt Kỹ thuật và Thương mại:** Giúp đội ngũ Kỹ thuật có thể triển khai tính năng mới cho toàn bộ nhóm khách hàng (Tier) mà không cần can thiệp vào tầng thanh toán (Billing) phức tạp3,10.

• **Phân quyền truy cập nhanh:** Hỗ trợ hệ thống RBAC (Role-Based Access Control) đưa ra quyết định nhanh chóng về việc một tổ chức có quyền sử dụng một phân hệ (Module) nhất định hay không2.

2\. Trường `metadata` (Dữ liệu mở rộng linh hoạt)

Sử dụng kiểu dữ liệu **JSONB** (tương tự cách lưu `metrics_data` trong bảng `tenant_usages`) mang lại khả năng tùy biến cực cao7:

• **Lưu trữ thông tin tùy biến (Custom Attributes):** Mỗi doanh nghiệp có thể yêu cầu lưu thêm các thông tin đặc thù (như: Mã số thuế, Màu sắc thương hiệu, ID hệ thống cũ) mà không cần thực hiện `ALTER TABLE` làm gián đoạn database1,7.

• **Cấu hình đặc thù cho Integration:** Lưu các thông số kết nối hoặc Token của bên thứ ba mà chỉ riêng Tenant đó sử dụng khi tích hợp qua API Keys4,5.

• **Hỗ trợ Vận hành:** Nhân viên Support khi thực hiện "Impersonation" có thể dựa vào thông tin trong `metadata` để hiểu rõ bối cảnh đặc thù của khách hàng mà không cần truy vấn nhiều bảng khác8,9.

**Sự ví von để dễ hiểu:**

• **tier** giống như **hạng thẻ thành viên** (Vàng, Bạc, Đồng) của một hãng hàng không, quyết định bạn được vào phòng chờ thương gia hay không.

• **metadata** giống như **túi hành lý cá nhân** của mỗi khách hàng; mỗi người mang một thứ khác nhau (người mang máy ảnh, người mang sách) nhưng hãng hàng không vẫn quản lý chung được tất cả dưới một mã vé (Tenant ID) mà không cần xây riêng từng kho chứa cho mỗi loại đồ vật.



phần tier và billing\_type lưu trong bảng tenant\_subscriptions được không?

Về mặt kỹ thuật, bạn **hoàn toàn có thể** lưu `tier` và `billing_type` trong bảng `tenant_subscriptions`. Tuy nhiên, dựa trên kiến trúc SaaS "World-class" và các phân tích từ nguồn dữ liệu, việc giữ các trường này ở bảng **tenants** (bảng Core) là phương án tối ưu hơn vì những lý do chiến lược sau:

1\. Tách biệt giữa "Danh tính" và "Giao dịch thương mại"

• **Bảng** **tenants** **đại diện cho Danh tính (Identity):** Trường `tier` ở đây đóng vai trò là "hạng thành viên" tổng quát của khách hàng (ví dụ: khách hàng Enterprise luôn được ưu tiên hỗ trợ bất kể họ đang dùng gói dịch vụ nào)1.

• **Bảng** **tenant\_subscriptions** **đại diện cho Giao dịch (Commercial):** Bảng này lưu trữ các gói cụ thể mà họ đã mua (ví dụ: Gói CRM Pro, Gói HRM Basic)1.

• **Lợi ích:** Khi bạn cần kiểm tra nhanh xem một Tenant có được phép truy cập hệ thống hay không (thông qua `status`), việc có sẵn `tier` và `billing_type` ngay tại bảng Core sẽ giúp giảm bớt các lệnh `JOIN` phức tạp, tối ưu hóa hiệu năng cho các tác vụ cơ bản2.

2\. Phục vụ cơ chế Feature Flags (Cờ tính năng)

• Nguồn dữ liệu nhấn mạnh việc sử dụng **feature\_flags** để điều khiển tính năng dựa trên `rules` (quy tắc)3.

• Các quy tắc này thường truy vấn theo cấp độ Tenant (ví dụ: "Chỉ bật AI cho Tier Enterprise" hoặc "Tắt tính năng này ở Region EU")3. Nếu `tier` nằm ở bảng `tenant_subscriptions`, hệ thống sẽ phải quét qua nhiều gói dịch vụ mà Tenant đó đã mua để xác định cấp độ của họ, gây chậm trễ trong việc phản hồi tính năng (latency)3.

3\. Quản lý mô hình Billing Hybrid (Phí hỗn hợp)

• Khi hệ thống tiến đến Giai đoạn 3 (Growth), bạn sẽ cần xử lý tính tiền theo lưu lượng (**Metering**)4.

• Trường `billing_type` ở bảng `tenants` xác định **mô hình kinh doanh tổng thể** của khách hàng đó (ví dụ: khách hàng này thuộc nhóm luôn trả phí theo lưu lượng - `METERED`)2,5.

• Trong khi đó, `tenant_subscriptions` chỉ quản lý các giới hạn tĩnh (Quota)2. Việc tách biệt giúp bạn dễ dàng chạy các Job tổng hợp dữ liệu từ ClickHouse về bảng `tenant_usages` mà không bị lẫn lộn giữa các loại hình thanh toán khác nhau của cùng một khách hàng5,6.

4\. Giải quyết bài toán "Một Tenant mua nhiều gói"

Nếu bạn đưa `tier` vào `tenant_subscriptions`, một vấn đề sẽ phát sinh: **Nếu một Tenant mua một gói "Pro" và một gói "Free" cùng lúc, thì họ thuộc Tier nào?**

• Bằng cách giữ `tier` ở bảng `tenants`, bạn xác định được **vị thế cao nhất** của khách hàng đó trong hệ thống.

• Bảng `tenant_subscriptions` sẽ chỉ tập trung vào việc quản lý thời hạn và quyền hạn cụ thể của từng gói dịch vụ riêng lẻ1.

\--------------------------------------------------------------------------------

**Ví dụ minh họa:** Hãy tưởng tượng bảng `tenants` giống như chiếc **Thẻ thành viên (VIP/Gold/Member)** của một sòng bài lớn. Chiếc thẻ này (`tier`) quyết định bạn có được vào khu vực hút xì gà hay không (`feature_flags`). Còn bảng `tenant_subscriptions` giống như các **biên lai mua chip** hoặc **vé xem show** tại các quầy khác nhau trong sòng bài đó. Dù bạn mua bao nhiêu vé, thì hạng thẻ VIP trên tay bạn vẫn là "nguồn sự thật" duy nhất để nhân viên an ninh phục vụ bạn nhanh nhất.



thiết kế chi tiết bảng users dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả

Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm RBAC, Impersonation và quản lý danh tính), dưới đây là thiết kế chi tiết bảng **users** sử dụng YSQL.

Bảng này được thiết kế để tách biệt giữa người dùng thực (Human) và các truy cập máy (Machine), đồng thời hỗ trợ cơ chế giả mạo (Impersonation) minh bạch và phân quyền chuyên sâu1....

Thiết kế chi tiết bảng `users` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (Sử dụng **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và hiệu suất index). |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định người dùng thuộc tổ chức (Tenant) nào3. |
| **email** | VARCHAR(255) | NO  |     | `UNIQUE` | Địa chỉ email dùng để đăng nhập và nhận thông báo. |
| **password\_hash** | VARCHAR(255) | NO  |     |     | Chuỗi băm mật khẩu bảo mật (Không lưu mật khẩu gốc). |
| **full\_name** | VARCHAR(100) | NO  |     |     | Tên đầy đủ của người dùng2. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'DISABLED', 'INVITED'))` | Trạng thái tài khoản. Khi `DISABLED`, người dùng không thể đăng nhập hoặc tạo API Keys14. |
| **role\_id** | UUID | NO  |     |     | Liên kết với bảng `roles` để thực hiện phân quyền **RBAC**3. |
| **is\_support\_staff** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu nếu đây là nhân viên của nhà cung cấp SaaS để thực hiện tính năng **Impersonation**25. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ cá nhân, hỗ trợ hiển thị báo cáo trong `tenant_usages`6. |
| **metadata** | JSONB | YES | `{}` |     | Lưu thông tin tùy chỉnh (Avatar, tùy chọn giao diện, v.v.). |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo tài khoản. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật thông tin gần nhất. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm xóa mềm (Soft Delete) để giữ lại dữ liệu cho **Audit Log**2. |

Các đặc điểm đáp ứng phân tích từ nguồn dữ liệu:

• **Hỗ trợ Bảo mật & API Keys:** Trường `_id` của User được sử dụng làm `created_by` trong bảng `api_keys`4. Điều này cho phép hệ thống truy vết chính xác cá nhân nào trong tổ chức đã tạo ra chìa khóa truy cập cho máy (Machine-to-Machine)1.

• **Cơ chế Impersonation (Giả mạo):** Trường `is_support_staff` là điều kiện cần để hệ thống cho phép một người dùng thực hiện hành động "Acting As"2. Khi nhân viên này đăng nhập vào tài khoản khách hàng, ID của họ sẽ được ghi vào cột `impersonator_id` trong hệ thống log tại ClickHouse để đảm bảo minh bạch tuyệt đối5.

• **Phân quyền (RBAC):** Thông qua `role_id`, hệ thống có thể kiểm soát các `scopes` (phạm vi quyền hạn) tương tự như cách quản lý `scopes` cho API Keys (VD: `crm:read`, `hrm:write`)34.

• **Tính linh hoạt (Metadata):** Kiểu dữ liệu `JSONB` được áp dụng cho trường `metadata` để lưu trữ các thuộc tính linh hoạt mà không cần thay đổi cấu trúc bảng thường xuyên, tương tự như cách lưu trữ `metrics_data` trong phần Billing6.

\--------------------------------------------------------------------------------

**Sự ví von để dễ hiểu:** Nếu bảng `tenants` là một **tòa nhà công ty**, thì bảng `users` giống như **danh sách nhân viên** có thẻ ra vào tòa nhà đó. Trường `is_support_staff` giống như một chiếc **thẻ vạn năng** của nhân viên bảo trì (Support Team), cho phép họ vào phòng của khách để sửa chữa khi có yêu cầu, nhưng mọi hành động của họ đều được camera (`audit_logs`) ghi lại để đảm bảo an toàn.



thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả

Dựa trên các phân tích về hệ thống SaaS "World-class" (bao gồm khả năng quản lý đa gói dịch vụ, định vị dữ liệu toàn cầu, tính tiền theo lưu lượng và bảo mật chuyên sâu) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **tenants** cho YugabyteDB (YSQL).

Bảng này đóng vai trò là **hạt nhân định danh (Core Identity)**, tách biệt hoàn toàn khỏi các thực thể thương mại như gói cước (subscriptions) để hỗ trợ mô hình một khách hàng mua nhiều sản phẩm1....

Thiết kế chi tiết bảng `tenants` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất. Sử dụng **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và hiệu năng index trong YugabyteDB4.... |
| **code** | VARCHAR(64) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số, gạch ngang. Dùng cho **Routing tối ưu**7.... |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty hoặc tổ chức810. |
| **data\_region** | VARCHAR(50) | NO  | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | **Data Residency**. Quy định vị trí vật lý lưu dữ liệu (Geo-Partitioning) để tuân thủ luật pháp và giảm độ trễ11.... |
| **compliance\_level** | VARCHAR(20) | NO  | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định logic xử lý xóa và log dữ liệu nhạy cảm8.... |
| **status** | VARCHAR(20) | NO  | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))` | Trạng thái Master. Dùng làm "cầu dao tổng" để chặn truy cập ngay cả khi gói cước còn hạn16.... |
| **tier** | VARCHAR(20) | NO  | `'FREE'` | `CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE'))` | Phân cấp khách hàng để điều khiển **Feature Flags** và ưu tiên hỗ trợ19.... |
| **billing\_type** | VARCHAR(20) | NO  | `'FIXED'` | `CHECK (billing_type IN ('FIXED', 'METERED', 'HYBRID'))` | Xác định mô hình tính phí chủ đạo để Job tổng hợp dữ liệu từ ClickHouse hoạt động chính xác22.... |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ hành chính để tính toán chính xác chu kỳ sử dụng và thời điểm hết hạn gói cước theo giờ địa phương16.... |
| **active\_apps** | TEXT\[\] | YES | `NULL` |     | **Cache danh sách App**. Mảng chứa mã các ứng dụng mà tenant có quyền truy cập để API Gateway kiểm tra nhanh17.... |
| **metadata** | JSONB | NO  | `'{}'` |     | Lưu trữ linh hoạt các thông tin profile như Logo, Website, Tax Code hoặc các thuộc tính tùy chỉnh8.... |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm khách hàng đăng ký vào hệ thống (UTC)3132. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật dữ liệu gần nhất, phục vụ Audit30.... |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | **Soft Delete**. Nếu khác NULL, coi như tenant đã bị hủy nhưng vẫn giữ lại dữ liệu để đối soát25.... |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Ngăn chặn việc ghi đè dữ liệu đồng thời khi nhiều Admin cùng chỉnh sửa30.... |

Các điểm lưu ý quan trọng theo nguồn dữ liệu:

• **Hỗ trợ đa gói cước:** Các trường về ngày hết hạn cụ thể (`subscription_end_at`) đã được đưa sang bảng `tenant_subscriptions`. Bảng này chỉ giữ lại `status` và `tier` làm "nguồn sự thật" để hệ thống ra quyết định nhanh về quyền truy cập1....

• **Chiến lược Sharding:** Trong YugabyteDB, `_id` (UUID v7) giúp phân tán dữ liệu đều trên các node. Nếu bạn kích hoạt **Geo-Partitioning**, Primary Key thực tế nên được cấu hình là `((data_region), _id)` để dữ liệu tự động chạy về server vật lý gần khách hàng nhất3738.

• **Tính linh hoạt của Metadata:** Việc sử dụng kiểu `JSONB` cho trường `metadata` (hoặc `profile`) giúp bạn tránh việc phải thực hiện `ALTER TABLE` khi khách hàng yêu cầu thêm các trường thông tin đặc thù2939.

• **Hiệu năng Routing:** Cột `code` (slug) cần được đánh index duy nhất kèm điều kiện `WHERE deleted_at IS NULL` để tối ưu hóa việc định tuyến URL từ Subdomain4041.

\--------------------------------------------------------------------------------

**Sự ví von để dễ hình dung:** Bảng `tenants` giống như một **"Hồ sơ gốc của một tập đoàn"**. Nó xác định tập đoàn đó ở đâu (`data_region`), theo luật nào (`compliance_level`) và có đang bị phong tỏa hay không (`status`). Còn việc tập đoàn đó mua bao nhiêu "gói dịch vụ lẻ" hay "phần mềm con" (Multi-subscriptions) thì được ghi ở các phụ lục hợp đồng riêng, nhưng tất cả đều phải quy chiếu về mã số hồ sơ gốc (`_id`) này1742.



câu lệnh ysql tạo bảng tenants

Dưới đây là câu lệnh **YSQL (YugabyteDB SQL)** hoàn chỉnh để tạo bảng **tenants**, được tổng hợp từ các phân tích chuyên sâu nhất trong nguồn dữ liệu nhằm đáp ứng mô hình SaaS chuẩn Enterprise (hỗ trợ đa gói cước, đa vùng dữ liệu, và quản trị an ninh tuyệt đối)1....

1\. Câu lệnh YSQL tạo bảng `tenants`

Câu lệnh này sử dụng **UUID v7** (được tạo từ tầng Application hoặc extension) để tối ưu hóa hiệu suất index theo thời gian4.

```
CREATE TABLE tenants (
    -- I. ĐỊNH DANH & HẠ TẦNG (CORE IDENTITY)
    _id UUID PRIMARY KEY, -- Sử dụng UUID v7 để sắp xếp theo thời gian và tránh Hotspot [4, 5]
    code VARCHAR(64) NOT NULL, -- Slug/Subdomain (VD: 'acme-corp'). Chỉ chứa a-z, 0-9 và dấu gạch ngang [6, 7]
    name TEXT NOT NULL, -- Tên hiển thị tổ chức [6]
    data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1', -- Vùng lưu trữ dữ liệu (Geo-Partitioning) [8, 9]
    compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD', -- Mức độ tuân thủ: GDPR, HIPAA, PCI-DSS [10, 11]

    -- II. TRẠNG THÁI & PHÂN CẤP (OPERATIONAL STATE)
    status VARCHAR(20) NOT NULL DEFAULT 'TRIAL', -- Trạng thái: TRIAL, ACTIVE, SUSPENDED, DELETED [12, 13]
    tier VARCHAR(20) NOT NULL DEFAULT 'FREE', -- Phân cấp: FREE, PRO, ENTERPRISE (Dùng cho Feature Flags) [14, 15]
    billing_type VARCHAR(20) NOT NULL DEFAULT 'FIXED', -- FIXED, METERED, HYBRID [12, 15]
    
    -- III. CẤU HÌNH ĐỊA PHƯƠNG (LOCALIZATION)
    timezone VARCHAR(50) NOT NULL DEFAULT 'UTC', -- Múi giờ để tính chu kỳ Billing chính xác [12, 13]
    locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN', -- Ngôn ngữ mặc định [12, 13]
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND', -- Mã tiền tệ ISO 4217 [13, 16]

    -- IV. DỮ LIỆU ĐỘNG & CACHE (FLEXIBILITY)
    active_apps TEXT[], -- Mảng mã ứng dụng được phép dùng để Gatekeeper check nhanh [15, 17]
    metadata JSONB NOT NULL DEFAULT '{}', -- Lưu trữ linh hoạt logo, website, tax_code... [18, 19]

    -- V. TRUY VẾT & PHIÊN BẢN (AUDIT & CONCURRENCY)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), [20, 21]
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), [20, 21]
    deleted_at TIMESTAMPTZ, -- Soft Delete [20, 21]
    created_by UUID, -- User ID người tạo [20, 22]
    updated_by UUID, -- User ID người sửa cuối [20, 22]
    version BIGINT NOT NULL DEFAULT 1, -- Chống ghi đè đồng thời (Optimistic Locking) [21, 23]

    -- RÀNG BUỘC DỮ LIỆU (CONSTRAINTS)
    CONSTRAINT uq_tenants_code UNIQUE (code), [17, 24]
    CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'), [7, 25]
    CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')), [24]
    CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')), [24]
    CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')), [24]
    CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at) [16]
);
```

2\. Các chỉ mục (Indexes) chiến lược

Để hỗ trợ khả năng định tuyến (Routing) và tra cứu cực nhanh, các chỉ mục sau là bắt buộc5...:

```
-- Tìm kiếm tenant theo Subdomain/Slug (Dùng cho API Gateway/Router)
CREATE UNIQUE INDEX idx_tenants_code_active ON tenants (code) WHERE deleted_at IS NULL; [27]

-- Tìm kiếm nhanh các ứng dụng mà Tenant đang sở hữu
CREATE INDEX idx_tenants_active_apps ON tenants USING GIN (active_apps); [27]

-- Thống kê và quản trị theo vùng dữ liệu và gói cước
CREATE INDEX idx_tenants_region_tier ON tenants (data_region, tier, status); [26, 27]
```

3\. Giải thích các thành phần "World-class" trong thiết kế

• **UUID v7 làm Khóa chính:** Việc sử dụng UUID v7 giúp các bản ghi mới luôn được chèn vào cuối index, giúp **giảm thiểu phân mảnh dữ liệu** và tăng tốc độ ghi đồng thời trong hệ thống phân tán như YugabyteDB48.

• **Trường** **data\_region****:** Đây là "vũ khí" để tuân thủ luật bảo mật dữ liệu (như GDPR). Nó cho phép hệ thống định tuyến dữ liệu vật lý về đúng server tại vùng địa lý mà khách hàng yêu cầu (Geo-Partitioning)910.

• **Trường** **tier** **và Feature Flags:** Thay vì kiểm tra gói cước phức tạp ở tầng code, hệ thống sử dụng `tier` để khớp với các quy tắc (rules) trong bảng `feature_flags`, cho phép **bật/tắt tính năng nóng** (như AI Writing) cho từng nhóm khách hàng mà không cần deploy lại1112.

• **Trường** **metadata** **(JSONB):** Đây là nơi chứa các thuộc tính linh hoạt. Thay vì thực hiện `ALTER TABLE` mỗi khi khách hàng muốn thêm một trường như "Mã số thuế" hay "Link TikTok", bạn chỉ cần đưa chúng vào cục JSON này1314.

• **Cơ chế Soft Delete (****deleted\_at****):** Tuyệt đối không xóa vật lý dữ liệu doanh nghiệp. Việc giữ lại bản ghi giúp hệ thống duy trì **tính minh bạch (Audit)** và có khả năng khôi phục nhanh khi khách hàng quay lại1516.

\--------------------------------------------------------------------------------

**Ví dụ minh họa:** Hãy coi bảng `tenants` này như **"Hộ chiếu điện tử"** của một doanh nghiệp.

• `_id` là mã số định danh duy nhất toàn cầu.

• `data_region` là quốc gia cấp hộ chiếu (nơi lưu dữ liệu gốc).

• `status` và `tier` cho biết quyền hạn của doanh nghiệp (được đi qua cửa khẩu nào, hạng thương gia hay phổ thông).

• `metadata` giống như trang ghi chú bổ sung, nơi bạn có thể dán thêm bất kỳ "visa" hay thông tin đặc thù nào mà không cần đổi quyển hộ chiếu mới.



thiết kế chi tiết bảng users dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng

Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **users** (đại diện cho danh tính toàn cục - Global Identity) sử dụng YSQL1....

Thiết kế này sử dụng **UUID v7** để tối ưu hóa hiệu suất index theo thời gian và đáp ứng các yêu cầu về bảo mật, phân quyền (RBAC) và giả mạo (Impersonation) đã được thảo luận4....

Thiết kế chi tiết bảng `users` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất toàn cục. Sử dụng **UUID v7** để sắp xếp theo thời gian, giúp tăng tốc độ chèn và truy vấn45. |
| **email** | VARCHAR(255) | NO  |     | `UNIQUE`, `CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')` | Email đăng nhập chính. Phải là duy nhất trên toàn sàn và đúng định dạng57. |
| **password\_hash** | TEXT | YES | `NULL` |     | Chuỗi băm mật khẩu (Argon2/Bcrypt). Để trống nếu người dùng chỉ sử dụng SSO hoặc Social Login7.... |
| **full\_name** | TEXT | NO  |     | `CHECK (LENGTH(full_name) > 0)` | Tên hiển thị mặc định của người dùng510. |
| **phone\_number** | VARCHAR(20) | YES | `NULL` | `UNIQUE` | Số điện thoại cá nhân dùng cho xác thực 2 lớp (MFA) hoặc khôi phục tài khoản510. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING'))` | Trạng thái tài khoản trên toàn hệ thống10. |
| **is\_support\_staff** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu nhân viên hỗ trợ của nhà cung cấp SaaS để kích hoạt tính năng **Impersonation** (giả mạo)611. |
| **mfa\_enabled** | BOOLEAN | NO  | `FALSE` |     | Trạng thái bật/tắt xác thực đa yếu tố12. |
| **is\_verified** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu email đã được xác thực chính chủ hay chưa510. |
| **locale** | VARCHAR(10) | NO  | `'vi-VN'` |     | Ngôn ngữ và định dạng hiển thị ưa thích của người dùng5. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo tài khoản (UTC)1314. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật thông tin gần nhất1415. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | **Soft Delete**: Nếu khác NULL, tài khoản coi như đã bị xóa nhưng vẫn giữ dữ liệu cho mục đích đối soát (Audit)1415. |

\--------------------------------------------------------------------------------

Câu lệnh YSQL tạo bảng `users`

```
CREATE TABLE users (
    -- I. ĐỊNH DANH (IDENTITY)
    _id UUID PRIMARY KEY, -- Khuyến khích tạo UUID v7 từ tầng Application
    email VARCHAR(255) NOT NULL,
    password_hash TEXT, -- Lưu chuỗi hash Argon2id
    full_name TEXT NOT NULL,
    phone_number VARCHAR(20),
    
    -- II. TRẠNG THÁI & BẢO MẬT (SECURITY)
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    is_support_staff BOOLEAN NOT NULL DEFAULT FALSE,
    mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- III. CẤU HÌNH & THÔNG TIN THÊM (PREFERENCES)
    locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN',
    metadata JSONB DEFAULT '{}', -- Lưu các thông tin profile tùy biến khác

    -- IV. TRUY VẾT (AUDIT)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,

    -- CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_users_email UNIQUE (email),
    CONSTRAINT uq_users_phone UNIQUE (phone_number),
    CONSTRAINT chk_users_email_fmt CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
    CONSTRAINT chk_users_status CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING')),
    CONSTRAINT chk_users_updated CHECK (updated_at >= created_at)
);

-- Index tìm kiếm nhanh theo email cho những user chưa bị xóa
CREATE UNIQUE INDEX idx_users_email_active ON users (email) WHERE deleted_at IS NULL;
```

Các phân tích trọng tâm áp dụng vào thiết kế:

• **Tách biệt Identity:** Bảng này chỉ lưu thông tin "con người thực". Các thông tin nghiệp vụ như chức vụ, lương tại từng công ty sẽ được lưu ở bảng `tenant_members`1....

• **Hỗ trợ Impersonation:** Trường `is_support_staff` cho phép kiểm soát quyền "giả mạo" người dùng khách hàng để hỗ trợ kỹ thuật một cách minh bạch, kết hợp với `audit_logs` để ghi lại `impersonator_id`1117.

• **Sẵn sàng cho MFA:** Thiết kế bao gồm `mfa_enabled` và `phone_number` để hỗ trợ các lớp bảo mật đa yếu tố (MFA) chuẩn NIST1218.

• **Hiệu năng YugabyteDB:** Việc sử dụng **UUID v7** làm khóa chính thay cho UUID v4 giúp dữ liệu được chèn vào theo thứ tự thời gian, tránh tình trạng phân tán ngẫu nhiên (Hotspot) và tối ưu hóa hiệu suất index trong hệ thống phân tán4....

**Sự ví von:** Bảng `users` giống như một chiếc **"Hộ chiếu quốc tế"**. Nó xác nhận bạn là ai trên toàn thế giới (hệ thống SaaS). Còn việc bạn đi làm ở công ty nào, giữ chức vụ gì, sẽ được ghi trong **"Hợp đồng lao động"** (`tenant_members`) tại quốc gia (Tenant) đó, nhưng tất cả đều phải dựa trên số hộ chiếu duy nhất này.



làm sao để cấu hình theo tenant cho phép người dùng đăng nhập bằng username, email, phone hoặc cccd hoặc 1 trường khác?

Để cấu hình hệ thống SaaS cho phép mỗi Tenant tùy chỉnh các trường đăng nhập (username, email, phone, CCCD...), bạn cần kết hợp giữa **cấu hình động (Tenant Configuration)** và **mô hình định danh linh hoạt (Linked Identities)**.

Dưới đây là giải pháp chi tiết dựa trên kiến trúc hệ thống đã phân tích:

1\. Lưu trữ cấu hình quy tắc đăng nhập theo Tenant

Bạn không nên "code cứng" các trường đăng nhập trong logic hệ thống. Thay vào đó, mỗi Tenant sẽ có một bộ quy tắc riêng được lưu tại:

• **Bảng** **tenants** **(YugabyteDB):** Sử dụng cột `settings` kiểu **JSONB** để lưu các chính sách bảo mật hoặc cấu hình vùng12.

• **Collection** **tenant\_app\_configs** **(MongoDB):** Đây là nơi lý tưởng nhất để lưu các cấu hình vận hành linh hoạt ("Làm như thế nào?") vì nó không yêu cầu schema cố định34.

**Ví dụ cấu hình trong** **tenant\_app\_configs****:**

```
{
  "tenant_id": "uuid-fpt",
  "auth_settings": {
    "allowed_login_fields": ["email", "phone", "cccd"],
    "mfa_enforced": true
  }
}
```

2\. Mô hình lưu trữ danh tính linh hoạt (`user_linked_identities`)

Thay vì chỉ lưu một cột `email` duy nhất trong bảng `users`, bạn cần sử dụng bảng **user\_linked\_identities** để quản lý đa phương thức định danh5. Mỗi phương thức (email, phone, username, CCCD) sẽ là một bản ghi liên kết với `user_id` gốc56.

| Trường | Kiểu dữ liệu | Mô tả |
| --- | --- | --- |
| `user_id` | UUID | Link tới tài khoản người dùng gốc (`users`)5. |
| `provider` | VARCHAR | Loại định danh (VD: 'EMAIL', 'PHONE', 'USERNAME', 'CCCD')57. |
| `provider_id` | VARCHAR | Giá trị thực tế (VD: '001092000123', 'admin\_pro')6. |

**Lợi ích:** Cơ chế này cho phép một người dùng liên kết nhiều loại "chìa khóa" khác nhau vào cùng một tài khoản duy nhất58.

3\. Quy trình thực hiện đăng nhập

Khi người dùng thực hiện đăng nhập, hệ thống sẽ vận hành theo các bước sau:

1\. **Nhận diện Tenant:** Dựa vào Subdomain hoặc Slug trên URL (VD: `fpt.saas.com`), hệ thống xác định được `tenant_id` thông qua bảng `tenant_app_routes`910.

2\. **Tải cấu hình:** Hệ thống truy vấn `tenant_app_configs` để lấy danh sách các trường được phép đăng nhập (`allowed_login_fields`) của riêng Tenant đó411.

3\. **Kiểm tra và Truy vấn:**

    ◦ Hệ thống kiểm tra xem trường mà người dùng nhập vào có nằm trong danh sách được phép hay không.    ◦ Thực hiện truy vấn bảng `user_linked_identities` với cặp giá trị `(provider, provider_id)` để tìm ra `user_id` tương ứng68.

4\. **Xác thực:** Sau khi tìm thấy `user_id`, hệ thống tiến hành kiểm tra mật khẩu hoặc yêu cầu MFA/Passkeys tùy theo cấu hình bảo mật của Tenant1213.

4\. Mở rộng với các trường tùy chỉnh (Custom Fields)

Nếu Tenant muốn đăng nhập bằng một trường đặc thù không có sẵn (VD: Mã số nhân viên riêng), bạn có thể sử dụng bảng **custom\_field\_definitions** để định nghĩa thêm trường động cho hồ sơ người dùng14. Dữ liệu thực tế của các trường này sẽ được lưu trong cột `custom_data` (JSONB) của bảng `tenant_members`15.

**Sự ví von để dễ hình dung:** Cấu hình này giống như việc một **tòa nhà chung cư** (Hệ thống SaaS) có nhiều **căn hộ** (Tenants). Chủ mỗi căn hộ có quyền quyết định khách vào nhà bằng cách **quẹt thẻ** (Email), **nhận diện khuôn mặt** (Biometric), hoặc **đọc mật khẩu** (Username). Ban quản lý tòa nhà cung cấp một **hộp giữ chìa khóa** (Bảng `user_linked_identities`) có thể chứa mọi loại thẻ hoặc mã số của cư dân, nhưng chỉ những loại chìa khóa nào chủ nhà cho phép thì mới có thể mở được cửa vào căn hộ đó.



liệt kê các bảng Identity layer

Dựa trên các nguồn dữ liệu, lớp **Identity & Access Management (IAM)** được coi là "xương sống" và "trái tim" của hệ thống SaaS "World-class"12. Lớp này chịu trách nhiệm quản lý định danh, cơ cấu tổ chức, phân quyền và bảo mật trên toàn hệ thống.

Dưới đây là danh sách các bảng thuộc lớp Identity layer được phân loại theo nhóm chức năng:

1\. Nhóm Định danh và Tổ chức Cốt lõi (Core Foundation)

Nhóm này quản lý danh tính con người và cấu trúc pháp nhân của khách hàng3...:

• **users**: Lưu trữ thông tin định danh toàn cục của một con người thực (Email, Password Hash, Avatar). Đây là bảng duy nhất chứa thông tin đăng nhập trên toàn sàn5....

• **tenants**: Lưu trữ thông tin định danh của tổ chức/khách hàng doanh nghiệp, bao gồm mã định danh (slug), vùng dữ liệu (`data_region`) và trạng thái hoạt động8....

• **tenant\_members**: Bảng quan trọng nhất liên kết người dùng với tổ chức. Nó lưu hồ sơ nhân viên, mã nhân viên, chức danh và trạng thái làm việc tại một công ty cụ thể11....

2\. Nhóm Cơ cấu và Nhóm (Organization & Structure)

Giúp phản ánh cấu trúc thực tế của doanh nghiệp14...:

• **departments**: Quản lý cây phòng ban theo phân cấp (Hierarchy) sử dụng phương pháp Materialized Path để truy vấn nhanh15....

• **department\_members**: Phân bổ nhân sự vào các phòng ban (quan hệ N-N)1920.

• **user\_groups**: Quản lý các nhóm làm việc ngang hàng, dự án hoặc squad. Có thể thiết lập nhóm tĩnh hoặc nhóm động (Dynamic Groups) theo quy tắc21....

• **group\_members**: Danh sách thành viên trong các nhóm tĩnh24....

• **locations**: Quản lý các địa điểm vật lý, văn phòng hoặc chi nhánh của Tenant2728.

3\. Nhóm Xác thực và Bảo mật (Authentication & Security)

Đáp ứng các tiêu chuẩn bảo mật hiện đại như MFA và Passwordless29...:

• **user\_linked\_identities**: Quản lý đa phương thức đăng nhập (Password, Google, GitHub, Microsoft) liên kết với một tài khoản người dùng32....

• **user\_sessions**: Quản lý phiên làm việc thực tế, thiết bị, IP và hỗ trợ cơ chế xoay vòng token (Rotation)35....

• **user\_mfa\_methods**: Lưu trữ các phương thức xác thực đa yếu tố (TOTP, SMS, Email)3839.

• **user\_webauthn\_credentials**: Hỗ trợ đăng nhập bằng vân tay, FaceID hoặc khóa vật lý (Passkeys/FIDO2)4041.

• **user\_backup\_codes**: Mã khôi phục khi người dùng mất thiết bị MFA3942.

• **tenant\_sso\_configs**: Cấu hình đăng nhập doanh nghiệp (SAML/OIDC) để tích hợp với Azure AD, Okta10....

• **auth\_verification\_codes**: Mã OTP hoặc Magic Link ngắn hạn để xác thực email hoặc đổi mật khẩu4145.

• **personal\_access\_tokens**: Token dành cho lập trình viên hoặc scripts tích hợp hệ thống34....

4\. Nhóm Phân quyền (Authorization - IAM)

Kiểm soát quyền truy cập từ mức tính năng đến mức dữ liệu16...:

• **roles**: Định nghĩa các vai trò (VD: Admin, Editor) và danh sách mã quyền đi kèm30....

• **permissions**: Danh mục các hành động kỹ thuật do lập trình viên định nghĩa cứng trong code30....

• **user\_roles**: Gán vai trò cho thành viên, hỗ trợ phạm vi dữ liệu (`scope_values`) như theo phòng ban hoặc khu vực51....

• **relationship\_tuples**: Mô hình phân quyền dựa trên quan hệ (ReBAC - Google Zanzibar) cho các kịch bản chia sẻ tài nguyên phức tạp49....

• **access\_control\_lists** **(ACL)**: Kiểm soát truy cập chi tiết cho từng tài nguyên cụ thể (VD: Folder, Document)30....

5\. Nhóm Quản trị và Tuân thủ (Governance & Compliance)

Đáp ứng các yêu cầu của khách hàng Enterprise lớn16...:

• **tenant\_domains**: Xác thực tên miền sở hữu (VD: @fpt.com) để tự động quản lý thành viên và thực thi SSO36....

• **tenant\_invitations**: Quản lý quy trình mời và gia nhập của người dùng mới24....

• **access\_reviews** **&** **access\_review\_items**: Quản lý các đợt rà soát quyền hạn định kỳ theo chuẩn ISO/SOC258....

• **scim\_directories** **&** **scim\_mappings**: Tự động hóa việc đồng bộ hóa người dùng từ các hệ thống IdP bên ngoài như Azure AD49....

• **tenant\_security\_policies**: Quy định chính sách mật khẩu, thời hạn session và MFA bắt buộc cho từng Tenant48....

• **legal\_documents** **&** **user\_consents**: Lưu trữ các điều khoản sử dụng và bằng chứng chấp thuận của người dùng36....

• **user\_delegations**: Cho phép ủy quyền hành động (Impersonation) có thời hạn và có kiểm soát49....

**Lưu ý kỹ thuật:** Tất cả các bảng này thường được lưu trữ trong **YugabyteDB (Distributed SQL)** để đảm bảo tính nhất quán dữ liệu tuyệt đối (ACID) và khả năng mở rộng toàn cầu1....



thiết kế chi tiết bảng tenant\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng

Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật từ các nguồn dữ liệu (đặc biệt là việc tách biệt danh tính toàn cầu và hồ sơ thành viên), dưới đây là thiết kế chi tiết bảng **tenant\_members** cho YugabyteDB (YSQL).

Bảng này đóng vai trò là "nút thắt" liên kết một con người (`users`) vào một tổ chức (`tenants`), cho phép một người có thể tham gia nhiều công ty với các chức danh và quyền hạn khác nhau1....

1\. Thiết kế chi tiết bảng `tenant_members` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tối ưu sắp xếp và chèn dữ liệu45. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id)` | Xác định thành viên thuộc tổ chức nào. Là Sharding Key quan trọng67. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id)` | Liên kết với danh tính người dùng toàn cục89. |
| **display\_name** | VARCHAR(255) | YES |     |     | Tên hiển thị riêng trong tổ chức (VD: "Anh An IT")1011. |
| **status** | VARCHAR(20) | NO  | `'INVITED'` | `CHECK (status IN ('INVITED', 'ACTIVE', 'SUSPENDED', 'RESIGNED'))` | Trạng thái hoạt động của thành viên trong tổ chức này1011. |
| **custom\_data** | JSONB | NO  | `'{}'` |     | Lưu trữ linh hoạt các trường động (Mã NV, chức danh, size áo...)1112. |
| **joined\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm chính thức gia nhập tổ chức1011. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi hồ sơ613. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật hồ sơ gần nhất1314. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | **Soft Delete**. Thời điểm xóa thành viên khỏi tổ chức1415. |
| **created\_by** | UUID | YES |     |     | ID người thực hiện tạo hồ sơ (Admin/System)1314. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Chống ghi đè dữ liệu khi nhiều Admin cùng sửa1516. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng `tenant_members`

```
CREATE TABLE tenant_members (
    -- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINK)
    _id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ Application
    tenant_id UUID NOT NULL,
    user_id UUID NOT NULL,
    
    -- II. THÔNG TIN VẬN HÀNH (OPERATIONAL)
    display_name VARCHAR(255),
    status VARCHAR(20) NOT NULL DEFAULT 'INVITED',
    custom_data JSONB NOT NULL DEFAULT '{}',
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    created_by UUID,
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_mem_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    -- Đảm bảo một User chỉ có duy nhất 1 hồ sơ tại 1 Tenant (không trùng lặp)
    CONSTRAINT uq_tenant_user UNIQUE (tenant_id, user_id),
    CONSTRAINT chk_mem_status CHECK (status IN ('INVITED', 'ACTIVE', 'SUSPENDED', 'RESIGNED')),
    CONSTRAINT chk_mem_updated CHECK (updated_at >= created_at)
);

-- Index quan trọng để truy vấn danh sách thành viên của một Tenant nhanh hơn
CREATE INDEX idx_mem_tenant ON tenant_members (tenant_id) WHERE deleted_at IS NULL;

-- GIN Index để tìm kiếm trong custom_data (Ví dụ: tìm theo mã nhân viên lưu trong JSON)
CREATE INDEX idx_mem_custom_data ON tenant_members USING GIN (custom_data);
```

Các phân tích trọng tâm áp dụng vào thiết kế:

• **Mô hình "Switch Workspace":** Bằng cách tách `users` (danh tính) và `tenant_members` (hồ sơ), hệ thống cho phép một người dùng đăng nhập một lần nhưng có thể làm việc tại nhiều công ty khác nhau mà không bị lẫn lộn dữ liệu317.

• **SaaS Core tinh gọn:** Thiết kế này loại bỏ các trường nghiệp vụ nặng (lương, hợp đồng) để giữ cho Core ổn định. Các ứng dụng như HRM có thể mở rộng dữ liệu thông qua trường `custom_data` hoặc tạo bảng riêng liên kết 1-1 với `tenant_members` \[\_id\]10....

• **Hiệu năng phân tán:** Sử dụng UUID v7 và đánh Index vào `tenant_id` giúp YugabyteDB phân tán dữ liệu đồng đều và truy vấn nhanh chóng khi hệ thống mở rộng lên hàng triệu người dùng5....

• **Tính toàn vẹn:** Ràng buộc `UNIQUE(tenant_id, user_id)` ngăn chặn việc một người bị thêm hai lần vào cùng một tổ chức, gây sai lệch báo cáo722.

**Sự ví von:** Nếu `users` là một **Hộ chiếu** quốc tế, thì `tenant_members` chính là **Thẻ nhân viên** của từng công ty. Bạn có thể có nhiều thẻ nhân viên khác nhau, nhưng tất cả đều phải quy chiếu về một số hộ chiếu duy nhất của bạn822.



thiết kế chi tiết bảng departments dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng

Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và phân tích về cấu trúc tổ chức (Organizational Units) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **departments** (Phòng ban) sử dụng YugabyteDB (YSQL).

Bảng này đóng vai trò quản lý cấu trúc cây (Hierarchy) của doanh nghiệp, cho phép truy vấn nhanh các cấp bậc tổ chức thông qua phương pháp **Materialized Path**1,2,3.

Thiết kế chi tiết bảng `departments` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7). Tối ưu hóa việc sắp xếp theo thời gian và tránh Hotspot4,5. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id)` | Xác định phòng ban thuộc tổ chức nào (Sharding Key quan trọng)6,7. |
| **parent\_id** | UUID | YES | `NULL` | `REFERENCES departments(_id)` | ID của phòng ban cha. Dùng để xây dựng quan hệ phân cấp1,2. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên phòng ban (VD: Khối Công nghệ, Phòng Nhân sự)2. |
| **code** | VARCHAR(50) | YES | `NULL` |     | Mã phòng ban dùng để đồng bộ với hệ thống ERP bên ngoài2. |
| **type** | VARCHAR(20) | NO  | `'TEAM'` | `CHECK (type IN ('DIVISION', 'DEPARTMENT', 'TEAM'))` | Phân loại cấp độ tổ chức2,3. |
| **head\_member\_id** | UUID | YES | `NULL` | `REFERENCES tenant_members(_id)` | Trưởng phòng (Administrative Head). Link tới hồ sơ thành viên2,3. |
| **path** | TEXT | YES |     |     | **Materialized Path** (VD: `/root/dept_a/team_b/`). Giúp truy vấn toàn bộ cây con cực nhanh2,8. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)9,8. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng9,8. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | **Soft Delete**. Nếu khác NULL, phòng ban coi như đã bị giải thể9,10. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking**. Ngăn chặn việc cập nhật dữ liệu đồng thời bị xung đột11,12. |

\--------------------------------------------------------------------------------

Câu lệnh YSQL tạo bảng `departments`

Câu lệnh này bao gồm cả các chỉ mục (Indexes) chiến lược để tối ưu hóa việc truy vấn cây thư mục phòng ban trong môi trường đa tenant8,3.

```
CREATE TABLE departments (
    -- I. ĐỊNH DANH & PHÂN CẤP (IDENTITY & HIERARCHY)
    _id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ Application
    tenant_id UUID NOT NULL,
    parent_id UUID,
    
    -- II. THÔNG TIN NGHIỆP VỤ (BUSINESS DATA)
    name TEXT NOT NULL,
    code VARCHAR(50),
    type VARCHAR(20) NOT NULL DEFAULT 'TEAM',
    head_member_id UUID,
    path TEXT, -- Cấu trúc: /parent_id/child_id/
    
    -- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_dept_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_dept_parent FOREIGN KEY (parent_id) REFERENCES departments(_id),
    CONSTRAINT chk_dept_status CHECK (type IN ('DIVISION', 'DEPARTMENT', 'TEAM')),
    CONSTRAINT chk_dept_updated CHECK (updated_at >= created_at)
);

-- Index để tìm tất cả phòng ban con cực nhanh bằng toán tử LIKE hoặc mẫu text [8], [3]
CREATE INDEX idx_dept_path ON departments (tenant_id, path text_pattern_ops) WHERE deleted_at IS NULL;

-- Index hỗ trợ tìm kiếm phòng ban theo Tenant (SaaS isolation) [6], [13]
CREATE INDEX idx_dept_tenant ON departments (tenant_id) WHERE deleted_at IS NULL;
```

Điểm nhấn kỹ thuật theo nguồn dữ liệu:

• **UUID v7 làm Khóa chính:** Đảm bảo tính duy nhất toàn cầu nhưng vẫn giữ được thứ tự thời gian chèn, giúp tránh hiện tượng "Hotspot" trong hệ thống phân tán YugabyteDB4,5,12.

• **Materialized Path (****path****):** Thay vì sử dụng đệ quy (Recursive CTE) tốn kém, cột `path` cho phép lấy toàn bộ danh sách phòng ban con của "Khối Công nghệ" chỉ bằng một lệnh: `WHERE path LIKE '/khoi-cn-uuid/%'`2,8.

• **Phân tách Core và App:** Bảng này chỉ lưu cấu trúc tổ chức lõi. Các thông tin đặc thù khác (như ngân sách phòng ban) nên được lưu ở các module nghiệp vụ liên kết thông qua `_id` của bảng này13,14.

\--------------------------------------------------------------------------------

**Sự ví von để dễ hiểu:** Bảng `departments` giống như một **sơ đồ mặt bằng** của một tòa nhà cao tầng. `_id` là mã số của mỗi phòng, `parent_id` cho biết phòng đó nằm trong khu vực lớn nào, và `path` giống như **số nhà đầy đủ** (VD: Tòa A/Tầng 10/Phòng 1001) giúp bất kỳ ai cũng có thể tìm thấy mọi phòng nhỏ bên trong một khu vực lớn chỉ bằng một cái nhìn lướt qua sơ đồ2,8.



bảng users và tenants có cần index gì không?

Trong hệ thống SaaS đa tenant trên YugabyteDB (YSQL), việc thiết kế các chỉ mục (index) cho bảng `users` và `tenants` là **cực kỳ quan trọng** để tối ưu hóa hiệu suất truy vấn, đặc biệt là khi dữ liệu được phân tán trên nhiều node12.

Dưới đây là các chỉ mục chiến lược cần thiết cho hai bảng này dựa trên các kịch bản truy cập phổ biến:

1\. Chỉ mục cho bảng `tenants` (Tổ chức)

Các chỉ mục này tập trung vào việc định tuyến (routing) và quản lý trạng thái khách hàng:

• **idx\_tenants\_code** **(Unique Index):** Đánh trên cột `code` (slug/subdomain) kèm điều kiện `WHERE deleted_at IS NULL`34. Đây là chỉ mục quan trọng nhất để API Gateway hoặc Router tìm kiếm Tenant ID ngay khi người dùng truy cập qua URL (ví dụ: `fpt.saas.com`)56.

• **idx\_tenants\_active\_apps** **(GIN Index):** Đánh trên cột mảng `active_apps`47. Chỉ mục này giúp hệ thống nhanh chóng tìm ra tất cả các khách hàng đang sử dụng một ứng dụng cụ thể (ví dụ: HRM) khi cần cập nhật tính năng hoặc triển khai phiên bản mới56.

• **idx\_tenants\_owner****:** Đánh trên cột `owner_id` để hiển thị danh sách các công ty mà một User đang sở hữu trên trang Dashboard quản trị3....

• **idx\_tenants\_status\_tier****:** Chỉ mục ghép trên `status` và `tier` (hoặc `current_tier_code`) giúp đội ngũ Sales hoặc Admin lọc nhanh danh sách khách hàng theo phân cấp (VIP, Pro) hoặc trạng thái hoạt động5....

• **idx\_tenants\_region****:** Đánh trên `data_region` để phục vụ công tác thống kê hạ tầng và phân bổ dữ liệu theo khu vực địa lý46.

2\. Chỉ mục cho bảng `users` (Người dùng)

Các chỉ mục này ưu tiên cho việc xác thực và tìm kiếm danh tính:

• **idx\_users\_email\_active** **(Unique Index):** Đánh trên cột `email` kèm điều kiện `WHERE deleted_at IS NULL`10. Đây là chỉ mục "sống còn" để thực hiện đăng nhập bằng email và đảm bảo không có hai người dùng hoạt động nào trùng email trên toàn hệ thống10.

• **idx\_users\_search\_trgm** **(GIN Trigram Index):** Sử dụng trên một cột vector tìm kiếm (bao gồm tên, email, số điện thoại) để hỗ trợ tìm kiếm người dùng theo kiểu "gõ sai vẫn ra" hoặc tìm kiếm mờ (fuzzy search) cực nhanh1112.

• **idx\_identity\_lookup****:** Trong mô hình đa phương thức đăng nhập, chỉ mục này được đánh trên bảng liên kết (`user_linked_identities`) cho cặp `(provider, provider_id)` để tìm nhanh User ID khi họ đăng nhập qua Google, GitHub hoặc SSO1314.

• **idx\_sessions\_user****:** Đánh trên bảng `user_sessions` (`user_id`) để người dùng có thể quản lý và thu hồi (logout) các thiết bị đang đăng nhập một cách nhanh chóng15.

Lưu ý quan trọng về Hiệu năng

• **Sử dụng UUID v7 làm Khóa chính:** Việc dùng UUID v7 cho `_id` giúp các bản ghi mới được chèn vào theo thứ tự thời gian, tránh tình trạng "Hotspot" (nghẽn cổ chai) trong database phân tán và tối ưu hóa hiệu suất index mặc định của Primary Key17.

• **Tránh Index các cột URL/Text quá dài:** Các nguồn tài liệu khuyên **không nên** đánh index trực tiếp trên các cột chứa URL ảnh hoặc mô tả dài vì sẽ làm chậm thao tác chèn (insert); thay vào đó hãy index trên một cột hash (MD5/SHA256) nếu thực sự cần tìm kiếm16.

**Ví von để dễ hiểu:** Các chỉ mục này giống như **bản chỉ dẫn ở sảnh tòa nhà**. Thay vì nhân viên bảo vệ phải đi gõ cửa từng phòng (`Full Table Scan`) để tìm một công ty hay một người, họ chỉ cần nhìn vào bảng chỉ dẫn (`Index`) để biết ngay vị trí chính xác, giúp khách hàng ra vào tòa nhà nhanh chóng và không gây ùn tắc ở cửa ra vào.



viết lệnh ysql để tạo index cho tenants và users

Dựa trên các tiêu chuẩn thiết kế hệ thống SaaS đa tenant và các đặc thù của YugabyteDB (YSQL), việc tạo Index không chỉ giúp tăng tốc truy vấn mà còn hỗ trợ định tuyến (routing) và bảo mật dữ liệu12.

Dưới đây là các câu lệnh YSQL để tạo Index chiến lược cho hai bảng **tenants** và **users**:

1\. Chỉ mục cho bảng `tenants` (Tổ chức)

Các chỉ mục này tập trung vào việc định danh khách hàng trên URL và quản lý trạng thái gói cước34.

• **Index định tuyến Subdomain:** Đảm bảo tìm kiếm Tenant cực nhanh khi người dùng truy cập qua URL (ví dụ: `fpt.saas.com`) và hỗ trợ xóa mềm (Soft Delete)12.

• **GIN Index cho mảng ứng dụng:** Hỗ trợ truy vấn nhanh danh sách khách hàng đang sử dụng một ứng dụng cụ thể (ví dụ: HRM, CRM)25.

• **Index cho chủ sở hữu (Owner):** Giúp hiển thị danh sách các công ty mà một người dùng đang quản lý trên Dashboard16.

• **Index quản trị:** Hỗ trợ Admin hệ thống lọc khách hàng theo trạng thái hoạt động và cấp độ gói cước56.

• **Index vùng dữ liệu:** Thống kê hạ tầng và số lượng khách hàng theo khu vực địa lý27.

2\. Chỉ mục cho bảng `users` (Người dùng)

Các chỉ mục này ưu tiên tối ưu hóa luồng đăng nhập và tìm kiếm danh tính89.

• **Index đăng nhập an toàn:** Đảm bảo Email là duy nhất đối với các tài khoản đang hoạt động và tăng tốc độ xác thực810.

• **GIN Trigram Index cho tìm kiếm mờ:** Hỗ trợ tìm kiếm người dùng theo tên hoặc email ngay cả khi gõ thiếu hoặc sai chính tả nhẹ911. _(Lưu ý: Cần kích hoạt extension_ _pg\_trgm_ _trước khi sử dụng)_

3\. Chỉ mục bổ trợ liên quan (Xác thực & Định danh)

Để hệ thống IAM (Identity and Access Management) hoạt động mượt mà, các bảng liên kết cũng cần được đánh Index1213.

• **Tra cứu định danh liên kết (Social Login):** Tìm nhanh User ID khi đăng nhập qua Google, GitHub hoặc SSO1214.

• **Tra cứu quan hệ (ReBAC):** Dành cho mô hình phân quyền dựa trên quan hệ như Google Zanzibar1315.

**Lời khuyên từ các nguồn dữ liệu:** Việc sử dụng **UUID v7** cho các trường `_id` giúp các chỉ mục này được sắp xếp theo thời gian, tránh tình trạng nghẽn cổ chai (Hotspot) trong database phân tán như YugabyteDB1617.

**Ví von để dễ hiểu:** Các chỉ mục này giống như **mục lục của một cuốn sách khổng lồ**. Thay vì phải lật từng trang (Full Table Scan) để tìm một thông tin, bạn chỉ cần xem mục lục để biết chính xác trang cần đọc, giúp hệ thống phản hồi nhanh chóng ngay cả khi dữ liệu phình to lên hàng triệu bản ghi.



viết câu lệnh ysql mà?

Dưới đây là các câu lệnh **YSQL** (YugabyteDB) để khởi tạo bảng `users` hoàn chỉnh, bao gồm các ràng buộc (constraints) và các chỉ mục (indexes) chiến lược giúp tối ưu hóa hiệu năng cho hệ thống SaaS quy mô lớn.

1\. Câu lệnh YSQL tạo bảng `users`

Câu lệnh này tích hợp đầy đủ các cột từ bản thiết kế trước đó, tuân thủ các quy tắc về kiểu dữ liệu (như `TEXT` cho password hash và `TIMESTAMPTZ` cho thời gian)1,2.

```
CREATE TABLE users (
    -- I. ĐỊNH DANH (IDENTITY)
    _id UUID PRIMARY KEY, -- Sử dụng UUID v7 (tạo từ ứng dụng) để tối ưu sharding và sắp xếp [3], [4]
    email VARCHAR(255) NOT NULL, -- Email đăng nhập chính
    password_hash TEXT, -- Chuỗi băm Argon2id/Bcrypt, để NULL nếu dùng SSO [5], [6]
    full_name TEXT NOT NULL, -- Tên hiển thị mặc định
    avatar_url TEXT, -- Hỗ trợ URL dài (Presigned URL) [7]
    phone_number VARCHAR(20), -- Số điện thoại để xác thực/MFA [2]

    -- II. TRẠNG THÁI & BẢO MẬT (SECURITY & STATUS)
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, BANNED, PENDING [2]
    is_support_staff BOOLEAN NOT NULL DEFAULT FALSE, -- Phục vụ tính năng Impersonation [8]
    is_verified BOOLEAN NOT NULL DEFAULT FALSE, -- Xác thực email [2]
    mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE, -- Trạng thái bật MFA
    mfa_secret TEXT, -- Secret key cho TOTP (nên mã hóa) [2]
    
    -- III. CẤU HÌNH & DỮ LIỆU ĐỘNG (PREFERENCES)
    locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN', -- Ngôn ngữ/định dạng [2]
    metadata JSONB NOT NULL DEFAULT '{}', -- Lưu thông tin tùy chỉnh linh hoạt [9]
    
    -- IV. TRUY VẾT (AUDIT)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ, -- Phục vụ xóa mềm (Soft Delete) [10]
    version BIGINT NOT NULL DEFAULT 1, -- Chống ghi đè đồng thời (Optimistic Locking) [11]

    -- V. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_users_phone UNIQUE (phone_number),
    CONSTRAINT chk_users_email_fmt CHECK (email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
    CONSTRAINT chk_users_status CHECK (status IN ('ACTIVE', 'BANNED', 'DISABLED', 'PENDING')),
    CONSTRAINT chk_users_updated CHECK (updated_at >= created_at)
);
```

2\. Các chỉ mục (Indexes) quan trọng

Theo các nguồn dữ liệu, việc đánh chỉ mục đúng cách là "vũ khí" để hệ thống phản hồi dưới 1ms3,4.

• **Chỉ mục duy nhất cho Email (Hỗ trợ Soft Delete):** Đảm bảo email là duy nhất trên toàn hệ thống nhưng không bị xung đột với các tài khoản đã bị xóa5.

• **Chỉ mục tìm kiếm mờ (Fuzzy Search):** Cho phép tìm kiếm người dùng theo tên hoặc email nhanh chóng ngay cả khi gõ thiếu dấu hoặc sai chính tả6,7.

• **Chỉ mục hỗ trợ quản trị:** Giúp Admin lọc danh sách người dùng theo trạng thái nhanh hơn.

Giải thích các lựa chọn kỹ thuật:

• **UUID v7:** Được ưu tiên làm khóa chính vì tính chất sắp xếp theo thời gian (time-sortable), giúp các node trong cụm YugabyteDB không bị hiện tượng "hotspot" khi chèn dữ liệu mới8,9.

• **Kiểu dữ liệu TEXT:** Sử dụng cho `password_hash` và `avatar_url` thay vì `VARCHAR(255)` để tránh giới hạn ký tự khi thay đổi thuật toán băm (như Argon2id thường dài hơn Bcrypt) hoặc khi dùng các URL có chữ ký bảo mật dài10,11.

• **JSONB:** Trường `metadata` cho phép lưu trữ các thuộc tính linh hoạt như "Size áo", "Biển số xe" mà không cần phải thay đổi cấu trúc bảng (ALTER TABLE)12,13.

• **Soft Delete (****deleted\_at****):** Giúp tuân thủ các quy định về lưu vết và phục hồi dữ liệu khi người dùng lỡ tay xóa tài khoản5.



viết các lệnh CREATE INDEX ấy

Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và các Access Pattern (mô hình truy cập) đã phân tích trong các nguồn dữ liệu, dưới đây là tổng hợp các lệnh **CREATE INDEX** chiến lược trong YugabyteDB (YSQL).

Các chỉ mục này được thiết kế để tối ưu hóa hiệu suất truy vấn phân tán, hỗ trợ **Soft Delete** và đảm bảo tốc độ phản hồi tính bằng mili giây cho hàng triệu người dùng1....

1\. Chỉ mục cho bảng `tenants` (Tổ chức)

Nhóm này tập trung vào việc định tuyến (Routing) khách hàng từ URL và quản trị hệ thống.

• **Index định tuyến Subdomain (Quan trọng nhất):** Đảm bảo tìm nhanh Tenant ID từ slug trên URL. Sử dụng **Partial Index** để chỉ quét các Tenant chưa bị xóa34.

• **GIN Index cho mảng ứng dụng:** Hỗ trợ truy vấn: "Tìm tất cả tenant đang sử dụng app HRM" để phục vụ việc deploy hoặc bật tính năng mới3....

• **Index cho chủ sở hữu (Owner):** Hiển thị danh sách các công ty mà một User đang sở hữu trên Dashboard quản trị4....

• **Index quản trị & thống kê:** Hỗ trợ lọc khách hàng theo vùng dữ liệu, trạng thái và cấp độ gói cước2....

2\. Chỉ mục cho bảng `users` (Người dùng)

Nhóm này ưu tiên cho việc xác thực (Authentication) và tìm kiếm danh tính.

• **Index đăng nhập duy nhất:** Đảm bảo email không trùng lặp và truy vấn đăng nhập cực nhanh910.

• **GIN Trigram Index cho tìm kiếm mờ:** Hỗ trợ tìm kiếm người dùng theo tên hoặc email ngay cả khi gõ thiếu hoặc sai chính tả nhẹ1112.

3\. Chỉ mục cho bảng `tenant_app_routes` (Định tuyến Domain/Path)

Đây là bảng có tần suất đọc cực cao mỗi khi có request bay vào hệ thống1314.

• **Covering Index "thần thánh":** Chứa cả `tenant_id` và `app_code` ngay trong Index để database trả về kết quả mà không cần đọc bảng gốc (**Index Only Scan**)1516.

4\. Chỉ mục cho các bảng Core khác

• **Phân cấp phòng ban (****departments****):** Sử dụng B-Tree Index trên cột `path` để lấy toàn bộ cây con cực nhanh1718.

• **Phân quyền dựa trên quan hệ (****relationship\_tuples****):** Index đảo ngược để trả lời câu hỏi: "User A được quyền xem những tài liệu nào?"19.

• **Dữ liệu tùy chỉnh (****tenant\_members****):** GIN Index trên cột JSONB `custom_data` để tìm kiếm theo các trường động như mã nhân viên, size áo20.

• **Đảm bảo nhất quán (****outbox\_events****):** Giúp Worker quét nhanh các sự kiện chưa được bắn sang Kafka21.

Lưu ý kỹ thuật quan trọng:

1\. **UUID v7:** Việc sử dụng UUID v7 cho các cột ID làm khóa chính giúp các chỉ mục này được **sắp xếp theo thời gian (Time-sortable)**, tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi chèn dữ liệu đồng thời trong hệ thống phân tán YugabyteDB22....

2\. **Geo-Partitioning:** Nếu hệ thống của bạn yêu cầu dữ liệu khách hàng phải nằm tại vùng địa lý cụ thể (VD: VN, EU), các Index nên bao gồm cột `data_region` trong thành phần khóa để định tuyến query chính xác tới Node vật lý tại vùng đó25....



viết các lệnh CREATE INDEX để tạo index cho bảng tenants

Dựa trên các phân tích chuyên sâu về hệ thống SaaS đa tenant trong các nguồn dữ liệu, việc tạo index cho bảng **tenants** trên YugabyteDB (YSQL) không chỉ nhằm tăng tốc truy vấn mà còn để tối ưu hóa khả năng định tuyến (routing), quản trị hạ tầng và phân tán dữ liệu1,2,3.

Dưới đây là các câu lệnh **CREATE INDEX** chiến lược cho bảng `tenants`:

1\. Chỉ mục định tuyến Subdomain (Quan trọng nhất)

Đây là chỉ mục giúp hệ thống xác định nhanh chóng định danh của khách hàng thông qua mã slug hoặc subdomain khi người dùng truy cập vào ứng dụng1,4.

```
CREATE UNIQUE INDEX idx_tenants_code 
ON tenants (code) 
WHERE deleted_at IS NULL;
```

• **Mục đích:** Hỗ trợ đăng nhập và định tuyến URL (ví dụ: `fpt.saas.com`)5,6. Việc sử dụng **Partial Index** (`WHERE deleted_at IS NULL`) giúp loại bỏ các bản ghi đã xóa khỏi chỉ mục, làm giảm dung lượng và tăng hiệu năng truy vấn4.

2\. Chỉ mục quản trị chủ sở hữu (Owner Dashboard)

Dùng để hiển thị danh sách các tổ chức/công ty mà một người dùng cụ thể đang quản lý5,7.

```
CREATE INDEX idx_tenants_owner 
ON tenants (owner_id) 
WHERE deleted_at IS NULL;
```

• **Mục đích:** Phục vụ trang Dashboard cá nhân của người dùng để họ có thể chuyển đổi nhanh giữa các workspace (công ty)1,5.

3\. Chỉ mục GIN cho mảng ứng dụng (active\_apps)

Khi sử dụng kiểu dữ liệu mảng để lưu danh sách ứng dụng mà tenant được quyền sử dụng, chỉ mục GIN là bắt buộc để tìm kiếm hiệu quả2,4.

```
CREATE INDEX idx_tenants_active_apps 
ON tenants USING GIN (active_apps);
```

• **Mục đích:** Hỗ trợ các tác vụ quản trị như tìm tất cả các tenant đang sử dụng một ứng dụng cụ thể (ví dụ: 'HRM') để nâng cấp tính năng hoặc triển khai phiên bản mới5,6.

4\. Chỉ mục phân cấp gói cước và trạng thái

Hỗ trợ đội ngũ vận hành và marketing trong việc lọc danh sách khách hàng theo tình trạng kinh doanh2,5.

```
CREATE INDEX idx_tenants_status_tier 
ON tenants (status, current_tier_code);
```

• **Mục đích:** Giúp Admin hệ thống lọc nhanh các khách hàng VIP hoặc các khách hàng đang ở trạng thái dùng thử (TRIAL)5,7.

5\. Chỉ mục theo vùng dữ liệu (Data Residency)

Đối với hệ thống SaaS toàn cầu, việc theo dõi khách hàng theo khu vực địa lý là yếu tố then chốt để tuân thủ pháp lý và quản trị hạ tầng6,4.

```
CREATE INDEX idx_tenants_region 
ON tenants (data_region);
```

• **Mục đích:** Giúp hệ thống thống kê số lượng khách hàng theo từng vùng (ví dụ: `ap-southeast-1`, `us-east-1`) và hỗ trợ chiến lược phân mảnh dữ liệu theo địa lý (Geo-Partitioning)6,8.

6\. Chỉ mục cho dữ liệu tùy chỉnh (Profile Metadata)

Nếu bạn gom các thông tin mô tả, logo, website vào cột JSONB để tăng tính linh hoạt, bạn có thể tạo chỉ mục GIN trên cột này9.

```
CREATE INDEX idx_tenants_profile 
ON tenants USING GIN (profile);
```

• **Mục đích:** Cho phép tìm kiếm nhanh các thông tin nằm sâu bên trong cấu hình JSON như mã số thuế hoặc các thuộc tính tùy biến khác9.

\--------------------------------------------------------------------------------

**Lưu ý kỹ thuật:**

• **Thứ tự ưu tiên:** Index trên cột `code` là quan trọng nhất vì nó được gọi mỗi khi có request bay vào hệ thống để xác định tenant10.

• **Hiệu năng Sharding:** Theo các nguồn dữ liệu, việc sử dụng **UUID v7** cho khóa chính `_id` giúp dữ liệu được phân tán đều trên các node và tối ưu hóa thứ tự sắp xếp theo thời gian cho các chỉ mục11,12.

• **Bảo mật:** Với các hệ thống yêu cầu bảo mật cao, các chỉ mục cần kết hợp với các chính sách che giấu dữ liệu (Data Masking) để bảo vệ thông tin nhạy cảm của khách hàng13.

Để dễ hình dung, hãy coi các chỉ mục này như **hệ thống phân loại trong một thư viện khổng lồ**. Thay vì thủ thư phải đi kiểm tra từng cuốn sách trên kệ (**Full Table Scan**), các bản chỉ dẫn này cho biết chính xác cuốn sách (dữ liệu tenant) nằm ở khu vực nào, giúp việc tìm kiếm diễn ra gần như tức thì ngay cả khi thư viện có hàng triệu cuốn sách.



viết các lệnh CREATE INDEX để tạo index cho bảng users

Dựa trên các phân tích về hệ thống SaaS "World-class" và các yêu cầu về hiệu năng trong YugabyteDB (YSQL), việc tạo Index cho bảng `users` cần tập trung vào tối ưu hóa xác thực, tìm kiếm danh tính và quản trị12.

Dưới đây là các câu lệnh **CREATE INDEX** chiến lược cho bảng `users`:

1\. Index duy nhất cho Email (Hỗ trợ Soft Delete)

Đây là chỉ mục quan trọng nhất để phục vụ quá trình đăng nhập. Sử dụng **Partial Index** để đảm bảo email là duy nhất trên toàn hệ thống nhưng không bị xung đột với các tài khoản đã bị xóa mềm23.

```
CREATE UNIQUE INDEX idx_users_email_active 
ON users (email) 
WHERE deleted_at IS NULL;
```

2\. Index tìm kiếm mờ (Fuzzy Search)

Để hỗ trợ quản trị viên tìm kiếm người dùng theo tên hoặc email nhanh chóng ngay cả khi gõ thiếu hoặc sai chính tả nhẹ, chúng ta sử dụng **GIN Trigram Index**45.

```
-- Cần kích hoạt extension trước khi tạo index
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE INDEX idx_users_search_trgm 
ON users USING GIN (full_name gin_trgm_ops, email gin_trgm_ops);
```

3\. Index duy nhất cho Số điện thoại

Tương tự như email, số điện thoại cần được index để phục vụ xác thực đa yếu tố (MFA) hoặc đăng nhập bằng điện thoại67.

```
CREATE UNIQUE INDEX idx_users_phone_active 
ON users (phone_number) 
WHERE phone_number IS NOT NULL AND deleted_at IS NULL;
```

4\. Index quản trị và trạng thái

Hỗ trợ các truy vấn lọc danh sách người dùng theo trạng thái (Active, Banned, Pending) và sắp xếp theo thời gian tạo (sử dụng lợi thế của UUID v7)68.

```
CREATE INDEX idx_users_status_created 
ON users (status, created_at DESC);
```

5\. Index liên kết danh tính (Social Login)

Mặc dù index này nằm trên bảng liên kết `user_linked_identities`, nhưng nó là "chìa khóa" để tìm nhanh `user_id` khi người dùng đăng nhập qua Google, GitHub hoặc SSO910.

```
CREATE INDEX idx_identity_lookup 
ON user_linked_identities (provider, provider_id);
```

6\. Index quản lý phiên làm việc (Security Audit)

Sử dụng trên bảng `user_sessions` để giúp người dùng hoặc quản trị viên truy vấn nhanh các phiên làm việc đang hoạt động và thu hồi thiết bị khi cần thiết1112.

```
CREATE INDEX idx_sessions_user_active 
ON user_sessions (user_id) 
WHERE is_revoked = FALSE;
```

Tại sao các chỉ mục này tối ưu?

• **UUID v7:** Do `_id` được tạo theo UUID v7 (sắp xếp theo thời gian), các chỉ mục trên sẽ không bị hiện tượng "Hotspot" khi chèn dữ liệu mới, giúp phân tán dữ liệu đồng đều trên các node của YugabyteDB1314.

• **Partial Index:** Giúp giảm dung lượng Index và tăng tốc độ ghi do không phải chứa dữ liệu của những người dùng đã bị xóa215.

• **GIN Index:** Cho phép tìm kiếm văn bản hiệu quả hơn nhiều so với toán tử `LIKE` thông thường trên tập dữ liệu lớn516.

**Lời khuyên:** Bạn nên thực hiện các lệnh này sau khi đã tạo bảng để đảm bảo các ràng buộc dữ liệu đã được thiết lập chính xác17.



thiết kế chi tiết bảng department\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng, các index

Dựa trên các phân tích về kiến trúc SaaS đa tenant và mô hình định danh "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **department\_members** (Thành viên phòng ban) sử dụng YugabyteDB (YSQL).

Bảng này đóng vai trò quản lý quan hệ **N-N** giữa phòng ban (`departments`) và nhân sự trong tổ chức (`tenant_members`), cho phép một người có thể tham gia nhiều phòng ban khác nhau (ví dụ: vừa thuộc phòng IT, vừa thuộc Ban Công đoàn)12.

1\. Thiết kế chi tiết bảng `department_members`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" trong hệ thống phân tán34. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id)` | Xác định bản ghi thuộc tổ chức nào (Sharding Key quan trọng)56. |
| **department\_id** | UUID | NO  |     | `REFERENCES departments(_id)` | Liên kết tới phòng ban cụ thể27. |
| **member\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id)` | Liên kết tới hồ sơ nhân sự trong Tenant12. |
| **is\_primary** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu đây có phải là phòng ban chính của nhân sự này không (dùng để tính headcount)18. |
| **role\_in\_dept** | VARCHAR(100) | YES | `NULL` |     | Vai trò cụ thể trong phòng ban này (VD: Thư ký, Điều phối viên)8. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm nhân sự được gán vào phòng ban (UTC)910. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật hồ sơ gần nhất911. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Theo các nguồn dữ liệu, việc gán Index chiến lược là "vũ khí" để hệ thống phản hồi dưới 1ms trong môi trường phân tán1213.

```
-- 1. TẠO BẢNG
CREATE TABLE department_members (
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    department_id UUID NOT NULL,
    member_id UUID NOT NULL,
    is_primary BOOLEAN NOT NULL DEFAULT FALSE,
    role_in_dept VARCHAR(100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ràng buộc tham chiếu
    CONSTRAINT fk_dept_mem_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_dept_mem_dept FOREIGN KEY (department_id) REFERENCES departments(_id) ON DELETE CASCADE,
    CONSTRAINT fk_dept_mem_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,

    -- Đảm bảo một nhân sự không bị gán trùng lặp vào cùng một phòng ban
    CONSTRAINT uq_dept_member_unique UNIQUE (tenant_id, department_id, member_id),
    CONSTRAINT chk_dept_mem_updated CHECK (updated_at >= created_at)
);

-- 2. TẠO CÁC INDEX CHIẾN LƯỢC

-- Index hỗ trợ truy vấn danh sách nhân viên của một phòng ban cụ thể
CREATE INDEX idx_dept_mem_lookup 
ON department_members (tenant_id, department_id);

-- Index hỗ trợ tìm tất cả các phòng ban mà một nhân viên đang tham gia
CREATE INDEX idx_dept_mem_member 
ON department_members (tenant_id, member_id);

-- Index lọc nhanh những nhân sự thuộc phòng ban chính (dùng cho báo cáo nhân sự)
CREATE INDEX idx_dept_mem_primary 
ON department_members (tenant_id, is_primary) 
WHERE is_primary = TRUE;
```

Các điểm lưu ý trong thiết kế:

• **UUID v7 làm Khóa chính:** Việc dùng UUID v7 đảm bảo dữ liệu được chèn theo thứ tự thời gian, giúp tối ưu hóa việc sắp xếp và tránh tình trạng nghẽn cổ chai (hotspot) khi hệ thống có hàng triệu nhân sự3....

• **SaaS Isolation:** Trường `tenant_id` luôn xuất hiện trong khóa chính hoặc các Index phức hợp (Composite Index) để đảm bảo dữ liệu của khách hàng này không bao giờ bị lẫn sang khách hàng khác5....

• **Tính nhất quán (ACID):** Việc lưu trữ trong YugabyteDB thay vì MongoDB cho phép hệ thống thực hiện các ràng buộc khóa ngoại (Foreign Keys) cứng, đảm bảo nếu một phòng ban bị xóa, các liên kết thành viên cũng tự động được dọn dẹp (Cascade Delete)1617.

**Sự ví von:** Bảng `department_members` giống như **danh sách phân vai** trong một đoàn kịch. Một diễn viên (`member_id`) có thể đóng nhiều vai trong nhiều vở kịch (`department_id`) khác nhau, nhưng tại mỗi vở kịch, họ chỉ có một danh phận cụ thể và ban tổ chức (`tenant_id`) cần biết ai là diễn viên chính (`is_primary`) cho vở diễn đó để quản lý thù lao hiệu quả.



thiết kế chi tiết bảng user\_groups dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về kiến trúc SaaS đa tenant và quy chuẩn thiết kế hệ thống "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **user\_groups** sử dụng YugabyteDB (YSQL).

Việc đặt tên là `user_groups` thay vì `groups` giúp tránh xung đột với các từ khóa dành riêng trong SQL (như `GROUP BY` hoặc `GROUPS` trong Window Functions) và làm rõ ngữ cảnh đây là nhóm của người dùng1,2.

1\. Thiết kế chi tiết bảng `user_groups`

Bảng này hỗ trợ cả cấu hình nhóm tĩnh (thêm tay), nhóm động (dựa trên quy tắc JSONB) và cấu trúc phân cấp (Hierarchy)3,4.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (khuyến nghị dùng UUID v7 để tối ưu sắp xếp theo thời gian)5,6. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định nhóm thuộc tổ chức nào (Sharding Key quan trọng)7,8. |
| **parent\_id** | UUID | YES | `NULL` | `REFERENCES user_groups(_id)` | ID của nhóm cha, dùng để xây dựng cấu trúc phân cấp lồng nhau4,9. |
| **name** | VARCHAR(100) | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên nhóm (VD: "Squad Mobile", "Phòng IT")4. |
| **code** | VARCHAR(50) | YES | `NULL` |     | Mã định danh duy nhất trong một tenant (VD: `GRP_DEV_01`)4. |
| **type** | VARCHAR(20) | NO  | `'CUSTOM'` | `CHECK (type IN ('ORG_UNIT', 'PROJECT', 'PERMISSION', 'CUSTOM'))` | Phân loại: Phòng ban, Dự án, Nhóm quyền hoặc nhóm tùy chỉnh9. |
| **dynamic\_rules** | JSONB | YES | `NULL` |     | Quy tắc để tự động thêm thành viên (VD: `{"dept": "IT", "loc": "HN"}`)10,11. |
| **path** | TEXT | YES | `NULL` |     | **Materialized Path** (VD: `/root-id/child-id/`) giúp truy vấn cây nhóm cực nhanh12,9. |
| **description** | TEXT | YES | `NULL` |     | Mô tả chi tiết về mục đích của nhóm4. |
| **owner\_member\_id** | UUID | YES | `NULL` | `REFERENCES tenant_members(_id)` | ID người quản trị/trưởng nhóm13,14. |
| **created\_at** | TIMESTAMPTZ | NO  | `NOW()` |     | Thời điểm tạo nhóm (UTC)15,16. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking** để ngăn chặn ghi đè dữ liệu đồng thời6,17. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Các chỉ mục được thiết kế để tối ưu hóa việc truy vấn trong môi trường phân tán, đảm bảo tốc độ phản hồi dưới 1ms8,18.

```
-- 1. Tạo bảng user_groups
CREATE TABLE user_groups (
    -- I. ĐỊNH DANH & PHÂN CẤP
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    parent_id UUID,
    
    -- II. THÔNG TIN NGHIỆP VỤ
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50),
    type VARCHAR(20) NOT NULL DEFAULT 'CUSTOM',
    dynamic_rules JSONB,
    path TEXT,
    description TEXT,
    owner_member_id UUID,
    
    -- III. TRUY VẾT & PHIÊN BẢN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC
    CONSTRAINT fk_groups_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_groups_parent FOREIGN KEY (parent_id) REFERENCES user_groups(_id),
    CONSTRAINT fk_groups_owner FOREIGN KEY (owner_member_id) REFERENCES tenant_members(_id),
    CONSTRAINT uq_group_tenant_code UNIQUE (tenant_id, code), -- Mã nhóm là duy nhất trong một công ty
    CONSTRAINT chk_groups_type CHECK (type IN ('ORG_UNIT', 'PROJECT', 'PERMISSION', 'CUSTOM'))
);

-- 2. Tạo các Index chiến lược

-- Index hỗ trợ phân tách dữ liệu đa tenant (Bắt buộc cho SaaS) [8]
CREATE INDEX idx_groups_tenant ON user_groups (tenant_id);

-- Index hỗ trợ truy vấn cấu trúc cây (Hierarchy) bằng Materialized Path [9]
-- Sử dụng text_pattern_ops để tối ưu cho toán tử LIKE 'path/%'
CREATE INDEX idx_groups_path ON user_groups (tenant_id, path text_pattern_ops);

-- Index hỗ trợ tìm kiếm nhanh theo loại nhóm
CREATE INDEX idx_groups_type ON user_groups (tenant_id, type);
```

Các điểm nhấn kỹ thuật áp dụng:

• **Materialized Path (****path****)**: Thay vì sử dụng các câu lệnh đệ quy phức tạp, cột `path` cho phép lấy toàn bộ các nhóm con của một nhóm cha chỉ bằng một truy vấn `LIKE` đơn giản, giúp tăng hiệu năng đáng kể12,9.

• **JSONB cho Dynamic Rules**: Cho phép hệ thống linh hoạt định nghĩa các quy tắc tự động hóa việc gán thành viên vào nhóm mà không cần thay đổi cấu trúc bảng10,19.

• **UUID v7**: Đảm bảo các nhóm được tạo mới sẽ được sắp xếp theo trình tự thời gian, giúp tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi chèn dữ liệu vào hệ thống phân tán YugabyteDB5,6.

• **Schema Isolation**: Luôn bao gồm `tenant_id` trong mọi Index để đảm bảo dữ liệu của các khách hàng luôn được tách biệt hoàn toàn7,8.



thiết kế chi tiết bảng group\_members dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về kiến trúc SaaS đa tenant "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, bảng **group\_members** đóng vai trò quản lý mối quan hệ "Nhiều - Nhiều" giữa các nhóm người dùng (`user_groups`) và các thành viên tổ chức (`tenant_members`)1....

Dưới đây là thiết kế chi tiết sử dụng **UUID v7** để tối ưu hóa hiệu năng phân tán và tránh hiện tượng "Hotspot" khi chèn dữ liệu45.

1\. Thiết kế chi tiết bảng `group_members` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn UUID v7 giúp sắp xếp theo thời gian45. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định thành viên nhóm thuộc tổ chức nào (Sharding Key)67. |
| **group\_id** | UUID | NO  |     | `REFERENCES user_groups(_id) ON DELETE CASCADE` | Liên kết với nhóm (Squad, Dự án, Phòng ban)13. |
| **member\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id) ON DELETE CASCADE` | Liên kết với hồ sơ nhân sự cụ thể trong Tenant12. |
| **role\_in\_group** | VARCHAR(20) | NO  | `'MEMBER'` | `CHECK (role_in_group IN ('LEADER', 'MEMBER', 'SECRETARY'))` | Vai trò cụ thể của thành viên trong nhóm này13. |
| **joined\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm thành viên gia nhập nhóm12. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)68. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking**: Ngăn chặn ghi đè dữ liệu khi nhiều Admin cùng thao tác9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh này tuân thủ các quy tắc đặt tên `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho hệ thống phân tán4....

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE group_members (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    group_id UUID NOT NULL,
    member_id UUID NOT NULL,
    
    -- II. THÔNG TIN NGHIỆP VỤ
    role_in_group VARCHAR(20) NOT NULL DEFAULT 'MEMBER',
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- III. TRUY VẾT & PHIÊN BẢN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_gm_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_gm_group FOREIGN KEY (group_id) REFERENCES user_groups(_id) ON DELETE CASCADE,
    CONSTRAINT fk_gm_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,
    
    -- Đảm bảo một thành viên không bị gán trùng lặp vào cùng một nhóm
    CONSTRAINT uq_group_member UNIQUE (group_id, member_id),
    
    CONSTRAINT chk_gm_role CHECK (role_in_group IN ('LEADER', 'MEMBER', 'SECRETARY')),
    CONSTRAINT chk_gm_version CHECK (version >= 1)
);

-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)

-- Index hỗ trợ truy vấn nhanh danh sách tất cả thành viên của một nhóm (Access Pattern: View Group)
CREATE INDEX idx_gm_lookup_group 
ON group_members (tenant_id, group_id);

-- Index hỗ trợ tìm tất cả các nhóm mà một nhân sự đang tham gia (Access Pattern: User Profile)
CREATE INDEX idx_gm_lookup_member 
ON group_members (tenant_id, member_id);
```

Các phân tích trọng tâm áp dụng vào thiết kế:

• **Tách biệt định danh:** Bảng này liên kết tới `tenant_members` (hồ sơ nhân sự) thay vì liên kết trực tiếp tới `users` (danh tính toàn cầu), giúp đảm bảo tính cô lập dữ liệu giữa các tổ chức khác nhau12....

• **Hiệu năng phân tán:** Việc sử dụng **UUID v7** cho khóa chính giúp các node trong YugabyteDB phân tán tải đồng đều, đồng thời giữ được tính chất sắp xếp theo thời gian, giúp việc truy vấn các thành viên mới gia nhập hiệu quả hơn57.

• **Khả năng mở rộng (Scale):** Thiết kế này hỗ trợ mô hình **ReBAC** (Phân quyền dựa trên quan hệ). Khi cần kiểm tra quyền, hệ thống chỉ cần truy vấn quan hệ giữa `member_id` và `group_id` để xác định quyền hạn thừa kế1516.

• **An toàn dữ liệu:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một nhóm bị giải thể hoặc một nhân sự rời công ty, các bản ghi liên kết trong nhóm sẽ tự động được dọn dẹp, tránh dữ liệu rác (Orphaned Data)317.

**Sự ví von:** Bảng `group_members` giống như **danh sách thành viên của các câu lạc bộ** trong một trường học. `tenants` là trường học, `user_groups` là các câu lạc bộ (Bóng đá, Âm nhạc), và `tenant_members` là học sinh. Một học sinh có thể tham gia nhiều câu lạc bộ với các vai trò khác nhau (như Đội trưởng hoặc Thành viên), và bảng này giúp ban giám hiệu quản lý chính xác ai đang ở đâu12.



thiết kế chi tiết bảng locations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa tenant và các phân tích kỹ thuật từ nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **locations** (Văn phòng & Chi nhánh) sử dụng YugabyteDB (YSQL).

Bảng này đóng vai trò quản lý các địa điểm vật lý của tổ chức, phục vụ cho việc chấm công, định vị GPS và quản lý múi giờ làm việc đặc thù của từng chi nhánh1,2.

Thiết kế chi tiết bảng `locations` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (sử dụng UUID v7 để tối ưu sắp xếp theo thời gian)3,2. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định chi nhánh thuộc tổ chức nào (Sharding Key)4,2. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên văn phòng/chi nhánh (VD: FPT Tower Hà Nội)2. |
| **code** | VARCHAR(50) | YES | `NULL` |     | Mã địa điểm dùng để đồng bộ với thiết kế HRM hoặc máy chấm công2,5. |
| **address** | JSONB | NO  | `'{}'` |     | Lưu chi tiết địa chỉ: số nhà, phường, quận, quốc gia2. |
| **coordinates** | POINT | YES | `NULL` |     | Tọa độ GPS (Lat/Long) để xác thực vị trí chấm công2. |
| **radius\_meters** | INT | YES | `NULL` | `CHECK (radius_meters > 0)` | Bán kính cho phép chấm công xung quanh tọa độ (đơn vị: mét)2. |
| **timezone** | VARCHAR(50) | NO  | `'Asia/Ho_Chi_Minh'` |     | Múi giờ tại địa phương, quan trọng để tính toán ca làm việc2. |
| **is\_headquarter** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu nếu đây là trụ sở chính của công ty2. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)6,4. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng6,7. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking** ngăn chặn xung đột khi nhiều người cùng sửa cấu hình8. |

\--------------------------------------------------------------------------------

Câu lệnh YSQL tạo bảng `locations`

Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho tính toàn vẹn dữ liệu (ACID) trong môi trường phân tán9,10.

```
CREATE TABLE locations (
    -- I. ĐỊNH DANH & PHÂN TÁCH (IDENTITY & SHARDING)
    _id UUID PRIMARY KEY, -- Khuyến nghị gen UUID v7 từ tầng Application [3]
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN ĐỊA LÝ & NGHIỆP VỤ
    name TEXT NOT NULL,
    code VARCHAR(50),
    address JSONB NOT NULL DEFAULT '{}',
    coordinates POINT, -- Kiểu dữ liệu tọa độ hỗ trợ bởi YSQL/Postgres [2]
    radius_meters INT,
    timezone VARCHAR(50) NOT NULL DEFAULT 'Asia/Ho_Chi_Minh',
    is_headquarter BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- III. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_loc_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_loc_name CHECK (LENGTH(name) > 0),
    CONSTRAINT chk_loc_radius CHECK (radius_meters > 0),
    CONSTRAINT chk_loc_updated CHECK (updated_at >= created_at)
);

-- IV. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ truy vấn nhanh tất cả chi nhánh của một Tenant (Access Pattern phổ biến) [4], [11]
CREATE INDEX idx_locations_tenant ON locations (tenant_id);

-- Index hỗ trợ tìm kiếm nhanh theo mã chi nhánh trong cùng một tổ chức
CREATE INDEX idx_locations_code ON locations (tenant_id, code);

-- Index lọc nhanh trụ sở chính khi cần hiển thị thông tin pháp lý của Tenant
CREATE INDEX idx_locations_hq ON locations (tenant_id) WHERE is_headquarter = TRUE;
```

Điểm nhấn kỹ thuật theo nguồn dữ liệu:

• **UUID v7:** Giúp các bản ghi văn phòng mới được chèn vào theo thứ tự thời gian, tránh hiện tượng "Hotspot" (nghẽn cổ chai) trên các node của YugabyteDB3,11.

• **JSONB cho địa chỉ:** Thay vì tách quá nhiều cột lẻ (phường, xã, số nhà), sử dụng JSONB cho phép lưu trữ linh hoạt địa chỉ ở các quốc gia khác nhau mà không cần thay đổi cấu trúc bảng12.

• **Timezone & Coordinates:** Hai trường này là "vũ khí" để các ứng dụng chấm công (Timekeeping) xác định xem nhân viên có đang đứng đúng vị trí chi nhánh và tính toán thời gian vào ca chính xác theo giờ địa phương2,5.

**Ví von để dễ hiểu:** Bảng `locations` giống như một **quyển danh bạ các chi nhánh** của một chuỗi cửa hàng. `_id` là mã số cửa hàng, `coordinates` và `radius_meters` giống như một **vòng tròn bảo vệ** ảo trên bản đồ; chỉ khi nhân viên bước vào vòng tròn này, hệ thống mới cho phép "điểm danh" vào làm việc2.



thiết kế chi tiết bảng user\_linked\_identities dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống xác thực đa phương thức (Multi-modal Identity) và quy chuẩn thiết kế SaaS "World-class" trong các nguồn dữ liệu, bảng **user\_linked\_identities** đóng vai trò tách biệt thông tin cá nhân (Profile) khỏi phương thức đăng nhập (Credentials)12.

Việc sử dụng bảng này cho phép một người dùng liên kết nhiều tài khoản (Password, Google, GitHub, Passkeys) vào cùng một danh tính duy nhất13.

1\. Thiết kế chi tiết bảng `user_linked_identities`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sắp xếp theo thời gian và sharding14. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến hồ sơ người dùng gốc trong bảng `users`15. |
| **provider** | VARCHAR(20) | NO  |     | `CHECK (provider IN ('LOCAL', 'GOOGLE', 'GITHUB', 'MICROSOFT', 'APPLE', 'PASSKEY'))` | Nguồn định danh (LOCAL là mật khẩu truyền thống, còn lại là OAuth/SSO)13. |
| **provider\_id** | VARCHAR(255) | NO  |     | `UNIQUE(provider, provider_id)` | ID định danh tại nguồn (Email đối với LOCAL, Subject ID đối với OAuth)6. |
| **password\_hash** | TEXT | YES | `NULL` |     | Lưu chuỗi băm mật khẩu (chỉ sử dụng khi `provider = 'LOCAL'`)78. |
| **data** | JSONB | NO  | `'{}'` |     | Lưu trữ linh hoạt metadata như: access\_token, refresh\_token, profile\_url từ nhà cung cấp69. |
| **last\_login\_at** | TIMESTAMPTZ | YES | `NULL` |     | Ghi nhận thời điểm cuối cùng đăng nhập bằng phương thức này6. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm liên kết phương thức đăng nhập này vào tài khoản610. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Dưới đây là mã nguồn YSQL để triển khai bảng và các chỉ mục chiến lược nhằm tối ưu hóa tốc độ xác thực.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_linked_identities (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application [4]
    user_id UUID NOT NULL,
    
    -- II. THÔNG TIN XÁC THỰC
    provider VARCHAR(20) NOT NULL,
    provider_id VARCHAR(255) NOT NULL,
    password_hash TEXT, -- TEXT tối ưu hơn VARCHAR cho các thuật toán băm hiện đại [7]
    
    -- III. DỮ LIỆU ĐỘNG & TRUY VẾT
    data JSONB NOT NULL DEFAULT '{}',
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_identity_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    -- Đảm bảo 1 tài khoản mạng xã hội chỉ gắn với 1 user duy nhất trên hệ thống [6]
    CONSTRAINT uq_provider_identity UNIQUE (provider, provider_id),
    -- Kiểm soát danh sách các nhà cung cấp được phép
    CONSTRAINT chk_identity_provider CHECK (provider IN ('LOCAL', 'GOOGLE', 'GITHUB', 'MICROSOFT', 'APPLE', 'PASSKEY'))
);

-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)

-- Index quan trọng nhất: Tìm nhanh User ID khi đăng nhập qua Google/Github/Email [8]
-- Query: SELECT user_id FROM user_linked_identities WHERE provider = 'GOOGLE' AND provider_id = '...';
CREATE INDEX idx_identity_lookup 
ON user_linked_identities (provider, provider_id);

-- Index hỗ trợ trang quản lý tài khoản: Hiển thị các phương thức đã liên kết của 1 user
CREATE INDEX idx_identity_user_id 
ON user_linked_identities (user_id);
```

Các lưu ý kỹ thuật từ nguồn dữ liệu:

• **Chống trộm mật khẩu**: Việc tách `password_hash` sang bảng này giúp hỗ trợ đăng nhập không mật khẩu (Passwordless). Nếu `provider` không phải 'LOCAL', trường này sẽ mang giá trị `NULL`, giúp giảm diện tích tấn công111.

• **Hiệu năng Sharding**: Nhờ khóa chính là **UUID v7**, các bản ghi mới được phân tán đều (Uniform Distribution) trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai (Hotspot) khi có lượng lớn người dùng đăng ký cùng lúc1213.

• **Xóa an toàn**: Ràng buộc `ON DELETE CASCADE` đảm bảo khi tài khoản gốc trong bảng `users` bị xóa, toàn bộ các liên kết định danh này sẽ bị xóa sạch theo, tuân thủ quyền "được quên" (GDPR)514.

**Ví von để dễ hiểu:** Bảng `user_linked_identities` giống như một **chùm chìa khóa đa năng**15. Bảng `users` là cánh cửa nhà bạn, còn mỗi dòng trong bảng này là một loại chìa (chìa cơ, vân tay, thẻ từ). Bạn có thể thêm hoặc bớt chìa mà không cần thay đổi cánh cửa, và mỗi chiếc chìa đều được ghi chép lại lịch sử sử dụng để đảm bảo an ninh tối đa.



thiết kế chi tiết bảng user\_sessions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân chuẩn thiết kế hệ thống SaaS đa tenant và các quy tắc về bảo mật định danh (IAM) trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết bảng **user\_sessions** sử dụng YugabyteDB (YSQL).

Bảng này không chỉ lưu trạng thái đăng nhập mà còn hỗ trợ các tính năng cao cấp như **xoay vòng Refresh Token (Rotation)**, **phát hiện xâm nhập** và **quản lý thiết bị tin cậy**12.

1\. Thiết kế chi tiết bảng `user_sessions`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh phiên (Session ID). Sử dụng **UUID v7** để tối ưu sharding và sắp xếp theo thời gian34. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id)` | Xác định phiên thuộc tổ chức nào (SaaS Isolation)45. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id)` | Liên kết tới người dùng sở hữu phiên4. |
| **family\_id** | UUID | NO  |     |     | Định danh chuỗi token (Family). Dùng để thu hồi toàn bộ chuỗi nếu phát hiện token bị trộm26. |
| **refresh\_token\_hash** | VARCHAR(255) | YES | `NULL` |     | Lưu chuỗi băm của Refresh Token hiện tại để thực hiện cơ chế xoay vòng2. |
| **rotation\_counter** | INT | NO  | `0` | `CHECK (rotation_counter >= 0)` | Số lần xoay vòng token. Nếu phát hiện dùng lại counter thấp, hệ thống sẽ hủy cả family26. |
| **ip\_address** | INET | YES |     |     | Địa chỉ IP của thiết bị đăng nhập4. |
| **user\_agent** | TEXT | YES |     |     | Thông tin trình duyệt và hệ điều hành (Fingerprint)4. |
| **device\_type** | VARCHAR(20) | YES |     |     | Phân loại thiết bị: `MOBILE`, `DESKTOP`, `TABLET`4. |
| **location\_city** | VARCHAR(100) | YES |     |     | Thành phố đăng nhập (GeoIP)4. |
| **is\_revoked** | BOOLEAN | NO  | `FALSE` |     | Trạng thái bị thu hồi. Nếu `TRUE`, phiên không còn hiệu lực (dùng cho tính năng "Đăng xuất từ xa")17. |
| **expires\_at** | TIMESTAMPTZ | NO  |     |     | Thời điểm phiên hết hạn hoàn toàn7. |
| **last\_active\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cuối cùng phiên có hoạt động7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm bắt đầu phiên đăng nhập7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Việc sử dụng các ràng buộc khóa ngoại (Foreign Keys) và chỉ mục một phần (Partial Index) giúp đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cực nhanh trong môi trường phân tán78.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_sessions (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
    tenant_id UUID NOT NULL,
    user_id UUID NOT NULL,
    
    -- II. CƠ CHẾ XOAY VÒNG (ROTATION) & BẢO MẬT [2]
    family_id UUID NOT NULL,
    refresh_token_hash VARCHAR(255),
    rotation_counter INT NOT NULL DEFAULT 0,
    is_revoked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- III. THÔNG TIN THIẾT BỊ & VỊ TRÍ [4]
    ip_address INET,
    user_agent TEXT,
    device_type VARCHAR(20),
    os_name VARCHAR(50),
    browser_name VARCHAR(50),
    location_city VARCHAR(100),
    location_country VARCHAR(50),
    
    -- IV. THỜI GIAN [7]
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,

    -- V. RÀNG BUỘC
    CONSTRAINT fk_sessions_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_sessions_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT chk_rotation_val CHECK (rotation_counter >= 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm nhanh danh sách thiết bị đang hoạt động của người dùng [7]
CREATE INDEX idx_sessions_user_active 
ON user_sessions (user_id) 
WHERE is_revoked = FALSE;

-- Index hỗ trợ quét các phiên đã hết hạn để dọn dẹp (Cleanup Job)
CREATE INDEX idx_sessions_expiry 
ON user_sessions (expires_at) 
WHERE is_revoked = FALSE;

-- Index hỗ trợ kiểm tra nhanh token trong cùng một family khi thực hiện rotation [6]
CREATE INDEX idx_sessions_family 
ON user_sessions (family_id);
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7**: Đảm bảo các phiên đăng nhập mới được chèn vào theo thứ tự thời gian, giúp giảm hiện tượng tranh chấp (hotspot) trên các node của YugabyteDB39.

• **Refresh Token Rotation**: Cơ chế lưu `family_id` và `rotation_counter` cho phép hệ thống phát hiện hành vi sử dụng lại token cũ. Nếu hacker trộm được Refresh Token và sử dụng, hệ thống sẽ **hủy toàn bộ chuỗi phiên** thuộc Family đó để bảo vệ người dùng6.

• **Audit & Impersonation**: Bảng này là nền tảng để hỗ trợ tính năng **Impersonation** (Nhân viên hỗ trợ đăng nhập thay khách hàng) thông qua việc lưu vết `impersonator_id` trong nhật ký hành động đi kèm với `session_id` này1011.

• **Quản lý thiết bị**: Thông qua các trường `os_name`, `browser_name`, khách hàng có thể xem danh sách các thiết bị đang truy cập tài khoản của mình và thực hiện "Đăng xuất khỏi thiết bị khác" bằng cách chuyển `is_revoked` sang `TRUE`14.

**Lời khuyên:** Để tối ưu hiệu năng, các thông tin chi tiết về phiên (như token hiện tại) nên được **cache đồng thời trên Redis** để API Gateway có thể kiểm tra quyền truy cập với độ trễ dưới 1ms mà không cần truy vấn database liên tục1213.



thiết kế chi tiết bảng user\_mfa\_methods dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống xác thực đa phương thức (MFA) và quy chuẩn thiết kế hệ thống SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_mfa\_methods** sử dụng YugabyteDB (YSQL).

Việc thiết kế bảng này cho phép người dùng đăng ký nhiều thiết bị hoặc phương thức xác thực bước hai (như Google Authenticator, SMS, Email) nhằm tăng cường bảo mật và tránh rủi ro mất quyền truy cập khi mất một thiết bị cụ thể12.

1\. Thiết kế chi tiết bảng `user_mfa_methods`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (Sử dụng UUID v7 để tối ưu sharding và sắp xếp theo thời gian)13. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến người dùng sở hữu phương thức MFA này1. |
| **type** | VARCHAR(20) | NO  |     | `CHECK (type IN ('TOTP', 'SMS', 'EMAIL', 'HARDWARE'))` | Loại xác thực: TOTP (App), SMS, Email hoặc khóa cứng2. |
| **name** | VARCHAR(50) | YES | `NULL` |     | Tên gợi nhớ cho thiết bị (VD: "iPhone 15 của An")2. |
| **encrypted\_secret** | TEXT | NO  |     |     | Chuỗi bí mật (Secret Key) đã được **mã hóa** trước khi lưu để đảm bảo an toàn2. |
| **is\_default** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu phương thức ưu tiên khi đăng nhập2. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` |     | Ghi lại thời điểm cuối cùng phương thức này được sử dụng2. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm đăng ký phương thức MFA này2. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này tuân thủ quy chuẩn **snake\_case** và sử dụng các kiểu dữ liệu tối ưu cho hệ thống phân tán YugabyteDB34.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_mfa_methods (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application để tránh Hotspot [3, 5]
    user_id UUID NOT NULL,
    
    -- II. CHI TIẾT PHƯƠNG THỨC
    type VARCHAR(20) NOT NULL,
    name VARCHAR(50),
    encrypted_secret TEXT NOT NULL, -- Sử dụng TEXT để linh hoạt cho các loại secret khác nhau [6]
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- III. TRUY VẾT (AUDIT)
    last_used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_mfa_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT chk_mfa_type CHECK (type IN ('TOTP', 'SMS', 'EMAIL', 'HARDWARE')),
    CONSTRAINT chk_mfa_timeline CHECK (last_used_at IS NULL OR last_used_at >= created_at)
);

-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)

-- Index hỗ trợ tìm nhanh các phương thức MFA của một người dùng khi đăng nhập
CREATE INDEX idx_user_mfa_lookup 
ON user_mfa_methods (user_id);

-- Index một phần (Partial Index) để xác định nhanh phương thức mặc định của người dùng
CREATE INDEX idx_user_mfa_default 
ON user_mfa_methods (user_id) 
WHERE is_default = TRUE;
```

Các lưu ý kỹ thuật quan trọng:

• **Bảo mật dữ liệu nhạy cảm:** Trường `encrypted_secret` tuyệt đối không được lưu ở dạng rõ (plain text). Theo nguồn dữ liệu, cột này nên được mã hóa bằng khóa riêng (DEK) trước khi đưa vào cơ sở dữ liệu25.

• **Hiệu năng Sharding:** Nhờ sử dụng **UUID v7**, các bản ghi MFA mới được tạo sẽ được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ được tính chất sắp xếp theo thời gian, giúp việc truy vấn "Các thiết bị mới thêm gần đây" diễn ra cực nhanh36.

• **Tính nhất quán (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi tài khoản người dùng trong bảng `users` bị xóa, toàn bộ các phương thức MFA liên quan cũng sẽ bị dọn dẹp sạch sẽ để tránh dữ liệu rác và tuân thủ các quy định về quyền được quên (GDPR)78.

**Ví von để dễ hiểu:** Bảng `user_mfa_methods` giống như một **ngăn kéo chứa các loại chìa khóa dự phòng** cho ngôi nhà của bạn (tài khoản user). Bạn có thể có chìa khóa cơ (SMS), mã vân tay (TOTP) hay thẻ từ (Hardware). Nếu bạn mất một cái, bạn vẫn còn những cái khác để vào nhà, và chủ nhà (hệ thống) sẽ ghi chép lại mỗi khi bạn sử dụng bất kỳ chiếc chìa nào.



thiết kế chi tiết bảng user\_webauthn\_credentials dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống xác thực hiện đại (Passwordless/Passkeys) và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_webauthn\_credentials** sử dụng YugabyteDB (YSQL).

Việc áp dụng chuẩn **WebAuthn (FIDO2)** giúp người dùng đăng nhập bằng vân tay, khuôn mặt (FaceID) hoặc khóa vật lý (YubiKey), mang lại khả năng chống tấn công giả mạo (Phishing) gần như tuyệt đối1,2.

1\. Thiết kế chi tiết bảng `user_webauthn_credentials`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (Sử dụng **UUID v7** để tối ưu sắp xếp theo thời gian và phân tán dữ liệu)3,1. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến tài khoản người dùng gốc1. |
| **name** | VARCHAR(100) | YES | `NULL` |     | Tên gợi nhớ cho thiết bị (VD: "MacBook TouchID", "YubiKey 5C")1. |
| **credential\_id** | TEXT | NO  |     | `UNIQUE` | ID định danh duy nhất của thiết bị WebAuthn trả về, dùng để nhận diện thiết bị khi đăng nhập1,2. |
| **public\_key** | TEXT | NO  |     |     | Khóa công khai dùng để xác thực chữ ký số từ thiết bị trong mỗi lần đăng nhập1,2. |
| **sign\_count** | INT | NO  | `0` | `CHECK (sign_count >= 0)` | Bộ đếm số lần sử dụng nhằm chống lại các cuộc tấn công phát lại (Replay Attack)1,2. |
| **transports** | TEXT\[\] | YES | `NULL` |     | Mảng lưu các phương thức kết nối được hỗ trợ (VD: `{'usb', 'nfc', 'ble', 'internal'}`)2. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm gần nhất thiết bị này được sử dụng để đăng nhập2. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm đăng ký thiết bị vào hệ thống (UTC)4,2. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Dưới đây là mã nguồn YSQL để triển khai bảng và các chỉ mục tối ưu, đảm bảo hiệu năng truy vấn dưới 1ms trong môi trường phân tán5,6.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_webauthn_credentials (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
    user_id UUID NOT NULL,
    
    -- II. DỮ LIỆU KỸ THUẬT FIDO2/PASSKEY
    name VARCHAR(100),
    credential_id TEXT NOT NULL,
    public_key TEXT NOT NULL,
    sign_count INT NOT NULL DEFAULT 0,
    transports TEXT[], -- Kiểu mảng hỗ trợ bởi YSQL/Postgres [2]
    
    -- III. TRUY VẾT THỜI GIAN
    last_used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_webauthn_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT uq_credential_id UNIQUE (credential_id), -- Credential ID phải là duy nhất toàn sàn [1]
    CONSTRAINT chk_sign_count CHECK (sign_count >= 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng: Tìm nhanh toàn bộ thiết bị Passkey của một người dùng khi bắt đầu bước Login Challenge
CREATE INDEX idx_webauthn_user_lookup 
ON user_webauthn_credentials (user_id);

-- Index hỗ trợ việc xác thực dựa trên Credential ID trả về từ trình duyệt
CREATE INDEX idx_webauthn_credential_lookup 
ON user_webauthn_credentials (credential_id);
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7 & Hiệu năng Sharding:** Sử dụng UUID v7 cho khóa chính giúp các bản ghi được phân tán đều trên các node của YugabyteDB, đồng thời giữ được tính chất sắp xếp theo thời gian giúp các truy vấn tìm thiết bị mới nhất cực kỳ hiệu quả3,7.

• **Bảo mật Replay Attack:** Cột `sign_count` là yếu tố sống còn trong WebAuthn. Theo phân tích, nếu hệ thống nhận được một yêu cầu đăng nhập với `sign_count` thấp hơn hoặc bằng giá trị đã lưu, đó có thể là dấu hiệu thiết bị đã bị clone hoặc bị tấn công phát lại8,9.

• **Khả năng mở rộng:** Kiểu dữ liệu `TEXT[]` cho `transports` cho phép hệ thống linh hoạt hỗ trợ các loại kết nối mới của thiết bị trong tương lai mà không cần thay đổi cấu trúc bảng2.

• **Toàn vẹn dữ liệu:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi người dùng bị xóa khỏi hệ thống, các thông tin định danh sinh trắc học nhạy cảm cũng sẽ bị xóa bỏ hoàn toàn, tuân thủ các quy định về quyền riêng tư như GDPR10,11.

**Ví von:** Bảng `user_webauthn_credentials` giống như một **kho lưu trữ các mẫu dấu vân tay và khuôn mặt số**. Thay vì giữ chìa khóa (mật khẩu), hệ thống lưu lại các "mẫu đối chiếu" (`public_key`). Mỗi khi bạn chạm tay vào thiết bị, thiết bị sẽ tạo ra một chữ ký mới và hệ thống chỉ việc lấy mẫu đã lưu ra để khớp lệnh mà không bao giờ cần biết mật khẩu thật của bạn là gì1,2.



thiết kế chi tiết bảng user\_backup\_codes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống bảo mật đa lớp (MFA) và quy chuẩn thiết kế SaaS "World-class" trong các nguồn dữ liệu, bảng **user\_backup\_codes** đóng vai trò là lớp phòng thủ cuối cùng (Recovery) khi người dùng mất quyền truy cập vào các thiết bị xác thực chính1,2.

Việc sử dụng **UUID v7** cho định danh giúp tối ưu hóa hiệu năng chèn dữ liệu và sắp xếp theo thời gian trong môi trường phân tán của YugabyteDB3,4.

1\. Thiết kế chi tiết bảng `user_backup_codes`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" và tối ưu hóa việc phân tán dữ liệu3,5. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết đến tài khoản người dùng gốc trong hệ thống định danh toàn cầu6,7. |
| **code\_hash** | TEXT | NO  |     |     | Chuỗi băm của mã dự phòng (tương tự mật khẩu, tuyệt đối không lưu dạng rõ)8,9. |
| **is\_used** | BOOLEAN | NO  | `FALSE` |     | Trạng thái mã đã được sử dụng hay chưa6. |
| **used\_at** | TIMESTAMPTZ | YES | `NULL` |     | Ghi lại thời điểm chính xác mã này được sử dụng để khôi phục tài khoản6. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo mã (luôn lưu theo giờ UTC)10,6. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Dưới đây là các câu lệnh SQL được thiết kế để đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cao11,12.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_backup_codes (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    user_id UUID NOT NULL,
    
    -- II. NỘI DUNG & TRẠNG THÁI
    code_hash TEXT NOT NULL, 
    is_used BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- III. TRUY VẾT THỜI GIAN
    used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    -- Xóa người dùng sẽ tự động xóa các mã dự phòng liên quan (GDPR Compliance)
    CONSTRAINT fk_backup_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    
    -- Đảm bảo logic thời gian: Ngày sử dụng phải sau ngày tạo
    CONSTRAINT chk_backup_time CHECK (used_at IS NULL OR used_at >= created_at)
);

-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)

-- Index hỗ trợ tìm nhanh danh sách các mã dự phòng của một người dùng cụ thể
CREATE INDEX idx_backup_user_lookup 
ON user_backup_codes (user_id);

-- Partial Index: Chỉ index các mã chưa sử dụng để tăng tốc độ xác thực khi login
-- Giảm dung lượng index và tăng hiệu năng do không chứa các mã đã dùng
CREATE INDEX idx_backup_unused_codes 
ON user_backup_codes (user_id) 
WHERE is_used = FALSE;
```

Các lưu ý kỹ thuật quan trọng:

• **Bảo mật băm mã (Hashing):** Theo các nguồn dữ liệu, mã dự phòng phải được xử lý như mật khẩu; hệ thống chỉ lưu bản băm (`code_hash`) để ngay cả khi dữ liệu bị rò rỉ, hacker cũng không thể sử dụng mã8.

• **UUID v7:** Việc sử dụng UUID v7 giúp các node trong YugabyteDB ghi dữ liệu tuần tự hơn, tránh việc dồn tải vào một node duy nhất (hotspot) trong cụm phân tán3,4.

• **Xoay vòng mã:** Hệ thống thường sinh ra một bộ 10 mã mỗi lần; việc sử dụng `Partial Index` trên trường `is_used` giúp việc kiểm tra tính hợp lệ của mã trong bộ này diễn ra gần như tức thì8.

**Sự ví von:** Bảng `user_backup_codes` giống như một **hộp chứa các chìa khóa vạn năng dự phòng** được cất trong két sắt. Bạn chỉ sử dụng chúng khi làm mất chìa khóa chính (thiết bị MFA), và mỗi chiếc chìa này chỉ có tác dụng **mở khóa một lần duy nhất** rồi sẽ bị hủy bỏ để đảm bảo an toàn tuyệt đối.



thiết kế chi tiết bảng tenant\_sso\_configs dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenant\_sso\_configs**.

Bảng này đóng vai trò quan trọng trong việc cho phép các khách hàng doanh nghiệp lớn (Enterprise) tích hợp hệ thống định danh sẵn có của họ (như Azure AD, Okta, Google Workspace) vào nền tảng thông qua chuẩn SAML 2.0 hoặc OIDC1,2.

1\. Thiết kế chi tiết bảng `tenant_sso_configs`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO  |     | `PRIMARY KEY`, `REFERENCES tenants(_id) ON DELETE CASCADE` | Định danh Tenant. Mỗi tổ chức thường chỉ có một cấu hình SSO chính2,3. Sử dụng UUID v7 để tối ưu hiệu năng4. |
| **provider\_type** | VARCHAR(20) | NO  |     | `CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'GOOGLE', 'SAML', 'OIDC'))` | Loại nhà cung cấp định danh (IdP)2,5. |
| **entry\_point\_url** | TEXT | NO  |     |     | URL đăng nhập của nhà cung cấp định danh bên ngoài2,5. |
| **issuer\_id** | TEXT | YES | `NULL` |     | Định danh thực thể (Entity ID/Issuer) của IdP2. |
| **cert\_public\_key** | TEXT | YES | `NULL` |     | Chứng chỉ PEM dùng để xác thực chữ ký số từ IdP (SAML)2,5. |
| **client\_id** | VARCHAR(255) | YES | `NULL` |     | Client ID dùng cho phương thức OIDC5. |
| **client\_secret\_enc** | TEXT | YES | `NULL` |     | Client Secret đã mã hóa (chỉ dùng cho OIDC)5. |
| **attribute\_mapping** | JSONB | NO  | `'{}'` |     | Ánh xạ các trường dữ liệu (VD: map 'mail' của IdP sang 'email' của hệ thống)2,5. |
| **is\_enforced** | BOOLEAN | NO  | `FALSE` |     | Nếu `TRUE`, bắt buộc nhân viên phải đăng nhập qua SSO, cấm dùng mật khẩu thông thường2,5. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo cấu hình (UTC)6,7. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng7. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để chống ghi đè dữ liệu đồng thời8. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Thiết kế này sử dụng các chuẩn mực về kiểu dữ liệu (UUID v7, JSONB, TIMESTAMPTZ) và quy tắc đặt tên `snake_case` để đảm bảo hệ thống vận hành trơn tru và dễ mở rộng9,10,4.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_sso_configs (
    -- I. ĐỊNH DANH & LIÊN KẾT
    tenant_id UUID PRIMARY KEY, -- Sử dụng luôn tenant_id làm PK vì quan hệ 1-1
    
    -- II. THÔNG TIN KỸ THUẬT IdP
    provider_type VARCHAR(20) NOT NULL,
    entry_point_url TEXT NOT NULL,
    issuer_id TEXT,
    cert_public_key TEXT,
    client_id VARCHAR(255),
    client_secret_enc TEXT,
    
    -- III. CẤU HÌNH NGHIỆP VỤ
    attribute_mapping JSONB NOT NULL DEFAULT '{}',
    is_enforced BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- IV. TRUY VẾT & PHIÊN BẢN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- V. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_sso_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_sso_provider CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'GOOGLE', 'SAML', 'OIDC')),
    CONSTRAINT chk_sso_dates CHECK (updated_at >= created_at),
    CONSTRAINT chk_sso_version CHECK (version >= 1)
);

-- 2. CÁC CHỈ MỤC CHIẾN LƯỢC (INDEXES)

-- Mặc dù tenant_id đã là PRIMARY KEY (có sẵn index), 
-- chúng ta có thể tạo thêm index trên is_enforced để hệ thống quản trị 
-- nhanh chóng lọc ra các Tenant đang áp dụng chính sách bảo mật nghiêm ngặt.
CREATE INDEX idx_sso_enforced ON tenant_sso_configs (is_enforced) WHERE is_enforced = TRUE;

-- Index hỗ trợ tìm kiếm cấu hình theo loại nhà cung cấp
CREATE INDEX idx_sso_provider ON tenant_sso_configs (provider_type);
```

Các lưu ý kỹ thuật từ nguồn dữ liệu:

• **Bảo mật:** Trường `client_secret_enc` tuyệt đối phải được mã hóa ở tầng ứng dụng trước khi lưu vào cơ sở dữ liệu để đảm bảo an toàn11.

• **Hiệu năng:** Việc sử dụng **JSONB** cho `attribute_mapping` cho phép hệ thống linh hoạt thay đổi quy tắc ánh xạ trường dữ liệu giữa các nhà cung cấp định danh khác nhau mà không cần thay đổi cấu trúc bảng12,13.

• **Tính nhất quán:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant bị xóa khỏi hệ thống, cấu hình SSO liên quan cũng sẽ bị dọn dẹp sạch sẽ14,15.

**Sự ví von:** Bảng `tenant_sso_configs` giống như một **bộ chuyển đổi phích cắm đa năng** (Adapter). Hệ thống SaaS của bạn có một kiểu phích cắm riêng, nhưng mỗi doanh nghiệp khách hàng lại dùng một kiểu phích cắm khác (Azure, Okta...). Bảng này lưu trữ thông số kỹ thuật của bộ chuyển đổi để đảm bảo "dòng điện định danh" có thể chảy thông suốt từ doanh nghiệp vào hệ thống của bạn một cách an toàn16.



thiết kế chi tiết bảng auth\_verification\_codes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống xác thực đa phương thức và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, bảng **auth\_verification\_codes** đóng vai trò quản lý các mã xác thực ngắn hạn (OTP, Magic Link) dùng cho các luồng: Đăng ký, Quên mật khẩu, và Đăng nhập không mật khẩu12.

Việc sử dụng **UUID v7** đảm bảo tính phân tán và sắp xếp theo thời gian, giúp hệ thống hoạt động mượt mà ở quy mô lớn23.

1\. Thiết kế chi tiết bảng `auth_verification_codes`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding24. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định mã thuộc tổ chức nào (SaaS Isolation)25. |
| **identifier** | VARCHAR(255) | NO  |     |     | Email hoặc số điện thoại nhận mã xác thực2. |
| **type** | VARCHAR(30) | NO  |     | `CHECK (type IN ('EMAIL_VERIFICATION', 'PASSWORD_RESET', 'LOGIN_OTP', 'MAGIC_LINK'))` | Phân loại mục đích của mã xác thực2. |
| **code\_hash** | TEXT | NO  |     |     | Chuỗi băm (Hash) của mã bí mật để đảm bảo an toàn, không lưu dạng rõ2. |
| **expires\_at** | TIMESTAMPTZ | NO  |     |     | Thời điểm mã hết hạn (thường từ 5-15 phút)26. |
| **attempt\_count** | INT | NO  | `0` | `CHECK (attempt_count <= 5)` | Bộ đếm số lần nhập sai để chống tấn công Brute-force26. |
| **metadata** | JSONB | YES | `'{}'` |     | Lưu ngữ cảnh bổ sung như `redirect_url` hoặc `device_info`26. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo mã (UTC)27. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Dưới đây là các câu lệnh SQL được thiết kế tối ưu cho YugabyteDB để đảm bảo tính toàn vẹn dữ liệu và hiệu năng truy vấn cao2....

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE auth_verification_codes (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. NỘI DUNG & LOẠI XÁC THỰC
    identifier VARCHAR(255) NOT NULL,
    type VARCHAR(30) NOT NULL,
    code_hash TEXT NOT NULL,
    
    -- III. KIỂM SOÁT THỜI GIAN & BẢO MẬT
    expires_at TIMESTAMPTZ NOT NULL,
    attempt_count INT NOT NULL DEFAULT 0,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_auth_codes_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_auth_codes_type CHECK (type IN ('EMAIL_VERIFICATION', 'PASSWORD_RESET', 'LOGIN_OTP', 'MAGIC_LINK')),
    CONSTRAINT chk_auth_codes_attempts CHECK (attempt_count <= 5),
    CONSTRAINT chk_auth_codes_expiry CHECK (expires_at > created_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm nhanh mã hợp lệ gần nhất cho một User/Email/Phone cụ thể
-- Giúp tăng tốc luồng verify OTP khi user nhập mã
CREATE INDEX idx_auth_codes_lookup 
ON auth_verification_codes (tenant_id, identifier, type, expires_at DESC);

-- Index hỗ trợ dọn dẹp các mã đã hết hạn (Cleanup Job)
-- Sử dụng Partial Index để chỉ tập trung vào các bản ghi đã quá hạn
CREATE INDEX idx_auth_codes_cleanup 
ON auth_verification_codes (expires_at) 
WHERE expires_at < NOW();
```

Các điểm nhấn kỹ thuật theo nguồn dữ liệu:

• **Bảo mật tuyệt đối:** Theo quy chuẩn, mật mã không bao giờ được lưu ở dạng rõ; trường `code_hash` sử dụng thuật toán băm giúp bảo vệ người dùng ngay cả khi cơ sở dữ liệu bị rò rỉ2.

• **Chống tấn công Brute-force:** Ràng buộc `attempt_count <= 5` kết hợp với logic ứng dụng sẽ tự động vô hiệu hóa mã nếu người dùng nhập sai quá số lần quy định6.

• **Hiệu năng Sharding:** Sử dụng **UUID v7** làm khóa chính giúp dữ liệu được phân tán đều trên các node của YugabyteDB, tránh hiện tượng "hotspot" khi có hàng triệu yêu cầu OTP được gửi đi cùng lúc310.

• **SaaS Isolation:** Trường `tenant_id` được đưa vào Index phức hợp để đảm bảo dữ liệu xác thực của các tổ chức luôn được tách biệt hoàn toàn511.

**Sự ví von:** Bảng `auth_verification_codes` giống như một **tập cuống vé xem phim có thời hạn**. Mỗi cuống vé (`code_hash`) chỉ dành cho một người (`identifier`) và một suất chiếu cụ thể (`type`). Nếu bạn không vào rạp trước giờ phim bắt đầu (`expires_at`) hoặc cố tình dùng vé giả quá nhiều lần (`attempt_count`), cuống vé đó sẽ trở thành rác vô giá trị và bị ban quản lý dọn dẹp sạch sẽ.



thiết kế chi tiết bảng personal\_access\_tokens dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống xác thực dành cho nhà phát triển (Developer Experience - DevEx) và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **personal\_access\_tokens** (PATs) sử dụng YugabyteDB (YSQL).

Việc sử dụng PATs cho phép các lập trình viên hoặc các kịch bản tự động (scripts) tích hợp với hệ thống mà không cần sử dụng mật khẩu hoặc duy trì phiên đăng nhập ngắn hạn (Session), giúp mở rộng SaaS thành một nền tảng mở12.

1\. Thiết kế chi tiết bảng `personal_access_tokens`

Bảng này được thiết kế để lưu trữ bản băm (hash) của token thay vì bản rõ để đảm bảo an toàn tuyệt đối3.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất. Sử dụng **UUID v7** để tối ưu sắp xếp theo thời gian và tránh "hotspot" trong DB phân tán14. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định token thuộc tổ chức nào để đảm bảo tính cô lập dữ liệu (SaaS Isolation)35. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Người dùng sở hữu và tạo ra token này1. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên gợi nhớ của token (Ví dụ: "Script Sync Excel", "Jenkins CI/CD")3. |
| **token\_prefix** | VARCHAR(10) | NO  |     |     | Chuỗi tiền tố (Ví dụ: `pat_live_`) để người dùng nhận diện token mà không cần lộ toàn bộ3. |
| **token\_hash** | TEXT | NO  |     | `UNIQUE` | **Bản băm** của token (SHA-256). **Tuyệt đối không lưu token gốc**3. |
| **scopes** | TEXT\[\] | NO  |     |     | Mảng các quyền hạn (Ví dụ: `['user:read', 'report:export']`) giới hạn phạm vi truy cập3. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` |     | Ghi lại thời điểm gần nhất token này được sử dụng để gọi API3. |
| **expires\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm hết hạn. Nếu `NULL` nghĩa là token vĩnh viễn (khuyến nghị có hạn)3. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kích hoạt. Cho phép người dùng vô hiệu hóa nhanh token mà không cần xóa2. |
| **created\_at** | TIMESTAMPTZ | NO  | `NOW()` |     | Thời điểm tạo mã token (luôn lưu theo giờ UTC)67. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** để tránh ghi đè dữ liệu đồng thời89. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Dưới đây là mã lệnh YSQL để triển khai bảng và các chỉ mục chiến lược nhằm tối ưu hóa hiệu năng truy vấn trong môi trường phân tán10.

```
-- 1. Câu lệnh tạo bảng personal_access_tokens
CREATE TABLE personal_access_tokens (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    user_id UUID NOT NULL,
    
    -- II. THÔNG TIN TOKEN & BẢO MẬT
    name TEXT NOT NULL,
    token_prefix VARCHAR(10) NOT NULL,
    token_hash TEXT NOT NULL,
    scopes TEXT[] NOT NULL, -- Kiểu mảng hỗ trợ phân quyền linh hoạt
    
    -- III. TRẠNG THÁI & THỜI GIAN
    last_used_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_pat_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_pat_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT uq_token_hash UNIQUE (token_hash),
    CONSTRAINT chk_pat_name CHECK (LENGTH(name) > 0)
);

-- 2. Chiến lược đánh Index (Indexing Strategy)

-- Index hỗ trợ xác thực token cực nhanh khi có request API
-- Truy vấn: SELECT user_id, scopes FROM personal_access_tokens WHERE token_hash = ? AND is_active = TRUE;
CREATE INDEX idx_pat_auth_lookup 
ON personal_access_tokens (token_hash) 
WHERE is_active = TRUE;

-- Index hỗ trợ trang quản lý: Hiển thị danh sách token của một người dùng trong một Tenant
CREATE INDEX idx_pat_user_list 
ON personal_access_tokens (tenant_id, user_id);

-- Index hỗ trợ các tác vụ dọn dẹp (Cleanup) token đã hết hạn
CREATE INDEX idx_pat_expiry 
ON personal_access_tokens (expires_at) 
WHERE expires_at IS NOT NULL;
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7**: Đảm bảo các token mới tạo được sắp xếp tuần tự theo thời gian, giúp YugabyteDB phân bổ dữ liệu vào các "Tablets" một cách hiệu quả và giảm thiểu việc tranh chấp (hotspot)411.

• **Security (Bảo mật)**: Chỉ lưu `token_hash`. Nếu cơ sở dữ liệu bị rò rỉ, kẻ tấn công cũng không thể lấy được token gốc để truy cập hệ thống3.

• **Scopes (Phạm vi quyền)**: Sử dụng kiểu `TEXT[]` giúp hệ thống kiểm tra quyền hạn cực kỳ linh hoạt (Ví dụ: `WHERE 'user:read' = ANY(scopes)`)1213.

• **SaaS Isolation**: Trường `tenant_id` luôn hiện diện để đảm bảo quy trình xác thực không bao giờ bị lẫn lộn giữa các khách hàng khác nhau514.

**Ví dụ trực quan:** Bảng `personal_access_tokens` giống như một **danh sách các thẻ từ phụ** mà bạn cấp cho nhân viên để vào kho. Bạn không cho họ chìa khóa tổng (mật khẩu), mà cho họ một chiếc thẻ chỉ được phép mở cửa kho (scopes) và có thời hạn nhất định (expires\_at). Nếu họ làm mất, bạn chỉ cần vô hiệu hóa chiếc thẻ đó (is\_active = FALSE) là xong.



thiết kế chi tiết bảng roles dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống SaaS "World-class" và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **roles**.

Bảng này được thiết kế theo mô hình **RBAC (Role-Based Access Control)** chuyên sâu dành cho Enterprise, cho phép định nghĩa các vai trò hệ thống và vai trò tùy chỉnh cho từng Tenant1,2.

1\. Thiết kế chi tiết bảng `roles` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**, giúp tối ưu hóa sắp xếp theo thời gian và sharding3,4. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định vai trò này thuộc tổ chức nào (Sharding Key)5,4. |
| **name** | VARCHAR(100) | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên vai trò (VD: Admin, Editor, HR Manager)4. |
| **description** | TEXT | YES | `NULL` |     | Mô tả chi tiết về trách nhiệm của vai trò này4. |
| **type** | VARCHAR(20) | NO  | `'CUSTOM'` | `CHECK (type IN ('SYSTEM', 'CUSTOM'))` | **SYSTEM**: Vai trò mặc định không thể xóa. **CUSTOM**: Vai trò do khách hàng tự định nghĩa6. |
| **permission\_codes** | TEXT\[\] | NO  | `'{}'` |     | Mảng chứa các mã quyền (VD: `{'user:view', 'invoice:create'}`). Lưu mảng giúp truy vấn nhanh mà không cần join bảng trung gian6. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo vai trò (UTC)7,8. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng8. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | **Optimistic Locking**: Ngăn chặn xung đột khi nhiều Admin cùng sửa cấu hình vai trò5,6. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn phân tán9,10.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE roles (
    -- I. ĐỊNH DANH & PHÂN TÁCH (IDENTITY & SHARDING)
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN NGHIỆP VỤ
    name VARCHAR(100) NOT NULL,
    description TEXT,
    type VARCHAR(20) NOT NULL DEFAULT 'CUSTOM',
    
    -- III. QUYỀN HẠN (Sử dụng mảng TEXT[] để tối ưu hiệu năng)
    permission_codes TEXT[] NOT NULL DEFAULT '{}',
    
    -- IV. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_role_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_role_type CHECK (type IN ('SYSTEM', 'CUSTOM')),
    CONSTRAINT chk_role_version CHECK (version >= 1),
    CONSTRAINT chk_role_dates CHECK (updated_at >= created_at),
    -- Đảm bảo tên vai trò là duy nhất trong phạm vi một Tenant
    CONSTRAINT uq_role_name_per_tenant UNIQUE (tenant_id, name)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lấy nhanh danh sách vai trò của một Tenant
CREATE INDEX idx_roles_tenant_lookup 
ON roles (tenant_id);

-- Index GIN hỗ trợ tìm kiếm các vai trò có chứa một mã quyền cụ thể
-- Query: SELECT * FROM roles WHERE 'user:view' = ANY(permission_codes);
CREATE INDEX idx_roles_permissions 
ON roles USING GIN (permission_codes);
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7:** Đảm bảo các vai trò mới được tạo sẽ được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ được tính chất tuần tự theo thời gian, giúp việc index và truy vấn hiệu quả hơn3,11.

• **Permission Flattening (Phẳng hóa quyền):** Thay vì sử dụng bảng trung gian `role_permissions` truyền thống, việc lưu mã quyền dưới dạng mảng `TEXT[]` giúp hệ thống kiểm tra quyền hạn cực nhanh chỉ với một câu truy vấn duy nhất, giảm thiểu chi phí JOIN trong môi trường dữ liệu phân tán1,6.

• **Tenant Isolation (Cô lập Tenant):** Ràng buộc `UNIQUE (tenant_id, name)` đảm bảo tính toàn vẹn dữ liệu, không cho phép trùng tên vai trò trong cùng một tổ chức nhưng vẫn cho phép các tổ chức khác nhau có cùng tên vai trò12.

• **Optimistic Locking:** Cột `version` bảo vệ cấu hình vai trò khỏi các lỗi ghi đè dữ liệu đồng thời khi có nhiều quản trị viên cùng thao tác5.

**Sự ví von:** Bảng `roles` giống như một **bộ danh mục các "thẻ thông hành"** trong một tòa nhà văn phòng (Tenant). Mỗi tấm thẻ (`_id`) có một tên gọi (`name`) như "Bảo vệ" hay "Giám đốc" và được ghi sẵn danh sách những cánh cửa mà người cầm thẻ được phép mở (`permission_codes`). Việc sử dụng UUID v7 giúp người quản lý sắp xếp các tấm thẻ này vào kho lưu trữ một cách khoa học nhất theo thứ tự cấp phát.



thiết kế chi tiết bảng permissions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống RBAC (Role-Based Access Control) chuyên sâu cho SaaS và quy chuẩn kỹ thuật YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **permissions**.

Bảng này đóng vai trò là danh mục các hành động kỹ thuật (quyền hạn) cấp hệ thống do nhà phát triển định nghĩa để kiểm soát truy cập vào các module chức năng khác nhau1,2.

1\. Thiết kế chi tiết bảng `permissions` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian3,4. |
| **code** | VARCHAR(100) | NO  |     | `UNIQUE`, `CHECK (LENGTH(code) > 0)` | Mã quyền duy nhất dùng trong code (VD: `invoice:create`, `user:view`)1,5. |
| **module** | VARCHAR(50) | NO  |     |     | Tên module chức năng sở hữu quyền này (VD: `FINANCE`, `HRM`, `IAM`)1. |
| **description** | TEXT | YES | `NULL` |     | Mô tả chi tiết ý nghĩa và phạm vi tác động của quyền này1. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo quyền trong hệ thống (UTC)6,7. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật thông tin quyền gần nhất8. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn trong môi trường phân tán9,10.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE permissions (
    -- I. ĐỊNH DANH (IDENTITY)
    -- Khuyến nghị sinh UUID v7 từ tầng Application để tối ưu hiệu năng ghi
    _id UUID PRIMARY KEY, 
    
    -- II. THÔNG TIN NGHIỆP VỤ (BUSINESS DATA)
    -- Code là định danh logic để ứng dụng kiểm tra quyền (Entitlement Check)
    code VARCHAR(100) NOT NULL, 
    module VARCHAR(50) NOT NULL,
    description TEXT,
    
    -- III. TRUY VẾT (AUDIT)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_permissions_code UNIQUE (code),
    CONSTRAINT chk_permissions_code_len CHECK (LENGTH(code) > 0),
    CONSTRAINT chk_permissions_dates CHECK (updated_at >= created_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh mã quyền khi ứng dụng thực hiện kiểm tra quyền hạn (AuthZ)
-- Query: SELECT _id FROM permissions WHERE code = 'user:view_salary';
CREATE UNIQUE INDEX idx_permissions_code_lookup ON permissions (code);

-- Index hỗ trợ việc phân loại và hiển thị danh sách quyền theo module trong trang quản trị Roles
-- Query: SELECT * FROM permissions WHERE module = 'FINANCE';
CREATE INDEX idx_permissions_module_group ON permissions (module);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **UUID v7 cho Khóa chính:** Việc sử dụng UUID v7 thay vì Serial Int truyền thống giúp tránh hiện tượng "Hotspot" (nghẽn cổ chai) khi ghi dữ liệu đồng thời vào các node trong cụm YugabyteDB, đồng thời vẫn giữ được khả năng sắp xếp theo thời gian3,10.

• **Tách biệt Permission và Role:** Bảng này chỉ chứa danh mục quyền tĩnh do hệ thống quy định1. Các quyền này sau đó sẽ được "phẳng hóa" (Flattening) và lưu vào mảng `permission_codes` của bảng `roles` để tối ưu hóa tốc độ kiểm tra quyền mà không cần thực hiện JOIN nhiều bảng phức tạp trong môi trường SQL phân tán11,12.

• **Module-based Grouping:** Trường `module` giúp tổ chức cây phân quyền trên giao diện người dùng (UI) một cách khoa học, giúp quản trị viên dễ dàng quản lý hàng trăm quyền hạn khác nhau trong một hệ thống Enterprise SaaS1,13.

**Ví dụ trực quan:** Bảng `permissions` giống như **danh mục các loại chìa khóa** có thể tồn tại trong một tòa nhà. Một quyền (`code`) như `door:open` đại diện cho khả năng mở một cánh cửa cụ thể. Các chìa khóa này sau đó sẽ được gom vào các "chùm chìa khóa" (Roles) để cấp cho từng nhân viên (Users) tùy theo vị trí công việc của họ.



thiết kế chi tiết bảng user\_roles dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về mô hình phân quyền **RBAC (Role-Based Access Control)** chuyên sâu cho Enterprise SaaS và các quy chuẩn kỹ thuật của YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **user\_roles**.

Bảng này đóng vai trò là "cầu nối" để gán các vai trò cụ thể cho người dùng trong từng tổ chức (Tenant), đồng thời hỗ trợ cơ chế **Data Scoping** (Phạm vi dữ liệu) để giới hạn quyền hạn trong một không gian cụ thể như phòng ban hoặc chi nhánh12.

1\. Thiết kế chi tiết bảng `user_roles`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sắp xếp theo thời gian và tránh "hotspot" khi ghi phân tán34. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation), xác định quan hệ này thuộc về khách hàng nào15. |
| **member\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id) ON DELETE CASCADE` | Liên kết với hồ sơ nhân viên trong tổ chức (thay vì User gốc) để quản lý vòng đời nhân sự67. |
| **role\_id** | UUID | NO  |     | `REFERENCES roles(_id) ON DELETE CASCADE` | Vai trò được gán (VD: Manager, Editor)18. |
| **scope\_type** | VARCHAR(50) | NO  | `'GLOBAL'` | `CHECK (scope_type IN ('GLOBAL', 'DEPARTMENT', 'LOCATION', 'PROJECT'))` | Phạm vi áp dụng quyền: Toàn cục, theo phòng ban, hoặc theo dự án cụ thể2. |
| **scope\_values** | TEXT\[\] | NO  | `'{}'` |     | Mảng chứa các UUID của phòng ban/vị trí tương ứng với `scope_type`9. |
| **assigned\_by** | UUID | YES | `NULL` |     | ID của người thực hiện gán quyền để phục vụ truy vết (Audit)110. |
| **assigned\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm chính xác quyền được gán (UTC)111. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng các ràng buộc cứng và chỉ mục phức hợp để đảm bảo tính toàn vẹn và tốc độ truy vấn "phẳng hóa" quyền hạn cực nhanh212.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_roles (
    -- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINKING)
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    member_id UUID NOT NULL,
    role_id UUID NOT NULL,
    
    -- II. PHẠM VI DỮ LIỆU (DATA SCOPING)
    scope_type VARCHAR(50) NOT NULL DEFAULT 'GLOBAL',
    scope_values TEXT[] NOT NULL DEFAULT '{}',
    
    -- III. TRUY VẾT (AUDIT)
    assigned_by UUID,
    assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_ur_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_ur_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id) ON DELETE CASCADE,
    CONSTRAINT fk_ur_role FOREIGN KEY (role_id) REFERENCES roles(_id) ON DELETE CASCADE,
    
    -- Đảm bảo không gán trùng lặp 1 Role với cùng 1 Scope cho 1 người
    CONSTRAINT uq_member_role_scope UNIQUE (member_id, role_id, scope_type),
    
    -- Kiểm tra giá trị hợp lệ cho scope_type
    CONSTRAINT chk_ur_scope_type CHECK (scope_type IN ('GLOBAL', 'DEPARTMENT', 'LOCATION', 'PROJECT'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng nhất: Lấy toàn bộ Role và Scope của nhân viên khi đăng nhập để tính toán quyền (Flattening)
CREATE INDEX idx_ur_member_lookup 
ON user_roles (member_id, tenant_id);

-- Index hỗ trợ tìm kiếm: "Ai là Manager của Department X?"
CREATE INDEX idx_ur_scope_search 
ON user_roles USING GIN (scope_values) 
WHERE scope_type = 'DEPARTMENT';
```

Các điểm nhấn kỹ thuật từ nguồn dữ liệu:

• **UUID v7 & Sharding:** Việc sử dụng UUID v7 cho khóa chính giúp các bản ghi gán quyền mới được phân tán đều trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai khi có đợt cấp quyền hàng loạt cho nhân viên mới413.

• **Phân quyền ma trận (Matrix Authorization):** Thông qua `scope_type` và `scope_values`, hệ thống cho phép một nhân viên làm **Manager ở Phòng IT** nhưng chỉ là **Member ở Phòng Marketing**29.

• **Hiệu năng truy vấn:** Thay vì phải JOIN nhiều bảng trung gian, việc lưu `scope_values` dạng mảng `TEXT[]` giúp API Gateway có thể kiểm tra quyền truy cập tài nguyên của người dùng chỉ với một lần quét index duy nhất112.

• **Tuân thủ GDPR/Security:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một vai trò (`role`) bị xóa hoặc một thành viên (`member`) rời khỏi tổ chức, các bản ghi phân quyền liên quan sẽ bị dọn dẹp sạch sẽ ngay lập tức1014.

**Sự ví von để dễ hiểu:** Bảng `user_roles` giống như một **tờ lệnh điều động nhân sự**. Nó không chỉ ghi tên người và tên chức vụ, mà còn ghi rõ "Anh A làm Trưởng phòng (Role) nhưng chỉ tại chi nhánh Hà Nội (Scope)". Khi anh A đi qua cửa bảo vệ (API Gateway), bảo vệ chỉ cần nhìn tờ lệnh này là biết anh được phép mở những cánh cửa nào trong chi nhánh đó.



thiết kế chi tiết bảng relationship\_tuples dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về mô hình phân quyền dựa trên quan hệ (**ReBAC - Relationship-Based Access Control**) theo kiến trúc **Google Zanzibar** từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **relationship\_tuples** sử dụng YugabyteDB (YSQL)12.

Bảng này đóng vai trò là "trái tim" của hệ thống phân quyền động, cho phép xử lý các kịch bản chia sẻ tài nguyên phức tạp (như chia sẻ thư mục, tài liệu, dự án) với khả năng thừa kế quyền hạn theo chiều sâu13.

1\. Thiết kế chi tiết bảng `relationship_tuples`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Định danh tổ chức sở hữu quan hệ này (SaaS Isolation)2. |
| **namespace** | VARCHAR(50) | NO  |     | `CHECK (LENGTH(namespace) > 0)` | Loại tài nguyên (Object Namespace) như: `document`, `folder`, `project`2. |
| **object\_id** | UUID | NO  |     |     | Định danh cụ thể của tài nguyên (Sử dụng UUID v7 để tối ưu)2. |
| **relation** | VARCHAR(50) | NO  |     |     | Mối quan hệ như: `viewer`, `editor`, `owner`, `parent`2. |
| **subject\_namespace** | VARCHAR(50) | NO  |     |     | Loại đối tượng được gán quyền: `user`, `group`, hoặc một `folder` (nếu thừa kế)2. |
| **subject\_id** | UUID | NO  |     |     | Định danh của đối tượng (User/Group ID)2. |
| **subject\_relation** | VARCHAR(50) | YES | `NULL` |     | Dùng cho quan hệ lồng nhau (VD: "Thành viên của nhóm A")3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo quan hệ (UTC)3. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng **Khóa chính phức hợp (Composite Primary Key)** để tối ưu hóa việc duyệt đồ thị quan hệ và đảm bảo không có các cặp quan hệ trùng lặp3.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE relationship_tuples (
    tenant_id UUID NOT NULL,
    
    -- THÔNG TIN TÀI NGUYÊN (OBJECT)
    namespace VARCHAR(50) NOT NULL,
    object_id UUID NOT NULL,
    
    -- MỐI QUAN HỆ (RELATION)
    relation VARCHAR(50) NOT NULL,
    
    -- ĐỐI TƯỢNG NHẬN QUYỀN (SUBJECT)
    subject_namespace VARCHAR(50) NOT NULL,
    subject_id UUID NOT NULL,
    subject_relation VARCHAR(50),
    
    -- THỜI GIAN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_tuples_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    
    -- Khóa chính phức hợp tối ưu cho việc truy vấn từ Object sang Subject
    PRIMARY KEY (tenant_id, namespace, object_id, relation, subject_namespace, subject_id)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index đảo ngược (Reverse Lookup Index)
-- Hỗ trợ trả lời cực nhanh câu hỏi: "Người dùng A có quyền xem những tài liệu nào?"
CREATE INDEX idx_tuples_reverse_lookup 
ON relationship_tuples (tenant_id, subject_id, relation, namespace);

-- Index hỗ trợ kiểm tra quyền theo loại tài nguyên (Namespace)
CREATE INDEX idx_tuples_namespace_lookup 
ON relationship_tuples (tenant_id, namespace, relation);
```

Các điểm nhấn kỹ thuật quan trọng:

• **Mô hình Bộ ba (Tuples):** Cấu trúc này cho phép hệ thống phân quyền không chỉ cho người dùng (`user`) mà còn cho cả các nhóm (`group`) hoặc các tài nguyên khác (`folder`), tạo ra khả năng thừa kế quyền hạn (VD: Nếu bạn là editor của Folder A, và Folder A là parent của Doc B, bạn tự động có quyền trên Doc B)13.

• **UUID v7 & Sharding:** Việc sử dụng UUID v7 cho các định danh giúp dữ liệu được sắp xếp tuần tự theo thời gian nhưng vẫn phân tán đều trên các node của YugabyteDB, tránh hiện tượng nghẽn cổ chai (hotspot) khi có hàng triệu quan hệ được tạo ra45.

• **Hiệu năng thực thi:** Nhờ vào Khóa chính phức hợp và Index đảo ngược, hệ thống có thể thực hiện các phép kiểm tra quyền (Check) và tìm kiếm (Expand) với độ trễ cực thấp ngay cả khi dữ liệu lên tới hàng tỷ bản ghi3.

• **Bảo mật & Toàn vẹn:** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một tổ chức (`tenant`) bị xóa, toàn bộ bản đồ quan hệ phức tạp của họ cũng sẽ được dọn dẹp sạch sẽ để đảm bảo an toàn dữ liệu2.

**Sự ví von:** Bảng `relationship_tuples` giống như một **bản đồ các sợi dây liên kết** trong một thư viện khổng lồ. Thay vì dán nhãn tên người lên từng cuốn sách, hệ thống này tạo ra các sợi dây nối giữa "Người" và "Sách", hoặc giữa "Sách" và "Kệ sách". Khi bạn có chìa khóa của "Kệ sách", bạn mặc nhiên có quyền chạm vào mọi cuốn "Sách" được nối với kệ đó qua sợi dây "parent".



thiết kế chi tiết bảng access\_control\_lists dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh và phân quyền (IAM) dành cho Enterprise SaaS trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **access\_control\_lists** (ACL) sử dụng YugabyteDB (YSQL).

Bảng này đóng vai trò quan trọng trong việc cho phép phân quyền chi tiết tới từng tài nguyên cụ thể (như Folder X, Dashboard Y), vượt xa khả năng của mô hình RBAC (Role-based) thông thường1.

1\. Thiết kế chi tiết bảng `access_control_lists`

Bảng được thiết kế theo quy chuẩn **snake\_case**, sử dụng **UUID v7** để tối ưu hóa hiệu năng chèn dữ liệu và sắp xếp theo thời gian trong môi trường phân tán23.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7** giúp tối ưu sharding3. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation)14. |
| **resource\_type** | VARCHAR(50) | NO  |     | `CHECK (LENGTH(resource_type) > 0)` | Loại tài nguyên (VD: 'DASHBOARD', 'REPORT', 'FOLDER')1. |
| **resource\_id** | UUID | NO  |     |     | ID cụ thể của tài nguyên được phân quyền1. |
| **subject\_type** | VARCHAR(20) | NO  |     | `CHECK (subject_type IN ('MEMBER', 'GROUP', 'ROLE'))` | Loại đối tượng nhận quyền (Thành viên, Nhóm, hoặc Vai trò)1. |
| **subject\_id** | UUID | NO  |     |     | ID của đối tượng nhận quyền (Member ID hoặc Group ID)1. |
| **action** | VARCHAR(50) | NO  |     | `CHECK (action IN ('READ', 'WRITE', 'DELETE', 'SHARE'))` | Hành động được phép thực hiện trên tài nguyên1. |
| **is\_allowed** | BOOLEAN | NO  | `TRUE` |     | `TRUE` là cho phép, `FALSE` là chặn cụ thể (Deny)5. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC) phục vụ truy vết46. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng **Composite Unique Constraint** để đảm bảo tính toàn vẹn, tránh việc trùng lặp các quy tắc phân quyền cho cùng một đối tượng5.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_control_lists (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN TÀI NGUYÊN (RESOURCE)
    resource_type VARCHAR(50) NOT NULL,
    resource_id UUID NOT NULL,
    
    -- III. THÔNG TIN ĐỐI TƯỢNG (SUBJECT)
    subject_type VARCHAR(20) NOT NULL,
    subject_id UUID NOT NULL,
    
    -- IV. QUYỀN HẠN
    action VARCHAR(50) NOT NULL,
    is_allowed BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- V. TRUY VẾT
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- VI. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_acl_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT uq_acl_entry UNIQUE (tenant_id, resource_type, resource_id, subject_type, subject_id, action),
    CONSTRAINT chk_acl_subject_type CHECK (subject_type IN ('MEMBER', 'GROUP', 'ROLE')),
    CONSTRAINT chk_acl_action CHECK (action IN ('READ', 'WRITE', 'DELETE', 'SHARE'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ kiểm tra quyền của một Member đối với một tài nguyên cụ thể (AuthZ Check)
CREATE INDEX idx_acl_lookup 
ON access_control_lists (tenant_id, resource_id, subject_id);

-- Index hỗ trợ việc lấy danh sách tất cả các tài nguyên mà một Member/Group có quyền truy cập
CREATE INDEX idx_acl_subject_search 
ON access_control_lists (tenant_id, subject_id, subject_type);
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7 và Sharding:** Việc sử dụng UUID v7 làm khóa chính giúp các bản ghi phân quyền mới được phân tán đều trên các node (tablets) của YugabyteDB, tránh hiện tượng "hotspot" khi hệ thống thực hiện cấp quyền hàng loạt78.

• **Phân quyền Tài nguyên (Resource-level):** Bảng này cho phép xây dựng các tính năng như "Chia sẻ thư mục" hay "Phân quyền báo cáo" cho từng cá nhân, điều mà các vai trò hệ thống (Global Roles) không làm được15.

• **Tính nhất quán mạnh (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant hoặc Member bị xóa, các bản ghi quyền hạn liên quan sẽ bị xóa bỏ ngay lập tức, tránh dữ liệu rác và đảm bảo an ninh910.

• **Hiệu năng truy vấn:** Bằng cách sử dụng **Composite Index**, hệ thống có thể kiểm tra quyền hạn của người dùng (AuthZ) với độ trễ cực thấp ngay cả khi bảng chứa hàng triệu quy tắc phân quyền1112.

**Ví von:** Bảng `access_control_lists` giống như một **danh sách khách mời chi tiết cho từng phòng** trong một khách sạn lớn (Tenant). Thay vì chỉ có chìa khóa tổng (Role), danh sách này ghi rõ: "Anh An (Subject) được phép vào (Action) phòng 101 (Resource)". Mỗi khi có ai đó định mở cửa, bảo vệ (API Gateway) chỉ cần liếc nhanh qua danh sách này để quyết định có cho qua hay không.



thiết kế chi tiết bảng tenant\_domains dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho doanh nghiệp và quy chuẩn thiết kế SaaS từ các nguồn dữ liệu, bảng **tenant\_domains** đóng vai trò cực kỳ quan trọng trong việc quản lý chủ quyền dữ liệu, giải quyết vấn đề **"Shadow IT"** và bắt buộc thực thi các chính sách bảo mật như SSO trên toàn bộ tên miền của tổ chức12.

Việc sử dụng **UUID v7** giúp hệ thống tối ưu hóa việc sắp xếp theo thời gian và phân tán dữ liệu hiệu quả trên các node của YugabyteDB34.

1\. Thiết kế chi tiết bảng `tenant_domains`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất (UUID v7) giúp tránh hiện tượng "Hotspot" khi chèn dữ liệu phân tán23. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết đến tổ chức sở hữu tên miền này2. |
| **domain** | VARCHAR(255) | NO  |     | `UNIQUE`, `CHECK (domain ~ '^[a-z0-9.-]+$')` | Tên miền (VD: `fpt.com`). Phải là duy nhất trên toàn hệ thống để xác định chủ quyền5. |
| **verification\_status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (status IN ('PENDING', 'VERIFIED'))` | Trạng thái xác minh chủ sở hữu tên miền2. |
| **verification\_method** | VARCHAR(20) | YES | `NULL` | `CHECK (method IN ('DNS_TXT', 'HTML_FILE'))` | Phương thức khách hàng chọn để chứng minh quyền sở hữu (DNS hoặc file HTML)5. |
| **verification\_token** | VARCHAR(100) | YES | `NULL` |     | Mã bí mật khách hàng phải cấu hình vào DNS/Web server để hệ thống đối soát2. |
| **policy** | VARCHAR(20) | NO  | `'NONE'` | `CHECK (policy IN ('NONE', 'CAPTURE', 'ENFORCE_SSO'))` | **CAPTURE**: Tự động đưa user đăng ký bằng email đuôi này vào Tenant. **ENFORCE\_SSO**: Bắt buộc đăng nhập qua SSO5. |
| **verified\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm xác thực thành công (UTC)56. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm bản ghi được tạo (UTC)26. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Thiết kế này sử dụng các chuẩn mực về kiểu dữ liệu và ràng buộc để đảm bảo tính nhất quán mạnh (Strong Consistency) theo yêu cầu của hệ thống lõi SaaS78.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_domains (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN TÊN MIỀN
    domain VARCHAR(255) NOT NULL,
    
    -- III. QUY TRÌNH XÁC THỰC
    verification_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    verification_method VARCHAR(20),
    verification_token VARCHAR(100),
    
    -- IV. CHÍNH SÁCH HÀNH VI
    policy VARCHAR(20) NOT NULL DEFAULT 'NONE',
    
    -- V. TRUY VẾT THỜI GIAN
    verified_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- VI. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_domain_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT uq_tenant_domain_name UNIQUE (domain), -- Một domain chỉ thuộc về 1 Tenant duy nhất
    CONSTRAINT chk_domain_status CHECK (verification_status IN ('PENDING', 'VERIFIED')),
    CONSTRAINT chk_domain_method CHECK (verification_method IN ('DNS_TXT', 'HTML_FILE')),
    CONSTRAINT chk_domain_policy CHECK (policy IN ('NONE', 'CAPTURE', 'ENFORCE_SSO')),
    CONSTRAINT chk_domain_fmt CHECK (domain ~ '^[a-z0-9.-]+$') -- Chỉ cho phép chữ thường, số, dấu chấm và gạch ngang
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm nhanh Tenant sở hữu một tên miền khi User đăng ký hoặc đăng nhập
CREATE UNIQUE INDEX idx_tenant_domain_lookup 
ON tenant_domains (domain) 
WHERE verification_status = 'VERIFIED';

-- Index hỗ trợ việc quản lý danh sách domain của một Tenant cụ thể
CREATE INDEX idx_tenant_domain_list 
ON tenant_domains (tenant_id);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **Giải quyết Shadow IT:** Thông qua chính sách `CAPTURE`, hệ thống giúp doanh nghiệp kiểm soát mọi tài khoản cá nhân đăng ký bằng email công ty, tự động quy hoạch họ về dưới sự quản lý của tổ chức12.

• **Thực thi SSO (Enforce SSO):** Đây là tính năng "Enterprise-grade". Khi một tên miền đã xác thực được đặt chính sách `ENFORCE_SSO`, bất kỳ người dùng nào sử dụng email thuộc tên miền đó sẽ bị hệ thống chặn đăng nhập bằng mật khẩu thông thường và bắt buộc phải qua cổng SSO (Azure AD, Okta...)59.

• **Tính nhất quán của YugabyteDB:** Việc sử dụng các ràng buộc `UNIQUE` và `CHECK` trực tiếp ở tầng Database đảm bảo rằng dù trong môi trường phân tán, không bao giờ xảy ra tình trạng hai tổ chức khác nhau tranh chấp cùng một tên miền1011.

**Ví von:** Bảng `tenant_domains` giống như một **quyển sổ đỏ xác nhận chủ quyền đất đai** trên không gian số. Khi một tổ chức đã "cắm cọc" và xác thực thành công mảnh đất tên miền của mình, họ có toàn quyền quyết định ai được phép vào (Capture) và phải đi vào bằng cửa nào (SSO), ngăn chặn việc người lạ hoặc nhân viên tự ý "xây nhà" trái phép trên email công ty25.



thiết kế chi tiết bảng tenant\_invitations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho doanh nghiệp và quy chuẩn thiết kế SaaS "World-class" từ các nguồn dữ liệu, bảng **tenant\_invitations** đóng vai trò quản lý quy trình mời người dùng mới tham gia vào tổ chức (Onboarding) một cách an toàn và chuyên nghiệp1,2.

Việc sử dụng **UUID v7** cho định danh giúp tối ưu hóa việc phân tán dữ liệu trên các node của YugabyteDB và đảm bảo tính tuần tự theo thời gian3,4.

1\. Thiết kế chi tiết bảng `tenant_invitations`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp thời gian3,5. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định lời mời thuộc về tổ chức nào (SaaS Isolation)2,6. |
| **email** | VARCHAR(255) | NO  |     | `CHECK (email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$')` | Email của người nhận lời mời2,6. |
| **role\_ids** | TEXT\[\] | YES | `'{}'` |     | Mảng chứa các mã vai trò (Roles) dự kiến gán cho người dùng sau khi chấp nhận2,6. |
| **department\_id** | UUID | YES | `NULL` |     | Phòng ban dự kiến người mới sẽ tham gia2,6. |
| **token** | VARCHAR(100) | NO  |     | `UNIQUE` | Mã bí mật duy nhất đính kèm trong link mời gửi qua email2,6. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (status IN ('PENDING', 'ACCEPTED', 'EXPIRED', 'REVOKED'))` | Trạng thái của lời mời (Chờ, Đã nhận, Hết hạn hoặc Bị thu hồi)2,6. |
| **expires\_at** | TIMESTAMPTZ | NO  |     | `CHECK (expires_at > created_at)` | Thời điểm link hết hạn (UTC)7,6. |
| **invited\_by** | UUID | YES | `NULL` |     | ID của người gửi lời mời để phục vụ truy vết (Audit)2,6. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo lời mời (UTC)2. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Dưới đây là các câu lệnh SQL được thiết kế tối ưu cho môi trường YugabyteDB, tuân thủ quy tắc đặt tên `snake_case` và tính toàn vẹn dữ liệu8,9.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_invitations (
    -- I. ĐỊNH DANH & LIÊN KẾT (IDENTITY & LINKING)
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN NGƯỜI NHẬN & VAI TRÒ
    email VARCHAR(255) NOT NULL,
    role_ids TEXT[] DEFAULT '{}',
    department_id UUID,
    
    -- III. KIỂM SOÁT XÁC THỰC & TRẠNG THÁI
    token VARCHAR(100) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    expires_at TIMESTAMPTZ NOT NULL,
    
    -- IV. TRUY VẾT (AUDIT)
    invited_by UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_invitation_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT uq_invitation_token UNIQUE (token),
    CONSTRAINT chk_invitation_status CHECK (status IN ('PENDING', 'ACCEPTED', 'EXPIRED', 'REVOKED')),
    CONSTRAINT chk_invitation_email_fmt CHECK (email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$'),
    CONSTRAINT chk_invitation_expiry CHECK (expires_at > created_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh khi người dùng click vào link mời (Token Lookup)
CREATE UNIQUE INDEX idx_invitation_token_lookup 
ON tenant_invitations (token) 
WHERE status = 'PENDING';

-- Index hỗ trợ Admin quản lý danh sách lời mời của một Tenant (Theo dõi tiến độ Onboarding)
CREATE INDEX idx_invitation_tenant_list 
ON tenant_invitations (tenant_id, created_at DESC);

-- Index hỗ trợ Job dọn dẹp hoặc tự động cập nhật trạng thái hết hạn
CREATE INDEX idx_invitation_expiry_cleanup 
ON tenant_invitations (expires_at) 
WHERE status = 'PENDING' AND expires_at < NOW();
```

Các lưu ý kỹ thuật từ nguồn dữ liệu:

• **Bảo mật Token:** Trường `token` cần được sinh ngẫu nhiên với độ phức tạp cao để tránh bị tấn công đoán mã (brute-force).2.

• **Quy trình Onboarding:** Theo phân tích, khi một lời mời được chuyển sang trạng thái `ACCEPTED`, hệ thống nên sử dụng dữ liệu từ `role_ids` và `department_id` để tự động tạo bản ghi trong bảng `tenant_members` và `user_roles`.2,10.

• **SaaS Isolation:** Việc bắt buộc có `tenant_id` và ràng buộc `ON DELETE CASCADE` đảm bảo rằng nếu một tổ chức ngừng sử dụng dịch vụ và bị xóa, tất cả các lời mời chưa được chấp nhận sẽ bị xóa sạch theo để đảm bảo an toàn dữ liệu.11,12.

**Sự ví von:** Bảng `tenant_invitations` giống như một **tấm vé mời tham quan VIP** của một tòa nhà văn phòng. Tấm vé ghi rõ người nhận (`email`), những phòng được phép vào (`role_ids`) và có một mã vạch duy nhất (`token`). Nếu người cầm vé không đến trước giờ đóng cửa (`expires_at`), tấm vé sẽ tự động vô hiệu hóa để bảo vệ an ninh cho tòa nhà.



thiết kế chi tiết bảng access\_reviews dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh và tuân thủ bảo mật (Governance & Compliance) cho Enterprise SaaS như ISO 27001/SOC2 trong các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **access\_reviews** sử dụng YugabyteDB (YSQL)1,2.

Bảng này đóng vai trò quản lý các đợt rà soát quyền hạn định kỳ, giúp các trưởng bộ phận (Manager) kiểm tra và xác nhận xem nhân viên còn cần các quyền hạn hiện tại hay không, từ đó giảm thiểu rủi ro "thừa quyền"1.

1\. Thiết kế chi tiết bảng `access_reviews`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh đợt rà soát. Sử dụng **UUID v7** (sinh từ tầng App) để tối ưu hóa sắp xếp và sharding3,4,1. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu (SaaS Isolation). Mỗi Tenant quản lý các đợt rà soát riêng5,1. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên đợt rà soát (VD: "Rà soát quyền hạn Q4/2024")1. |
| **description** | TEXT | YES | `NULL` |     | Mô tả chi tiết mục tiêu hoặc phạm vi của đợt rà soát này. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'))` | Trạng thái của đợt rà soát1. |
| **deadline** | TIMESTAMPTZ | NO  |     |     | Thời hạn cuối cùng phải hoàn thành việc rà soát1. |
| **created\_by** | UUID | NO  |     | `REFERENCES users(_id)` | Người khởi tạo đợt rà soát (thường là Security Admin)6. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo đợt rà soát (UTC)7,5. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật trạng thái gần nhất6. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để tránh xung đột khi nhiều Admin cùng điều chỉnh cấu hình8. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Thiết kế này tuân thủ các quy tắc về kiểu dữ liệu (TIMESTAMPTZ, UUID) và quy tắc đặt tên `snake_case` từ các nguồn dữ liệu9,4,10.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_reviews (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application để tối ưu hiệu năng ghi
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN NGHIỆP VỤ
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    
    -- III. KIỂM SOÁT THỜI GIAN & PHIÊN BẢN
    deadline TIMESTAMPTZ NOT NULL,
    created_by UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_access_review_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_access_review_creator FOREIGN KEY (created_by) REFERENCES users(_id),
    CONSTRAINT chk_review_status CHECK (status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED')),
    CONSTRAINT chk_review_dates CHECK (updated_at >= created_at),
    CONSTRAINT chk_review_version CHECK (version >= 1),
    CONSTRAINT chk_review_name_len CHECK (LENGTH(name) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm các đợt rà soát của một Tenant (Sắp xếp theo thời gian mới nhất)
CREATE INDEX idx_access_reviews_tenant_lookup 
ON access_reviews (tenant_id, created_at DESC);

-- Index hỗ trợ hệ thống quản trị theo dõi các đợt rà soát sắp đến hạn
-- Giúp chạy các Background Jobs gửi thông báo nhắc nhở (Reminder)
CREATE INDEX idx_access_reviews_deadline 
ON access_reviews (status, deadline) 
WHERE status IN ('PENDING', 'IN_PROGRESS');
```

Các điểm nhấn kỹ thuật theo nguồn dữ liệu:

• **UUID v7 cho Khóa chính:** Việc sử dụng UUID v7 giúp các bản ghi được sắp xếp tuần tự theo thời gian, tránh hiện tượng "hotspot" trong kiến trúc Distributed SQL của YugabyteDB, giúp tốc độ chèn dữ liệu nhanh hơn so với UUID v44,11.

• **Tính nhất quán mạnh (ACID):** Ràng buộc `ON DELETE CASCADE` đảm bảo khi một Tenant ngừng sử dụng dịch vụ và bị xóa, tất cả dữ liệu rà soát nhạy cảm của họ cũng sẽ được dọn dẹp sạch sẽ để tuân thủ bảo mật12.

• **Audit Trail:** Cột `created_by` và `updated_at` kết hợp với các bảng log ở ClickHouse sẽ tạo thành một bằng chứng pháp lý vững chắc khi doanh nghiệp thực hiện các cuộc kiểm toán (Audit) hàng năm5,13.

• **SaaS Isolation:** Trường `tenant_id` được đưa vào đầu của các Index phức hợp (Composite Index) để đảm bảo mọi truy vấn của khách hàng luôn được giới hạn trong phạm vi dữ liệu của họ, tối ưu hiệu năng sharding5,14.

**Ví dụ trực quan:** Bảng `access_reviews` giống như một **"Lịch tổng kiểm kho"** của một trung tâm thương mại (Tenant). Nó không ghi chi tiết từng món đồ, mà ghi lại kế hoạch: Ai thực hiện kiểm kê (`created_by`), tên đợt kiểm kê là gì (`name`), và khi nào thì phải nộp báo cáo xong (`deadline`). Nếu kế hoạch thay đổi, hệ thống sẽ tự động cập nhật phiên bản (`version`) để đảm bảo các quản lý không làm việc trên các dữ liệu cũ.



thiết kế chi tiết bảng access\_review\_items dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và tuân thủ bảo mật (ISO 27001/SOC2) dành cho Enterprise SaaS, dưới đây là thiết kế chi tiết cho bảng **access\_review\_items** sử dụng YugabyteDB (YSQL)1,2.

Bảng này lưu trữ chi tiết từng mục cần rà soát trong một đợt kiểm tra quyền hạn, giúp các cấp quản lý xác định liệu một nhân viên có nên tiếp tục giữ vai trò hiện tại hay không3,4.

1\. Thiết kế chi tiết bảng `access_review_items`

Việc sử dụng **UUID v7** làm khóa chính đảm bảo tính phân tán, tránh hiện tượng "hotspot" trên các node dữ liệu và hỗ trợ sắp xếp theo thời gian một cách tự nhiên5,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**5,7. |
| **review\_id** | UUID | NO  |     | `REFERENCES access_reviews(_id) ON DELETE CASCADE` | Liên kết với đợt rà soát tổng thể3. |
| **reviewer\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id)` | Người chịu trách nhiệm rà soát (thường là Manager trực tiếp)3. |
| **target\_member\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id)` | Nhân viên đang được kiểm tra quyền hạn3. |
| **role\_id** | UUID | NO  |     | `REFERENCES roles(_id)` | Vai trò cụ thể đang được xem xét để giữ lại hoặc thu hồi3. |
| **decision** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (decision IN ('PENDING', 'KEEP', 'REVOKE'))` | Quyết định: Đang chờ, Giữ lại, hoặc Thu hồi quyền3. |
| **reason** | TEXT | YES | `NULL` |     | Lý do cho quyết định (bắt buộc nếu chọn `REVOKE`)3. |
| **reviewed\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm người rà soát thực hiện xác nhận8,3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm mục rà soát được tạo (UTC)9. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật trạng thái mục rà soát10. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh này tuân thủ quy chuẩn `snake_case` và các ràng buộc toàn vẹn dữ liệu để đảm bảo tính nhất quán mạnh (Strong Consistency) trong môi trường phân tán11,2.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE access_review_items (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    review_id UUID NOT NULL,
    reviewer_id UUID NOT NULL,
    target_member_id UUID NOT NULL,
    role_id UUID NOT NULL,

    -- II. QUYẾT ĐỊNH RÀ SOÁT
    decision VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    reason TEXT,
    reviewed_at TIMESTAMPTZ,

    -- III. TRUY VẾT THỜI GIAN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_item_review FOREIGN KEY (review_id) REFERENCES access_reviews(_id) ON DELETE CASCADE,
    CONSTRAINT fk_item_reviewer FOREIGN KEY (reviewer_id) REFERENCES tenant_members(_id),
    CONSTRAINT fk_item_target FOREIGN KEY (target_member_id) REFERENCES tenant_members(_id),
    CONSTRAINT fk_item_role FOREIGN KEY (role_id) REFERENCES roles(_id),
    CONSTRAINT chk_item_decision CHECK (decision IN ('PENDING', 'KEEP', 'REVOKE')),
    CONSTRAINT chk_item_dates CHECK (updated_at >= created_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ trang Dashboard của người rà soát: "Lấy tất cả mục tôi cần xử lý trong đợt này"
CREATE INDEX idx_review_items_reviewer_task 
ON access_review_items (reviewer_id, review_id) 
WHERE decision = 'PENDING';

-- Index hỗ trợ báo cáo tiến độ: "Có bao nhiêu mục đã hoàn thành trong đợt rà soát X?"
CREATE INDEX idx_review_items_status 
ON access_review_items (review_id, decision);

-- Index hỗ trợ lịch sử nhân viên: "Nhân viên A đã từng bị thu hồi những quyền gì trong quá khứ?"
CREATE INDEX idx_review_items_target_history 
ON access_review_items (target_member_id) 
WHERE decision = 'REVOKE';
```

Các lưu ý kỹ thuật quan trọng từ nguồn dữ liệu:

• **Tính toàn vẹn (ACID):** Việc sử dụng YugabyteDB giúp đảm bảo rằng khi một đợt rà soát bị hủy, tất cả các mục (`items`) liên quan sẽ bị xóa sạch thông qua ràng buộc `ON DELETE CASCADE`, tránh dữ liệu rác trong hệ thống2,12.

• **Tuân thủ (Compliance):** Trường `reviewed_at` và `reviewer_id` cung cấp bằng chứng pháp lý (Audit Trail) cho các cuộc kiểm toán bảo mật, xác định rõ ai là người đã phê duyệt quyền hạn vào thời điểm nào13,14.

• **Hiệu năng Sharding:** Sử dụng UUID v7 làm khóa chính giúp phân tán các mục rà soát đều trên toàn bộ cluster, cực kỳ hữu ích khi một doanh nghiệp lớn thực hiện rà soát quyền cho hàng vạn nhân viên cùng lúc6,7.

• **Phân tách mối quan tâm:** Bảng này chỉ tập trung vào việc "phê duyệt" quyền, trong khi logic thực thi (thu hồi quyền thực tế) thường được xử lý bởi một Worker chạy ngầm sau khi đợt rà soát kết thúc15,16.

**Sự ví von:** Bảng `access_review_items` giống như một **danh sách kiểm tra (checklist) trong một kỳ thi**. Đợt rà soát (`review_id`) là kỳ thi tổng thể, còn mỗi dòng trong bảng là một câu hỏi dành cho giám thị (`reviewer_id`) về việc một thí sinh cụ thể (`target_member_id`) có đủ tư cách sử dụng một loại tài liệu (`role_id`) hay không. Mọi câu trả lời và lý do đều được ghi lại vĩnh viễn để phục vụ thanh tra về sau.



thiết kế chi tiết bảng scim\_directories dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh doanh nghiệp (IdP) và chuẩn SCIM 2.0 (System for Cross-domain Identity Management) dành cho phân khúc Enterprise SaaS từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **scim\_directories** sử dụng YugabyteDB (YSQL).

Bảng này đóng vai trò là "cổng chờ" tiếp nhận các yêu cầu đồng bộ hóa người dùng tự động từ các hệ thống như Azure AD, Okta hay OneLogin vào hệ thống SaaS của bạn1,2.

1\. Thiết kế chi tiết bảng `scim_directories` (YSQL)

Việc sử dụng **UUID v7** giúp tối ưu hóa hiệu năng ghi phân tán trên YugabyteDB bằng cách duy trì tính tuần tự theo thời gian, tránh hiện tượng "hotspot" khi có nhiều khách hàng Enterprise cùng thiết lập kết nối3,4.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp dữ liệu theo thời gian thực3,2. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu kết nối thư mục này (SaaS Isolation)5,2. |
| **provider\_type** | VARCHAR(20) | NO  |     | `CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'ONELOGIN', 'CUSTOM'))` | Loại nhà cung cấp định danh (IdP) như Azure AD, Okta...2. |
| **scim\_token\_hash** | TEXT | NO  |     | `UNIQUE` | **Bản băm** của Bearer Token dùng để xác thực các request SCIM từ IdP gửi đến2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kích hoạt của kết nối2. |
| **last\_synced\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm cuối cùng IdP thực hiện đồng bộ dữ liệu2. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo cấu hình kết nối (UTC)6,2. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** khi cập nhật cấu hình7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Dưới đây là mã lệnh YSQL để triển khai bảng và các chỉ mục chiến lược. Lưu ý rằng `scim_token_hash` cần được đánh chỉ mục để hệ thống xác thực nhanh các request API SCIM đổ vào2.

```
-- 1. Câu lệnh tạo bảng scim_directories
CREATE TABLE scim_directories (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. CẤU HÌNH KẾT NỐI
    provider_type VARCHAR(20) NOT NULL,
    scim_token_hash TEXT NOT NULL,
    
    -- III. TRẠNG THÁI & TRUY VẾT
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    last_synced_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_scim_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT uq_scim_token_hash UNIQUE (scim_token_hash),
    CONSTRAINT chk_scim_provider CHECK (provider_type IN ('AZURE_AD', 'OKTA', 'ONELOGIN', 'CUSTOM')),
    CONSTRAINT chk_scim_version CHECK (version >= 1)
);

-- 2. Chiến lược đánh Index (Indexing Strategy)

-- Index hỗ trợ xác thực cực nhanh khi IdP gọi API SCIM (Bearer Token Lookup)
-- Truy vấn: SELECT tenant_id FROM scim_directories WHERE scim_token_hash = ? AND is_active = TRUE;
CREATE INDEX idx_scim_auth_lookup 
ON scim_directories (scim_token_hash) 
WHERE is_active = TRUE;

-- Index hỗ trợ trang quản trị: Hiển thị danh sách kết nối thư mục của một Tenant
CREATE INDEX idx_scim_tenant_list 
ON scim_directories (tenant_id);
```

Các điểm nhấn kỹ thuật quan trọng:

• **Security (Bảo mật):** Tương tự như mật khẩu, chúng ta chỉ lưu `scim_token_hash`. Hệ thống sẽ không bao giờ hiển thị lại token gốc sau khi tạo để đảm bảo an toàn2.

• **SCIM Provisioning:** Bảng này là nền tảng để hỗ trợ tính năng tự động tạo/xóa người dùng từ Azure AD/Okta. Khi một nhân viên nghỉ việc ở phía khách hàng, hệ thống của họ sẽ tự động gọi đến endpoint SCIM của bạn, và bảng này giúp định tuyến request đó về đúng `tenant_id`1,2.

• **Performance (Hiệu năng):** Việc sử dụng `TIMESTAMPTZ` đảm bảo tính chính xác về thời gian đồng bộ hóa trên toàn cầu, đặc biệt quan trọng cho các tập đoàn đa quốc gia sử dụng các Shard dữ liệu khác nhau6,8.

**Sự ví von để dễ hiểu:** Bảng `scim_directories` giống như một **"tổng đài nội bộ"** kết nối trực tiếp với văn phòng chính (IdP của khách hàng). Khi văn phòng chính có nhân viên mới hoặc ai đó nghỉ việc, họ chỉ cần nhấc máy gọi qua "đường dây riêng" này (SCIM Token), và tổng đài sẽ tự động cập nhật danh sách nhân sự trong tòa nhà của bạn mà bạn không cần phải làm gì thủ công.



thiết kế chi tiết bảng scim\_mappings dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống SCIM 2.0 (System for Cross-domain Identity Management) dành cho phân khúc Enterprise SaaS và các quy chuẩn kỹ thuật YSQL từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **scim\_mappings**.

Bảng này đóng vai trò là "bản đồ ánh xạ" giữa định danh của hệ thống bên ngoài (như Azure AD, Okta) và định danh nội bộ của hệ thống SaaS, giúp tự động hóa quy trình cung cấp (Provisioning) và thu hồi (Deprovisioning) tài khoản1,2.

1\. Thiết kế chi tiết bảng `scim_mappings` (YSQL)

Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa việc sắp xếp theo thời gian và hiệu năng ghi phân tán trên YugabyteDB3,4.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**5,3. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu ánh xạ này để đảm bảo cô lập dữ liệu (SaaS Isolation)6,7. |
| **directory\_id** | UUID | NO  |     | `REFERENCES scim_directories(_id) ON DELETE CASCADE` | Liên kết với cấu hình kết nối thư mục SCIM cụ thể2. |
| **external\_id** | VARCHAR(255) | NO  |     |     | ID của đối tượng (User/Group) được cung cấp bởi hệ thống IdP bên ngoài (Azure AD/Okta)2. |
| **internal\_entity\_type** | VARCHAR(20) | NO  |     | `CHECK (internal_entity_type IN ('USER', 'GROUP'))` | Phân loại đối tượng ánh xạ là Người dùng hoặc Nhóm2. |
| **internal\_entity\_id** | UUID | NO  |     |     | ID của đối tượng tương ứng trong hệ thống nội bộ (trỏ đến `users` hoặc `user_groups`)2. |
| **data\_hash** | VARCHAR(64) | YES | `NULL` |     | Mã băm (Checksum) để so sánh và phát hiện thay đổi dữ liệu từ lần đồng bộ trước2. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật ánh xạ lần cuối (UTC)8,2. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh này tuân thủ quy tắc đặt tên `snake_case` và sử dụng các chỉ mục chiến lược để tối ưu hóa hiệu năng truy vấn trong môi trường phân tán của YugabyteDB9,10.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE scim_mappings (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    directory_id UUID NOT NULL,
    
    -- II. THÔNG TIN ÁNH XẠ (MAPPING DATA)
    external_id VARCHAR(255) NOT NULL,
    internal_entity_type VARCHAR(20) NOT NULL,
    internal_entity_id UUID NOT NULL,
    
    -- III. TRUY VẾT & ĐỒNG BỘ
    data_hash VARCHAR(64),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_scim_map_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_scim_map_dir FOREIGN KEY (directory_id) REFERENCES scim_directories(_id) ON DELETE CASCADE,
    CONSTRAINT chk_scim_entity_type CHECK (internal_entity_type IN ('USER', 'GROUP')),
    
    -- Đảm bảo một đối tượng ngoại không bị ánh xạ trùng lặp cho một thư mục
    CONSTRAINT uq_scim_external_lookup UNIQUE (directory_id, external_id, internal_entity_type)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm nhanh thực thể nội bộ khi nhận được request từ IdP (Provisioning)
-- Query: SELECT internal_entity_id FROM scim_mappings WHERE directory_id = ? AND external_id = ?;
CREATE UNIQUE INDEX idx_scim_external_sync 
ON scim_mappings (directory_id, external_id, internal_entity_type);

-- Index hỗ trợ tìm ngược từ hệ thống nội bộ để gửi update sang IdP (Deprovisioning)
-- Query: SELECT external_id FROM scim_mappings WHERE internal_entity_id = ?;
CREATE INDEX idx_scim_internal_lookup 
ON scim_mappings (internal_entity_id);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **UUID v7 làm Khóa chính:** Giúp các bản ghi ánh xạ mới được tạo ra (thường là hàng loạt khi bắt đầu đồng bộ thư mục) được phân tán đều trên các node của YugabyteDB nhưng vẫn giữ tính chất tuần tự theo thời gian để tối ưu hóa việc lưu trữ và lập chỉ mục3,4.

• **Unique Constraint (uq\_scim\_external\_lookup):** Đây là ràng buộc "sinh tử" để ngăn chặn tình trạng một User bên Azure AD bị ánh xạ nhầm vào hai User khác nhau trong hệ thống SaaS, đảm bảo tính nhất quán mạnh (Strong Consistency)11.

• **Khả năng mở rộng (Scalability):** Bằng cách lưu `data_hash`, hệ thống có thể thực hiện "Delta Sync" – chỉ cập nhật những đối tượng có thay đổi thực sự, giúp giảm tải đáng kể cho API và Database trong các đợt đồng bộ quy mô lớn (hàng chục ngàn nhân viên)2.

• **Cô lập Tenant:** Ràng buộc `ON DELETE CASCADE` với `tenant_id` đảm bảo tuân thủ quyền được quên và dọn dẹp dữ liệu sạch sẽ khi khách hàng Enterprise ngừng sử dụng dịch vụ12,2.

**Sự ví von:** Bảng `scim_mappings` giống như một **cuốn sổ hộ chiếu (Passport Log)**. Khi một người từ quốc gia khác (IdP bên ngoài) nhập cảnh vào "quốc gia SaaS" của bạn, cuốn sổ này sẽ ghi nhận: "Số hộ chiếu X của Azure AD tương ứng với Mã công dân Y của hệ thống chúng ta". Mỗi khi người này thay đổi thông tin ở quê nhà, hệ thống chỉ cần tra sổ này để cập nhật đúng cho "công dân" đó mà không bị nhầm lẫn với người khác2,11.



thiết kế chi tiết bảng tenant\_security\_policies dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống bảo mật dành cho Enterprise SaaS và quy chuẩn kỹ thuật YSQL (YugabyteDB) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenant\_security\_policies**.

Bảng này đóng vai trò quan trọng trong việc cho phép từng khách hàng doanh nghiệp (Tenant) tự định nghĩa các tiêu chuẩn an ninh riêng biệt, đáp ứng các yêu cầu khắt khe về tuân thủ bảo mật như NIST, HIPAA hoặc các chính sách nội bộ của ngân hàng1.

1\. Thiết kế chi tiết bảng `tenant_security_policies`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **tenant\_id** | UUID | NO  |     | `PRIMARY KEY`, `REFERENCES tenants(_id) ON DELETE CASCADE` | ID của tổ chức sở hữu chính sách. Sử dụng làm Khóa chính để đảm bảo mỗi Tenant chỉ có một bộ quy tắc1. |
| **pwd\_min\_length** | INT | NO  | `8` | `CHECK (pwd_min_length >= 6)` | Độ dài tối thiểu của mật khẩu1. |
| **pwd\_require\_special\_char** | BOOLEAN | NO  | `TRUE` |     | Bắt buộc mật khẩu phải chứa ký tự đặc biệt1. |
| **pwd\_expiry\_days** | INT | NO  | `0` | `CHECK (pwd_expiry_days >= 0)` | Số ngày mật khẩu hết hạn (0 là không bao giờ hết hạn)1. |
| **pwd\_history\_limit** | INT | NO  | `3` | `CHECK (pwd_history_limit >= 0)` | Số lượng mật khẩu cũ gần nhất không được phép trùng lặp khi đổi mới12. |
| **session\_timeout\_minutes** | INT | NO  | `1440` | `CHECK (session_timeout_minutes > 0)` | Thời gian hết hạn phiên làm việc (mặc định 24h)1. |
| **max\_login\_attempts** | INT | NO  | `5` | `CHECK (max_login_attempts > 0)` | Số lần đăng nhập sai tối đa trước khi bị khóa tài khoản1. |
| **lockout\_duration\_minutes** | INT | NO  | `30` | `CHECK (lockout_duration_minutes >= 0)` | Thời gian tài khoản bị khóa sau khi thử sai quá số lần quy định1. |
| **mfa\_enforced** | BOOLEAN | NO  | `FALSE` |     | Cờ bắt buộc tất cả thành viên trong Tenant phải bật xác thực 2 yếu tố1. |
| **allowed\_ip\_ranges** | CIDR\[\] | YES | `NULL` |     | Mảng danh sách các dải IP được phép truy cập (IP Whitelist)2. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật chính sách gần nhất (UTC)1. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng các kiểu dữ liệu tối ưu của YugabyteDB như **TIMESTAMPTZ** cho thời gian và **CIDR\[\]** cho mạng, giúp hệ thống kiểm tra quyền truy cập nhanh chóng ngay tại tầng cơ sở dữ liệu23.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_security_policies (
    -- I. ĐỊNH DANH (IDENTITY)
    -- Sử dụng chính tenant_id làm PK để thực thi quan hệ 1-1 và tối ưu sharding theo Tenant
    tenant_id UUID PRIMARY KEY,

    -- II. CHÍNH SÁCH MẬT KHẨU (PASSWORD POLICY)
    pwd_min_length INT NOT NULL DEFAULT 8,
    pwd_require_special_char BOOLEAN NOT NULL DEFAULT TRUE,
    pwd_expiry_days INT NOT NULL DEFAULT 0,
    pwd_history_limit INT NOT NULL DEFAULT 3,

    -- III. CHÍNH SÁCH PHIÊN & ĐĂNG NHẬP (LOGIN & SESSION)
    session_timeout_minutes INT NOT NULL DEFAULT 1440,
    max_login_attempts INT NOT NULL DEFAULT 5,
    lockout_duration_minutes INT NOT NULL DEFAULT 30,

    -- IV. BẢO MẬT NÂNG CAO (ADVANCED SECURITY)
    mfa_enforced BOOLEAN NOT NULL DEFAULT FALSE,
    allowed_ip_ranges CIDR[], -- Lưu mảng dải IP Whitelist

    -- V. TRUY VẾT (AUDIT)
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- VI. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_policy_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_pwd_len CHECK (pwd_min_length >= 6),
    CONSTRAINT chk_pwd_expiry CHECK (pwd_expiry_days >= 0),
    CONSTRAINT chk_login_attempts CHECK (max_login_attempts > 0),
    CONSTRAINT chk_session_timeout CHECK (session_timeout_minutes > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)
-- Do tenant_id là PRIMARY KEY, YugabyteDB đã tự động tạo Index B-tree tối ưu.
-- Thêm index cho cập nhật thời gian nếu cần thực hiện các báo cáo tuân thủ (Compliance Audit)
CREATE INDEX idx_security_policies_updated ON tenant_security_policies (updated_at DESC);
```

Giải thích kỹ thuật bổ sung từ nguồn dữ liệu:

• **UUID v7 và Sharding:** Việc sử dụng UUID cho `tenant_id` (vốn đã được sinh theo chuẩn v7 từ bảng `tenants`) giúp dữ liệu chính sách được phân tán đều trên các máy chủ trong cụm YugabyteDB, tránh hiện tượng "Hotspot" khi nhiều Tenant cùng truy cập cấu hình bảo mật lúc đăng nhập45.

• **Cơ chế Whitelist IP:** Sử dụng kiểu dữ liệu `CIDR[]` cho phép hệ thống kiểm tra nhanh chóng địa chỉ IP của người dùng bằng các toán tử mạng của PostgreSQL/YSQL (như `>>=` hoặc `<<=`), giúp ngăn chặn truy cập trái phép từ các vùng mạng lạ ngay tại cổng vào2.

• **Tính nhất quán mạnh (ACID):** Mọi thay đổi về chính sách mật khẩu hoặc bắt buộc MFA được thực thi với tính nhất quán cao, đảm bảo rằng ngay khi Admin lưu cấu hình, tất cả các node trong hệ thống phân tán đều áp dụng quy tắc mới ngay lập tức cho các lần đăng nhập tiếp theo6.

**Ví dụ trực quan:** Bảng `tenant_security_policies` giống như một **"Bộ nội quy ra vào tòa nhà"** dành riêng cho mỗi văn phòng trong một cao ốc lớn. Thay vì dùng chung một quy định, mỗi công ty có thể tự quyết định khóa cửa sau bao lâu (Session timeout), chìa khóa phải dài bao nhiêu (Password length) và có bắt buộc phải quẹt thẻ vân tay (MFA) hay không.



thiết kế chi tiết bảng legal\_documents dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và tuân thủ pháp lý (Legal Compliance) cho Enterprise SaaS từ các nguồn dữ liệu, bảng **legal\_documents** đóng vai trò lưu trữ các phiên bản văn bản pháp lý như Điều khoản sử dụng (ToS) hoặc Chính sách bảo mật (Privacy Policy)1.

Việc thiết kế bảng này yêu cầu tính nhất quán cao và khả năng truy vết chính xác để chứng minh sự đồng ý của người dùng đối với một phiên bản cụ thể tại một thời điểm nhất định12.

1\. Thiết kế chi tiết bảng `legal_documents`

Bảng sử dụng chuẩn **UUID v7** cho khóa chính để tối ưu hóa việc sắp xếp theo thời gian và hiệu năng ghi phân tán trên YugabyteDB13.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian thực34. |
| **type** | VARCHAR(50) | NO  |     | `CHECK (type IN ('TERMS_OF_SERVICE', 'PRIVACY_POLICY', 'COOKIE_POLICY', 'EULA'))` | Phân loại loại văn bản pháp lý1. |
| **version** | VARCHAR(20) | NO  |     |     | Phiên bản của văn bản (VD: 'v1.0', '2024-JAN')1. |
| **title** | TEXT | NO  |     | `CHECK (LENGTH(title) > 0)` | Tiêu đề hiển thị của văn bản. |
| **content\_url** | TEXT | NO  |     | `CHECK (content_url ~* '^https?://')` | Đường dẫn đến nội dung văn bản trên Object Storage. Dùng **TEXT** thay vì VARCHAR(255) để tránh rủi ro URL dài1.... |
| **is\_active** | BOOLEAN | NO  | `FALSE` |     | Đánh dấu phiên bản hiện hành. Chỉ một phiên bản trên mỗi loại được là TRUE1. |
| **published\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm công bố văn bản chính thức (UTC)17. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi trong hệ thống8. |
| **version\_locking** | BIGINT | NO  | `1` |     | Cơ chế **Optimistic Locking** để tránh xung đột khi cập nhật9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng **Partial Index** và **Unique Constraint** phức hợp để đảm bảo tính toàn vẹn dữ liệu và tốc độ truy vấn cao nhất cho hệ thống SaaS110.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE legal_documents (
    -- I. ĐỊNH DANH & PHIÊN BẢN
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    type VARCHAR(50) NOT NULL,
    version VARCHAR(20) NOT NULL,
    
    -- II. NỘI DUNG
    title TEXT NOT NULL,
    content_url TEXT NOT NULL,
    
    -- III. TRẠNG THÁI & THỜI GIAN
    is_active BOOLEAN NOT NULL DEFAULT FALSE,
    published_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version_locking BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    -- Đảm bảo không trùng lặp phiên bản cho cùng một loại văn bản
    CONSTRAINT uq_doc_type_version UNIQUE (type, version),
    
    -- Kiểm tra loại văn bản hợp lệ
    CONSTRAINT chk_legal_type CHECK (type IN ('TERMS_OF_SERVICE', 'PRIVACY_POLICY', 'COOKIE_POLICY', 'EULA')),
    
    -- Kiểm tra định dạng URL cơ bản
    CONSTRAINT chk_legal_url_fmt CHECK (content_url ~* '^https?://')
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lấy nhanh phiên bản đang hoạt động (Partial Index)
-- Query: SELECT * FROM legal_documents WHERE type = 'TERMS_OF_SERVICE' AND is_active = TRUE;
CREATE UNIQUE INDEX idx_legal_active_version 
ON legal_documents (type) 
WHERE is_active = TRUE;

-- Index hỗ trợ tra cứu lịch sử thay đổi của một loại văn bản theo thời gian
CREATE INDEX idx_legal_history_lookup 
ON legal_documents (type, published_at DESC);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **Tuân thủ Legal & Compliance:** Việc lưu trữ rõ ràng `type` và `version` kết hợp với bảng `user_consents` (sau này) cho phép doanh nghiệp cung cấp bằng chứng kỹ thuật (Audit Trail) rằng người dùng đã đồng ý với phiên bản pháp lý nào tại thời điểm nào12.

• **UUID v7 và Phân tán:** Sử dụng UUID v7 làm khóa chính giúp dữ liệu được sắp xếp tuần tự theo thời gian tạo, giảm thiểu hiện tượng "chẻ trang" (page splitting) và tối ưu hóa việc truy vấn các văn bản mới nhất trong cụm YugabyteDB311.

• **Lưu trữ URL linh hoạt:** Sử dụng kiểu dữ liệu **TEXT** cho `content_url` đảm bảo hệ thống không bị lỗi khi sử dụng các Presigned URL hoặc CDN URL có độ dài vượt quá 255 ký tự thường gặp trong môi trường Cloud512.

• **Tối ưu truy vấn bằng Partial Index:** Chỉ mục `idx_legal_active_version` cực kỳ nhỏ gọn vì nó chỉ chứa các bản ghi đang kích hoạt, giúp ứng dụng xác định nhanh văn bản pháp lý cần hiển thị khi người dùng đăng nhập1013.

**Sự ví von để dễ hiểu:** Bảng `legal_documents` giống như một **thư viện lưu trữ các bộ quy tắc ứng xử** của một tòa nhà. Mỗi khi quy tắc thay đổi, một cuốn sách mới (phiên bản) được xuất bản. Thư viện luôn giữ lại các cuốn sách cũ để đối chiếu, nhưng chỉ duy nhất một cuốn sách được treo ở đại sảnh (is\_active = TRUE) để mọi người cùng tuân thủ tại thời điểm đó.



thiết kế chi tiết bảng user\_consents dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) và yêu cầu tuân thủ pháp lý (Legal Compliance) cho Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_consents** đóng vai trò là bằng chứng kỹ thuật xác nhận việc người dùng đã đồng ý với các điều khoản dịch vụ (TOS) hoặc chính sách bảo mật cụ thể1,2.

Việc sử dụng **UUID v7** giúp tối ưu hóa hiệu năng ghi trong môi trường phân tán của YugabyteDB và đảm bảo các bản ghi được sắp xếp theo thời gian một cách tự nhiên3,2.

1\. Thiết kế chi tiết bảng `user_consents`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian thực3,2. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | ID của người dùng thực hiện đồng ý4. |
| **document\_id** | UUID | NO  |     | `REFERENCES legal_documents(_id)` | Liên kết đến phiên bản văn bản pháp lý cụ thể4. |
| **agreed\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm chính xác người dùng bấm nút đồng ý (UTC)5,4. |
| **ip\_address** | INET | NO  |     |     | Địa chỉ IP của người dùng tại thời điểm đồng ý (Phục vụ truy vết/Audit)6,4. |
| **user\_agent** | TEXT | YES | `NULL` |     | Thông tin trình duyệt/thiết bị của người dùng để tăng tính pháp lý4,7. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để quản lý phiên bản dòng dữ liệu8,9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Thiết kế này sử dụng các ràng buộc để đảm bảo một người dùng không thể có hai bản ghi đồng ý cho cùng một phiên bản văn bản, đồng thời tối ưu hóa việc truy vấn lịch sử chấp thuận2,4.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_consents (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application [3]
    user_id UUID NOT NULL,
    document_id UUID NOT NULL,
    
    -- II. THÔNG TIN XÁC THỰC (EVIDENCE)
    agreed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address INET NOT NULL,
    user_agent TEXT,
    
    -- III. QUẢN TRỊ
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_consent_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT fk_consent_doc FOREIGN KEY (document_id) REFERENCES legal_documents(_id),
    
    -- Đảm bảo mỗi user chỉ đồng ý một lần với một phiên bản tài liệu nhất định [4]
    CONSTRAINT uq_user_document_consent UNIQUE (user_id, document_id),
    
    CONSTRAINT chk_consent_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ kiểm tra nhanh: "Người dùng này đã đồng ý với phiên bản TOS hiện tại chưa?"
-- Query: SELECT 1 FROM user_consents WHERE user_id = ? AND document_id = ?;
CREATE UNIQUE INDEX idx_consent_lookup 
ON user_consents (user_id, document_id);

-- Index hỗ trợ báo cáo tuân thủ và truy vết pháp lý (Audit Trail)
-- Query: SELECT * FROM user_consents WHERE agreed_at BETWEEN ? AND ?;
CREATE INDEX idx_consent_audit_history 
ON user_consents (agreed_at DESC);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **Bằng chứng pháp lý (Audit Trail):** Việc lưu trữ `ip_address` (kiểu INET) và `user_agent` cung cấp một "dấu chân kỹ thuật" vững chắc giúp doanh nghiệp chứng minh sự đồng ý của người dùng trong trường hợp có tranh chấp hoặc thanh tra bảo mật4,7.

• **UUID v7 và Hiệu năng:** Sử dụng UUID v7 cho khóa chính thay vì các loại UUID ngẫu nhiên giúp dữ liệu được chèn vào các node của YugabyteDB một cách tuần tự hơn, giảm thiểu việc phân mảnh chỉ mục và tăng tốc độ ghi3,10.

• **Toàn vẹn dữ liệu:** Ràng buộc `UNIQUE` trên cặp `(user_id, document_id)` ngăn chặn các dữ liệu rác hoặc trùng lặp, đảm bảo tính duy nhất của mỗi lần chấp thuận4.

• **Tối ưu hóa dung lượng:** Sử dụng kiểu dữ liệu `TEXT` cho `user_agent` thay vì `VARCHAR(255)` để linh hoạt lưu trữ các chuỗi thông tin trình duyệt dài mà không làm giảm hiệu năng của YugabyteDB11,12.

**Sự ví von:** Bảng `user_consents` giống như một **quyển sổ ký nhận tại cổng an ninh**. Mỗi khi hệ thống cập nhật "nội quy" mới (Legal Documents), người dùng đi qua cổng phải ký tên vào sổ. Quyển sổ này không chỉ lưu tên (user\_id) mà còn ghi lại cả hình ảnh camera (ip\_address) và thiết bị họ mang theo (user\_agent) để làm bằng chứng xác thực rằng họ đã thực sự đọc và đồng ý với nội quy đó.



thiết kế chi tiết bảng user\_delegations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về quản trị định danh (IAM) và cơ chế ủy quyền dành cho hệ thống Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_delegations** đóng vai trò quan trọng trong việc cho phép một người dùng hành động thay mặt người khác (ví dụ: Thư ký làm việc thay Giám đốc hoặc Nhân viên hỗ trợ xử lý lỗi thay khách hàng) mà không cần chia sẻ mật khẩu12.

Dưới đây là thiết kế chi tiết sử dụng YugabyteDB (YSQL) với định danh **UUID v7** để tối ưu hóa hiệu năng trong môi trường phân tán34.

1\. Thiết kế chi tiết bảng `user_delegations`

Bảng này được thiết kế để đảm bảo tính minh bạch (Audit) và kiểm soát quyền hạn chặt chẽ theo thời gian25.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp theo thời gian và tối ưu sharding34. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Đảm bảo tính cô lập dữ liệu giữa các tổ chức (SaaS Isolation)24. |
| **delegator\_id** | UUID | NO  |     | `REFERENCES users(_id)` | ID của người ủy quyền (người cho đi quyền hạn - ví dụ: Giám đốc)2. |
| **delegatee\_id** | UUID | NO  |     | `REFERENCES users(_id)` | ID của người được ủy quyền (người nhận quyền - ví dụ: Thư ký)2. |
| **scopes** | TEXT\[\] | NO  | `'{}'` |     | Mảng danh sách các quyền được phép thực hiện (VD: `['calendar:read', 'email:send']`)2. |
| **starts\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm việc ủy quyền bắt đầu có hiệu lực26. |
| **expires\_at** | TIMESTAMPTZ | NO  |     | `CHECK (expires_at > starts_at)` | Thời điểm hết hạn ủy quyền (bắt buộc phải có hạn để đảm bảo an ninh)2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kích hoạt, cho phép thu hồi quyền nhanh chóng bằng tay27. |
| **reason** | TEXT | YES | `NULL` |     | Lý do ủy quyền (phục vụ mục đích tra soát/audit)5. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm bản ghi được tạo (UTC)47. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL để tạo bảng và chỉ mục (Indexes)

Thiết kế này sử dụng các ràng buộc (Constraints) để đảm bảo tính toàn vẹn dữ liệu và các chỉ mục (Indexes) giúp tra cứu quyền hạn cực nhanh khi người dùng đăng nhập5.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_delegations (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application [3]
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN ỦY QUYỀN
    delegator_id UUID NOT NULL,
    delegatee_id UUID NOT NULL,
    
    -- III. PHẠM VI & THỜI GIAN
    scopes TEXT[] NOT NULL DEFAULT '{}',
    starts_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    
    -- IV. TRẠNG THÁI & AUDIT
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    reason TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- V. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_delegation_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_delegator FOREIGN KEY (delegator_id) REFERENCES users(_id),
    CONSTRAINT fk_delegatee FOREIGN KEY (delegatee_id) REFERENCES users(_id),
    CONSTRAINT chk_delegation_expiry CHECK (expires_at > starts_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm nhanh các tài khoản mà người dùng hiện tại có thể "nhập vai" (Switch account)
-- Truy vấn: SELECT delegator_id FROM user_delegations WHERE delegatee_id = ? AND is_active = TRUE AND expires_at > NOW();
CREATE INDEX idx_delegation_lookup_delegatee 
ON user_delegations (tenant_id, delegatee_id) 
WHERE is_active = TRUE AND expires_at > NOW();

-- Index hỗ trợ người ủy quyền kiểm tra xem mình đã cấp quyền cho những ai
CREATE INDEX idx_delegation_lookup_delegator 
ON user_delegations (tenant_id, delegator_id);
```

Các điểm nhấn kỹ thuật quan trọng:

• **UUID v7 cho Sharding:** Việc sử dụng UUID v7 làm khóa chính giúp các bản ghi ủy quyền mới (thường phát sinh nhiều trong các đợt rà soát hoặc hỗ trợ kỹ thuật) được phân bổ đều trên cụm YugabyteDB, tránh hiện tượng "hotspot" ghi38.

• **Mô hình "On-behalf-of":** Cơ chế này cho phép hệ thống ghi lại chính xác ai là người thực hiện hành động (`actor_id`) và họ đang thực hiện thay mặt cho ai (`on_behalf_of`), đảm bảo tính minh bạch tuyệt đối trong các báo cáo tra soát (Audit Logs)59.

• **Kiểm soát thời hạn (Security):** Ràng buộc `CHECK` và yêu cầu `expires_at` bắt buộc giúp ngăn chặn tình trạng "quyền hạn vĩnh viễn" bị bỏ quên, một trong những lỗ hổng bảo mật phổ biến trong các hệ thống lớn2.

• **Hiệu năng truy vấn:** Với chỉ mục `idx_delegation_lookup_delegatee`, hệ thống chỉ mất vài mili-giây để xác định danh sách các tài khoản mà một nhân viên hỗ trợ (Support) có thể truy cập khi xử lý ticket510.

**Ví von:** Bảng `user_delegations` giống như một **"giấy ủy quyền có thời hạn"** trong văn phòng. Thay vì cho thư ký mượn chìa khóa gốc (mật khẩu), Giám đốc cấp một tấm thẻ phụ chỉ có quyền mở một số ngăn tủ nhất định (`scopes`) và tấm thẻ này sẽ tự động vô hiệu hóa sau một khoảng thời gian cụ thể (`expires_at`).



bảng tenant\_security\_policies có nên gộp vào trường metadata của bảng tenants không?

Dựa trên các quy chuẩn kiến trúc và phân tích dữ liệu từ các nguồn tài liệu, việc có nên gộp bảng `tenant_security_policies` vào trường metadata (thường được gọi là `profile` hoặc `settings` dưới dạng **JSONB**) của bảng `tenants` hay không phụ thuộc vào sự cân bằng giữa hiệu năng truy vấn và tính chặt chẽ của dữ liệu.

Dưới đây là phân tích chi tiết dựa trên các nguồn dữ liệu để bạn đưa ra quyết định:

1\. Tại sao NÊN GỘP (Sử dụng cột JSONB trong bảng `tenants`)

Theo các nguồn tài liệu, xu hướng thiết kế SaaS hiện đại ưu tiên việc giảm thiểu các phép JOIN không cần thiết trong hệ quản trị cơ sở dữ liệu phân tán như YugabyteDB:

• **Tối ưu hiệu năng (Distributed Join Overhead):** Trong YugabyteDB, dữ liệu của bảng `tenants` và một bảng tách rời `tenant_security_policies` có thể nằm ở hai node vật lý khác nhau1. Việc gộp chung giúp hệ thống lấy được toàn bộ thông tin định danh và chính sách bảo mật chỉ trong **một lần truy vấn duy nhất (Single seek)**, giúp giảm độ trễ (latency) mạng12.

• **Bản chất của dữ liệu cấu hình (Configs vs. Features):** Các chính sách như độ dài mật khẩu, MFA hay session timeout được phân loại là **Configs** (quy định sở thích vận hành - "Làm như thế nào?")3. Nguồn tài liệu khuyên nên lưu các Configs này trong các cột JSONB để đảm bảo tính linh hoạt3....

• **Schema linh hoạt:** Mỗi doanh nghiệp (Tenant) có thể có các yêu cầu bảo mật khác nhau. Sử dụng JSONB cho phép bạn thêm các chính sách mới (ví dụ: yêu cầu sinh trắc học mới phát sinh) mà không cần thực hiện lệnh `ALTER TABLE`, vốn có thể gây khóa bảng trong các hệ thống SQL truyền thống26.

• **Mối quan hệ 1-1:** Nguồn tài liệu khẳng định **KHÔNG NÊN tách bảng 1-1** trừ khi có lý do đặc biệt về bảo mật, vì việc tách bảng này thường mang lại nhiều tác hại về hiệu năng và làm phức tạp hóa mã nguồn (phải bọc trong Transaction để đảm bảo ghi cả 2 bảng thành công)78.

2\. Tại sao KHÔNG NÊN GỘP (Giữ bảng riêng)

Mặc dù việc gộp mang lại hiệu năng, nhưng có những trường hợp việc tách bảng lại cần thiết:

• **Ràng buộc dữ liệu cứng (Strict Constraints):** Nếu bạn cần các logic kiểm tra (CHECK constraints) cực kỳ phức tạp và khắt khe ngay tại tầng Database (ví dụ: dải IP phải tuân thủ định dạng CIDR nghiêm ngặt hoặc các quy tắc số học phức tạp), việc dùng cột riêng trong bảng tách biệt sẽ dễ quản lý hơn so với việc kiểm tra bên trong một đối tượng JSONB910.

• **Tính bảo mật và phân quyền:** Nếu bạn muốn áp dụng các chính sách bảo mật khác nhau cho việc truy cập thông tin định danh (tên, logo) và thông tin chính sách bảo mật (MFA, IP Whitelist) ở mức database, việc tách bảng sẽ giúp phân quyền dễ dàng hơn.

• **Kích thước bản ghi:** Mặc dù YugabyteDB/Postgres có cơ chế TOAST để xử lý các bản ghi lớn, nhưng nếu bảng `tenants` chứa quá nhiều thông tin metadata quá tải, nó có thể làm chậm các truy vấn quét toàn bảng (Full table scan) nếu không được đánh index cẩn thận8.

3\. Giải pháp khuyến nghị từ nguồn dữ liệu

Dựa trên nguyên tắc **"Sự chính xác và minh bạch ưu tiên hơn dung lượng lưu trữ"**11, giải pháp tối ưu nhất cho hệ thống SaaS Enterprise là:

1\. **Gộp các chính sách bảo mật vào một cột đặt tên là** **settings** **hoặc** **security\_configs** **kiểu JSONB ngay trong bảng** **tenants**5....

2\. **Cấu trúc mẫu trong cột JSONB:**

3\. **Đánh Index GIN:** Nếu bạn thường xuyên cần lọc các Tenant dựa trên một chính sách nào đó (ví dụ: tìm các Tenant bắt buộc MFA), hãy tạo **GIN Index** cho cột JSONB này để đảm bảo tốc độ truy vấn14.

**Kết luận:** Bạn **nên gộp** các chính sách bảo mật vào bảng `tenants` dưới dạng một cột **JSONB**. Điều này giúp hệ thống của bạn "Bắt đầu chặt chẽ, mở rộng linh hoạt" đúng như lời khuyên từ nguồn tài liệu15, đồng thời tối ưu hóa được sức mạnh của cơ sở dữ liệu phân tán YugabyteDB bằng cách giảm thiểu các phép Join liên node116.

**Ví dụ trực quan:** Việc gộp này giống như việc bạn dán **tờ hướng dẫn sử dụng** trực tiếp lên **vỏ hộp thiết bị**. Thay vì phải đi tìm cuốn sách hướng dẫn ở một ngăn tủ khác (bảng riêng), người dùng (ứng dụng) chỉ cần nhìn vào hộp (bảng tenants) là biết ngay cách vận hành an toàn.



thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân chuẩn thiết kế hệ thống SaaS "World-class" và kiến trúc phân tán của YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants**. Đây là bảng quan trọng nhất, đóng vai trò là "trái tim" của hệ thống, nơi lưu trữ thông tin định danh, cấu hình hạ tầng và trạng thái thực thể của từng khách hàng doanh nghiệp1,2.

Việc sử dụng **UUID v7** làm khóa chính là một lựa chọn chiến lược, giúp dữ liệu được phân tán đều trên các node (Sharding) mà vẫn giữ được tính tuần tự theo thời gian, tối ưu hóa hiệu suất ghi và truy vấn so với các loại UUID ngẫu nhiên truyền thống3,4.

1\. Thiết kế chi tiết bảng `tenants`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất toàn cục chuẩn **UUID v7** giúp tối ưu sharding và sắp xếp theo thời gian3,4. |
| **data\_region** | VARCHAR(50) | NO  | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | Quy định vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning) để tuân thủ pháp lý (GDPR/Luật ANM)5,6. |
| **code** | VARCHAR(64) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số và gạch ngang7,8. |
| **compliance\_level** | VARCHAR(20) | NO  | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định logic xử lý dữ liệu nhạy cảm9,6. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty/tổ chức7,10. |
| **parent\_tenant\_id** | UUID | YES | `NULL` | `REFERENCES tenants(_id)` | Hỗ trợ mô hình tập đoàn (Holding - Subsidiaries)11,12. |
| **profile** | JSONB | NO  | `'{}'` |     | Chứa thông tin bổ sung (Logo, Website, Tax info...). Giúp schema linh hoạt mà không cần JOIN bảng13,14. |
| **status** | VARCHAR(20) | NO  | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))` | Trạng thái vòng đời của khách hàng trên hệ thống15,6. |
| **active\_apps** | TEXT\[\] | YES | `'{}'` |     | Cache danh sách mã ứng dụng mà tenant được quyền sử dụng để check quyền nhanh16,17. |
| **owner\_id** | UUID | YES | `NULL` | `REFERENCES users(_id)` | ID của người dùng đóng vai trò chủ sở hữu (Super Admin)16,18. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)19,20. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng21,22. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | Cờ xóa mềm (Soft Delete) phục vụ việc khôi phục dữ liệu21,23. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho cơ chế **Optimistic Locking** chống ghi đè dữ liệu đồng thời24,25. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh này được thiết kế để tận dụng tối đa sức mạnh của **Distributed SQL** trong YugabyteDB, đảm bảo tính nhất quán mạnh (ACID) và khả năng mở rộng ngang26,27.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenants (
    -- I. ĐỊNH DANH & HẠ TẦNG (IDENTITY & INFRASTRUCTURE)
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application layer
    data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
    code VARCHAR(64) NOT NULL,
    compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',

    -- II. THÔNG TIN CƠ BẢN & MỞ RỘNG
    name TEXT NOT NULL,
    parent_tenant_id UUID,
    profile JSONB NOT NULL DEFAULT '{}',

    -- III. TRẠNG THÁI & QUYỀN HẠN
    status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
    active_apps TEXT[] DEFAULT '{}',
    owner_id UUID,

    -- IV. TRUY VẾT & PHIÊN BẢN (AUDIT & VERSIONING)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_tenants_code UNIQUE (code),
    CONSTRAINT fk_tenants_parent FOREIGN KEY (parent_tenant_id) REFERENCES tenants(_id),
    CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED')),
    CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
    CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
    CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_tenants_name_len CHECK (LENGTH(name) > 0),
    CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at),
    CONSTRAINT chk_tenants_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm Tenant theo domain/slug cực nhanh (Login/Routing)
CREATE UNIQUE INDEX idx_tenants_code_active 
ON tenants (code) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ tìm tất cả các Tenant do một User quản lý
CREATE INDEX idx_tenants_owner 
ON tenants (owner_id) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ quản trị hệ thống lọc khách hàng theo vùng và trạng thái
CREATE INDEX idx_tenants_region_status 
ON tenants (data_region, status);

-- Index GIN hỗ trợ tìm nhanh các Tenant đang sử dụng một ứng dụng cụ thể
-- Giúp query: WHERE 'HRM' = ANY(active_apps)
CREATE INDEX idx_tenants_active_apps 
ON tenants USING GIN (active_apps);
```

Các điểm nhấn kỹ thuật quan trọng từ nguồn dữ liệu:

• **Kiểu dữ liệu TEXT thay vì VARCHAR(255):** Đối với các trường như `name` và `profile`, YugabyteDB xử lý `TEXT` hiệu quả tương đương `VARCHAR` nhưng linh hoạt hơn, không lo bị tràn dữ liệu khi tên doanh nghiệp hoặc URL logo quá dài28,7.

• **Tính nhất quán trong Geo-Partitioning:** Cột `data_region` kết hợp với `_id` có thể được cấu hình làm **Partition Key** để đảm bảo dữ liệu của khách hàng Châu Âu nằm đúng ở server tại Châu Âu, đáp ứng các tiêu chuẩn khắt khe về chủ quyền dữ liệu29,30.

• **Cơ chế Xóa mềm (Soft Delete):** Việc sử dụng `deleted_at` thay vì lệnh `DELETE` vật lý cho phép hệ thống khôi phục dữ liệu khi khách hàng lỡ tay xóa hoặc khi cần tra soát pháp lý sau khi chấm dứt hợp đồng21,23.

• **Sử dụng JSONB cho Profile:** Theo triết lý thiết kế SaaS hiện đại, các thông tin "mềm" như logo, mạng xã hội nên được gom vào JSONB để tối ưu hiệu năng đọc (Single Seek) và tránh việc phải thay đổi cấu trúc bảng liên tục khi thêm các trường phụ31,13.

**Sự ví von:** Bảng `tenants` giống như **cuốn sổ hộ khẩu gốc** của một tòa nhà văn phòng thông minh. Nó không chỉ ghi tên công ty thuê phòng, mà còn chứa thông tin về các tiêu chuẩn an ninh riêng biệt của họ (`compliance_level`), họ được phép ra vào những tầng nào (`active_apps`), và quan trọng nhất là "vị trí ngăn kéo" chứa hồ sơ chi tiết của họ (`data_region`).



sao không có trường settings?

Trường **settings** thực chất là một thành phần cốt lõi trong thiết kế bảng `tenants` dành cho Enterprise SaaS, nhưng tùy vào giai đoạn thiết kế và triết lý phân tách dữ liệu mà nó có thể xuất hiện dưới các tên gọi khác nhau hoặc được tách ra để tối ưu hiệu năng.

Dưới đây là lý do chi tiết và cách đưa trường này vào bảng theo đúng các nguồn dữ liệu:

1\. Sự phân tách giữa `profile` và `settings`

Trong các thiết kế chuẩn Enterprise (End-game), các nguồn dữ liệu khuyến nghị tách biệt hai loại thông tin này để quản lý rõ ràng1,2:

• **profile** **(JSONB):** Chứa các thông tin về bộ nhận diện và thông tin công khai như Logo, Website, Mô tả công ty, Mạng xã hội3,4.

• **settings** **(JSONB):** Chứa các cấu hình vận hành và logic hệ thống như: Vùng dữ liệu (Region), Mức độ tuân thủ (Compliance level), Múi giờ (Timezone), và các chính sách bảo mật mà chúng ta đã thảo luận1,2.

2\. Tại sao thiết kế trước đó có thể "thiếu" hoặc gộp?

• **Triết lý "Gộp để tối ưu":** Một số nguồn tài liệu khuyên nên gộp tất cả metadata (bao gồm cả settings) vào một cột JSONB duy nhất (thường gọi là `profile` hoặc `metadata`) để giảm thiểu số lượng cột và giúp schema linh hoạt hơn, tránh việc phải `ALTER TABLE` thường xuyên5,6.

• **Phân loại Configs vs. Features:** Theo nguồn dữ liệu, các cấu hình mang tính chất "Sở thích vận hành" (như màu sắc giao diện, quy trình workflow) thường được tách ra lưu tại **MongoDB** trong bảng `tenant_app_configs` để tận dụng tính linh hoạt tuyệt đối của NoSQL7,8.

3\. Thiết kế bảng `tenants` hoàn thiện (Bao gồm cả `settings`)

Để đáp ứng yêu cầu về sự minh bạch và chính xác cao nhất cho hệ thống Enterprise, dưới đây là bảng `tenants` đã được cập nhật đầy đủ cả trường `profile` và `settings`1,2,9:

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh UUID v710,11. |
| **code** | VARCHAR(64) | NO  |     | `UNIQUE`, `CHECK` regex | Mã định danh/Subdomain11,12. |
| **name** | TEXT | NO  |     |     | Tên hiển thị công ty11,13. |
| **profile** | JSONB | NO  | `'{}'` |     | Thông tin thương hiệu (Logo, Website, Socials)3,2. |
| **settings** | JSONB | NO  | `'{}'` |     | **Cấu hình vận hành (Region, Compliance, Security policies)**1**,**2**.** |
| **status** | VARCHAR(20) | NO  | `'TRIAL'` | `CHECK` enum | Trạng thái: TRIAL, ACTIVE, SUSPENDED...14,15. |
| **active\_apps** | TEXT\[\] | YES | `'{}'` |     | Cache danh sách ứng dụng được phép dùng16,17. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Chống ghi đè đồng thời (Optimistic Locking)18,19. |

\--------------------------------------------------------------------------------

4\. Câu lệnh YSQL cập nhật

```
CREATE TABLE tenants (
    _id UUID PRIMARY KEY,
    code VARCHAR(64) NOT NULL,
    name TEXT NOT NULL,
    
    -- Phân tách rõ ràng Profile và Settings
    profile JSONB NOT NULL DEFAULT '{}', -- Thông tin thương hiệu
    settings JSONB NOT NULL DEFAULT '{}', -- Cấu hình logic & bảo mật
    
    status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
    active_apps TEXT[] DEFAULT '{}',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    CONSTRAINT uq_tenants_code UNIQUE (code),
    CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED', 'ARCHIVED'))
);

-- Index hỗ trợ tìm kiếm nhanh trong Settings (ví dụ: tìm theo vùng dữ liệu)
CREATE INDEX idx_tenants_settings ON tenants USING GIN (settings);
```

**Tóm lại:** Trường **settings** cực kỳ quan trọng để lưu trữ các tham số điều khiển logic mà không muốn JOIN bảng nhiều lần20,21. Nếu bạn muốn hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt", việc tách riêng `settings` ra khỏi `profile` sẽ giúp các lập trình viên Backend và Frontend dễ dàng phân biệt đâu là dữ liệu hiển thị (UI) và đâu là dữ liệu điều khiển (Logic)22,1.



thiết kế chi tiết bảng tenants dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả cần có đầy đủ các trường profile, settings, deleted\_at, data\_region, compliance\_level, tier, billing\_type, timezone, mô tả chi tiết trường profile, settings viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS "World-class" và kiến trúc cơ sở dữ liệu phân tán YugabyteDB (YSQL) từ các nguồn dữ liệu, dưới đây là thiết kế chi tiết cho bảng **tenants**. Đây là bảng hạt nhân lưu trữ định danh, trạng thái và các cấu hình cốt lõi của khách hàng doanh nghiệp12.

Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa hiệu năng ghi bằng cách duy trì tính tuần tự theo thời gian, tránh hiện tượng "hotspot" trong môi trường phân tán và hỗ trợ sắp xếp dữ liệu tự nhiên3....

1\. Thiết kế chi tiết bảng `tenants` (YSQL)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**56. |
| **code** | VARCHAR(64) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã định danh (Slug/Subdomain). Chỉ chứa chữ thường, số, gạch ngang78. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên hiển thị chính thức của công ty910. |
| **data\_region** | VARCHAR(50) | NO  | `'ap-southeast-1'` | `CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1'))` | Vị trí vật lý lưu trữ dữ liệu (Geo-Partitioning) để tuân thủ pháp lý1112. |
| **compliance\_level** | VARCHAR(20) | NO  | `'STANDARD'` | `CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS'))` | Mức độ tuân thủ bảo mật, quyết định quy trình xử lý dữ liệu1213. |
| **tier** | VARCHAR(50) | NO  | `'FREE'` |     | Cấp độ gói dịch vụ (VD: FREE, PRO, ENTERPRISE)1415. |
| **billing\_type** | VARCHAR(20) | NO  | `'POSTPAID'` | `CHECK (billing_type IN ('PREPAID', 'POSTPAID'))` | Hình thức thanh toán: Trả trước hoặc trả sau1617. |
| **timezone** | VARCHAR(50) | NO  | `'UTC'` |     | Múi giờ hành chính để tính toán thời hạn gói và báo cáo1418. |
| **profile** | JSONB | NO  | `'{}'` |     | Thông tin thương hiệu và bộ nhận diện (Metadata hiển thị)1519. |
| **settings** | JSONB | NO  | `'{}'` |     | Cấu hình vận hành và chính sách bảo mật (Metadata logic)1920. |
| **status** | VARCHAR(20) | NO  | `'TRIAL'` | `CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED'))` | Trạng thái vòng đời của tenant1821. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)2223. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | `CHECK (updated_at >= created_at)` | Thời điểm cập nhật cuối cùng2324. |
| **deleted\_at** | TIMESTAMPTZ | YES | `NULL` |     | Cờ xóa mềm (Soft Delete) phục vụ truy vết và khôi phục24.... |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè dữ liệu đồng thời2627. |

\--------------------------------------------------------------------------------

2\. Mô tả chi tiết trường `profile` và `settings`

Việc sử dụng **JSONB** cho hai trường này giúp hệ thống linh hoạt (Schema-less), cho phép thêm thông tin mới mà không cần thực hiện `ALTER TABLE` gây khóa bảng2829.

• **profile** **(Metadata hiển thị):** Chứa các thông tin dùng để cá nhân hóa giao diện và thông tin liên hệ1519.

    ◦ _Ví dụ cấu trúc:_ `logo_url`, `website_url`, `description`, `social_links` (Facebook, LinkedIn), `tax_info` (Mã số thuế, địa chỉ pháp lý)2029.    ◦ _Mục đích:_ Phục vụ hiển thị trên UI/UX và các thông tin phi nghiệp vụ30.

• **settings** **(Metadata vận hành):** Chứa các cấu hình điều khiển logic hệ thống và các chính sách bảo mật riêng biệt cho từng Tenant1931.

    ◦ _Ví dụ cấu trúc:_ `password_policy` (độ dài tối thiểu, ký tự đặc biệt), `mfa_enforced` (bắt buộc 2FA), `session_timeout`, `ip_whitelist` (dải IP được phép truy cập), `feature_flags` riêng cho tenant20....    ◦ _Mục đích:_ Điều hướng hành vi của ứng dụng mà không cần JOIN nhiều bảng cấu hình rời rạc29.

\--------------------------------------------------------------------------------

3\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenants (
    -- I. ĐỊNH DANH & HẠ TẦNG
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ tầng Application
    code VARCHAR(64) NOT NULL,
    data_region VARCHAR(50) NOT NULL DEFAULT 'ap-southeast-1',
    compliance_level VARCHAR(20) NOT NULL DEFAULT 'STANDARD',

    -- II. THÔNG TIN NGHIỆP VỤ & ĐỊA PHƯƠNG HÓA
    name TEXT NOT NULL,
    tier VARCHAR(50) NOT NULL DEFAULT 'FREE',
    billing_type VARCHAR(20) NOT NULL DEFAULT 'POSTPAID',
    timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',

    -- III. DỮ LIỆU ĐỘNG (JSONB)
    profile JSONB NOT NULL DEFAULT '{}',
    settings JSONB NOT NULL DEFAULT '{}',

    -- IV. TRẠNG THÁI & TRUY VẾT
    status VARCHAR(20) NOT NULL DEFAULT 'TRIAL',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_tenants_code UNIQUE (code),
    CONSTRAINT chk_tenants_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_tenants_status CHECK (status IN ('TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED')),
    CONSTRAINT chk_tenants_region CHECK (data_region IN ('ap-southeast-1', 'us-east-1', 'eu-central-1')),
    CONSTRAINT chk_tenants_compliance CHECK (compliance_level IN ('STANDARD', 'GDPR', 'HIPAA', 'PCI-DSS')),
    CONSTRAINT chk_tenants_billing CHECK (billing_type IN ('PREPAID', 'POSTPAID')),
    CONSTRAINT chk_tenants_updated CHECK (updated_at >= created_at),
    CONSTRAINT chk_tenants_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ xác thực và điều hướng (Login/Routing) theo subdomain/slug
CREATE UNIQUE INDEX idx_tenants_code_active 
ON tenants (code) 
WHERE deleted_at IS NULL;

-- Index GIN hỗ trợ tìm kiếm linh hoạt bên trong cấu hình Settings (Ví dụ: tìm tenant bắt buộc MFA)
CREATE INDEX idx_tenants_settings_gin 
ON tenants USING GIN (settings);

-- Index GIN hỗ trợ tìm kiếm trong Profile (Ví dụ: tìm theo Mã số thuế trong JSON)
CREATE INDEX idx_tenants_profile_gin 
ON tenants USING GIN (profile);

-- Index hỗ trợ báo cáo quản trị hệ thống theo khu vực và gói cước
CREATE INDEX idx_tenants_infra_stats 
ON tenants (data_region, tier, status);
```

**Sự ví von:** Bảng `tenants` giống như **"Hồ sơ gốc của một tòa nhà văn phòng"**. Khóa chính UUID v7 là mã số căn hộ được sắp xếp theo thời gian xây dựng. Trường `profile` là bảng tên và logo công ty treo ở sảnh, trong khi `settings` là bộ nội quy riêng (như giờ đóng cửa, yêu cầu thẻ từ) mà mỗi văn phòng có thể tự thiết lập để phù hợp với đặc thù an ninh của họ31.



liệt kê chi tiết các thuộc tính của trường profile

Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn thiết kế cơ sở dữ liệu YugabyteDB trong các nguồn tài liệu, trường **profile** trong bảng `tenants` được thiết kế dưới dạng kiểu dữ liệu **JSONB** để lưu trữ các thông tin mang tính chất "Metadata hiển thị" (UI Metadata)1,2.

Dưới đây là danh sách chi tiết các thuộc tính thường được chứa trong trường `profile`:

1\. Thông tin thương hiệu và nhận diện (Branding)

Đây là nhóm thông tin chính dùng để cá nhân hóa giao diện người dùng (UI/UX) cho từng khách hàng doanh nghiệp:

• **description**: Mô tả ngắn gọn về hoạt động kinh doanh hoặc giới thiệu về công ty3,4. Thông tin này thường hiển thị trên trang hồ sơ công khai hoặc trang quản trị nội bộ5.

• **logo\_url**: Đường dẫn đến tệp ảnh logo của công ty3,4. Do các URL này có thể rất dài (đặc biệt khi sử dụng Presigned URL từ S3 hoặc các dịch vụ CDN), việc lưu trong JSONB giúp linh hoạt hơn so với các cột VARCHAR giới hạn6,7.

• **website\_url** (hoặc **website**): Địa chỉ trang chủ chính thức của doanh nghiệp3,4.

2\. Thông tin pháp lý và thuế (Tax & Legal)

Nhóm này lưu trữ các dữ liệu cần thiết cho việc xuất hóa đơn hoặc xác minh danh tính doanh nghiệp mà không cần tạo quá nhiều cột rời rạc:

• **tax\_info**: Một đối tượng lồng nhau (nested object) bao gồm:

    ◦ **tax\_code**: Mã số thuế của doanh nghiệp3,4.    ◦ **address**: Địa chỉ pháp lý đăng ký trên giấy phép kinh doanh (khác với địa chỉ văn phòng thực tế có thể thay đổi)3,4.

3\. Liên kết mạng xã hội (Social Links)

Trường `profile` cho phép lưu trữ không giới hạn các liên kết mạng xã hội tùy theo nhu cầu của từng Tenant3:

• **socials** (hoặc **social\_links**): Một đối tượng chứa các khóa như:

    ◦ `facebook`: Link trang Fanpage.    ◦ `linkedin`: Link hồ sơ doanh nghiệp trên LinkedIn.    ◦ `twitter`, `tiktok`, hoặc các nền tảng khác phát sinh sau này3,4.

4\. Các thuộc tính tùy biến khác

Vì tính chất schema-less của JSONB, trường `profile` có thể mở rộng thêm các thuộc tính mà không cần sửa đổi cấu trúc bảng (ALTER TABLE)3,2:

• **industry**: Ngành nghề kinh doanh cụ thể.

• **founded\_year**: Năm thành lập.

• **contact\_person**: Thông tin người liên hệ bổ sung (nếu không nằm trong các bảng chuyên biệt).

Tại sao các thuộc tính này được gom vào `profile`?

• **Tối ưu hiệu năng:** Việc gom các thông tin hiển thị vào một cột JSONB giúp ứng dụng lấy được toàn bộ dữ liệu cần thiết cho trang Profile chỉ trong một lần truy vấn duy nhất (**Single Seek**), tránh việc phải thực hiện các phép JOIN phức tạp trong môi trường cơ sở dữ liệu phân tán8,3.

• **Sự linh hoạt:** Khách hàng doanh nghiệp A có thể cần lưu link TikTok, nhưng khách hàng B thì không. JSONB cho phép cấu trúc dữ liệu khác nhau giữa các Tenant mà vẫn đảm bảo tính nhất quán của bảng chính3.

• **Phân tách mối quan tâm:** Nguồn tài liệu nhấn mạnh việc tách biệt giữa **profile** (thông tin hiển thị, ít thay đổi) và **settings** (thông tin cấu hình logic, chính sách bảo mật) để quản lý hệ thống chuyên nghiệp và an toàn hơn9,4.

\--------------------------------------------------------------------------------

**Ví dụ về cấu trúc dữ liệu hoàn chỉnh của trường** **profile****:**

````
{
  "description": "Tập đoàn công nghệ đa quốc gia",
  "website_url": "https://fpt.com.vn",
  "logo_url": "https://s3.region.amazonaws.com/tenant-logos/fpt-logo.png",
  "tax_info": {
    "tax_code": "0101234567",
    "address": "Số 1 Duy Tân, Cầu Giấy, Hà Nội"
  },
  "socials": {
    "facebook": "fb.com/fpt",
    "linkedin": "linkedin.com/company/fpt"
  }
}
``` [4]
````


liệt kê chi tiết các thuộc tính của trường settings

Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn thiết kế cơ sở dữ liệu phân tán YugabyteDB từ các nguồn dữ liệu, trường **settings** trong bảng `tenants` được thiết kế dưới dạng kiểu dữ liệu **JSONB**1. Trường này đóng vai trò là "Metadata vận hành", chứa các cấu hình điều hướng hành vi của ứng dụng và các chính sách bảo mật riêng biệt cho từng tổ chức23.

Dưới đây là chi tiết các thuộc tính cốt lõi nằm trong trường **settings**:

1\. Chính sách bảo mật (Security Policies)

Đây là nhóm thuộc tính quan trọng nhất, giúp thực thi các tiêu chuẩn an ninh khắt khe của doanh nghiệp4.

• **password\_policy**: Đối tượng cấu hình mật khẩu, bao gồm:

    ◦ `min_length`: Độ dài tối thiểu của mật khẩu (thường >= 8)4.    ◦ `require_special_char`: Bắt buộc mật khẩu có ký tự đặc biệt4.    ◦ `expiry_days`: Số ngày mật khẩu hết hạn (0 là không bao giờ)4.    ◦ `history_limit`: Số lượng mật khẩu cũ không được phép trùng lại4.

• **mfa\_enforced**: Cờ BOOLEAN bắt buộc tất cả người dùng thuộc Tenant này phải bật xác thực 2 yếu tố (MFA)4.

• **ip\_whitelist** (hoặc `allowed_ip_ranges`): Mảng chứa các dải địa chỉ IP (CIDR) được phép truy cập vào hệ thống45.

• **session\_policy**: Cấu hình phiên làm việc:

    ◦ `timeout_minutes`: Thời gian tự động đăng xuất khi không hoạt động4.    ◦ `max_login_attempts`: Số lần thử sai tối đa trước khi khóa tài khoản4.

2\. Cấu hình vận hành và Hạ tầng (Operational & Infrastructure)

Nhóm này quy định cách hệ thống xử lý dữ liệu và định tuyến cho Tenant36.

• **compliance**: Mức độ tuân thủ bảo mật (ví dụ: `GDPR`, `HIPAA`, `PCI-DSS`), quyết định quy trình xóa vĩnh viễn hoặc lưu vết dữ liệu67.

• **data\_residency**: Quy định vùng địa lý lưu trữ dữ liệu để đảm bảo tuân thủ luật pháp quốc gia (ví dụ: `ap-southeast-1`)89.

• **rate\_limiting**: Hạn ngạch gọi API cho từng Tenant để chống DDoS nội bộ và quá tải hệ thống1011.

    ◦ `requests_per_minute`: Số lượng request tối đa trong một phút11.    ◦ `burst_size`: Số lượng request tối đa cho phép bùng phát trong thời gian ngắn11.

3\. Chính sách lưu trữ và Phê duyệt (Governance)

Dành cho các yêu cầu quản trị chuyên sâu của khách hàng Enterprise1213.

• **archival\_policy**: Quy định thời gian dữ liệu được giữ lại trong DB trước khi đẩy vào kho lưu trữ lạnh (S3)12.

    ◦ `audit_log_retention_days`: Số ngày lưu giữ nhật ký truy vết12.    ◦ `invoice_retention_days`: Số ngày lưu giữ hóa đơn trong hệ thống12.

• **approval\_required**: Cờ bắt buộc các hành động nhạy cảm (như xóa dữ liệu, xuất file) phải qua quy trình phê duyệt (Maker-Checker)13.

Ví dụ cấu trúc mẫu của trường `settings`:

```
{
  "security": {
    "password_policy": {
      "min_length": 12,
      "require_special_char": true,
      "expiry_days": 90
    },
    "mfa_enforced": true,
    "ip_whitelist": ["1.2.3.4/32", "118.0.0.0/24"],
    "session_timeout": 1440
  },
  "operational": {
    "compliance_level": "GDPR",
    "rate_limit": {
      "rpm": 1000,
      "burst": 50
    }
  },
  "archival": {
    "audit_log_days": 90
  }
}
```

Việc gom tất cả các tham số điều khiển này vào một cột **JSONB** duy nhất giúp hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt"14. Điều này cho phép ứng dụng lấy toàn bộ cấu hình chỉ trong **một lần truy vấn duy nhất (Single Seek)**, tối ưu hóa hiệu năng đáng kể trên môi trường YugabyteDB phân tán bằng cách giảm thiểu các phép JOIN phức tạp1516.



liệt kê các bảng của phần Access & Security

Dựa trên các nguồn tài liệu và lịch sử thiết kế hệ thống SaaS Enterprise, phân hệ **Access & Security** (truy cập và bảo mật) được chia thành các nhóm bảng chức năng để quản lý từ định danh cốt lõi, xác thực đa yếu tố đến phân quyền chuyên sâu1,2,3.

Dưới đây là danh sách chi tiết các bảng thuộc phần này:

1\. Nhóm Xác thực & Định danh (Authentication & Identity)

Nhóm này quản lý "Căn cước công dân" số của người dùng trên toàn hệ thống và các phương thức để họ chứng minh danh tính4,5.

• **users**: Lưu trữ thông tin định danh toàn cục của một con người thực (Email, Password Hash, Avatar)6,7,4.

• **user\_linked\_identities**: Quản lý việc liên kết tài khoản với các nguồn khác nhau như Google, GitHub hoặc mật khẩu truyền thống8,9,4.

• **user\_profiles**: Lưu trữ thông tin "mềm" và các cấu hình hiển thị cá nhân (Bio, mạng xã hội, giao diện) để giữ bảng `users` nhẹ và tối ưu10,11,4.

• **tenant\_sso\_configs**: Cấu hình đăng nhập doanh nghiệp qua các chuẩn SAML/OIDC (như Azure AD, Okta) dành cho khách hàng Enterprise12,13,14,4.

2\. Nhóm Quản lý Truy cập (Access Management)

Nhóm này quản lý cách thức máy móc hoặc con người duy trì phiên làm việc và tích hợp hệ thống15,16.

• **api\_keys**: Cung cấp mã truy cập dành cho các tích hợp máy-với-máy (Machine-to-Machine)17,18,19.

• **personal\_access\_tokens** **(PATs)**: Mã truy cập dành cho lập trình viên hoặc các script tự động hóa mà không cần qua giao diện20,21,4.

• **service\_accounts**: Tài khoản dành riêng cho các dịch vụ tự động (Bot, CI/CD), được quản lý quyền hạn tương tự như một thành viên22,23.

• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động, thông tin thiết bị, địa chỉ IP và vị trí địa lý để kiểm soát an ninh thiết bị24,25,15.

• **user\_devices**: Lưu vết các thiết bị tin cậy đã được xác minh để phát hiện các đăng nhập lạ26,27,3.

3\. Nhóm Bảo mật Nâng cao (Advanced Security & MFA)

Các bảng này thực thi các lớp phòng thủ bổ sung như xác thực 2 lớp và cơ chế đăng nhập không mật khẩu28.

• **user\_mfa\_methods**: Lưu trữ các phương thức xác thực bước 2 (TOTP, SMS, Email) của người dùng29,30,28.

• **user\_backup\_codes**: Các mã khôi phục dự phòng khi người dùng mất thiết bị xác thực MFA31,28.

• **user\_webauthn\_credentials**: Quản lý thông tin đăng nhập bằng vân tay, FaceID hoặc khóa vật lý (Passkeys/FIDO2)32,33,28.

• **auth\_verification\_codes**: Các mã OTP ngắn hạn hoặc Magic Links phục vụ việc quên mật khẩu hoặc xác thực email33,34,28.

• **auth\_logs**: Nhật ký chi tiết các lần đăng nhập thành công hoặc thất bại để phát hiện tấn công Brute-force35,4,3.

4\. Nhóm Phân quyền (Authorization - IAM)

Nhóm này quyết định một người dùng sau khi đăng nhập thành công sẽ được phép thực hiện những hành động gì trên tài nguyên nào25,16.

• **permissions**: Danh mục các mã quyền hệ thống do lập trình viên định nghĩa cứng (ví dụ: `invoice:create`)36,25,23.

• **roles**: Định nghĩa các vai trò (như Admin, Manager, Viewer) chứa mảng các mã quyền tương ứng36,25,23.

• **user\_roles** **(hoặc** **member\_roles****)**: Gán vai trò cho thành viên, hỗ trợ phân vùng dữ liệu (Data Scoping)37,38,25,15.

• **user\_groups**: Nhóm người dùng để gán quyền hàng loạt hoặc quản lý theo dự án/phòng ban39,40,15.

• **access\_control\_lists** **(ACL)**: Phân quyền chi tiết trên từng tài nguyên cụ thể (ví dụ: chia sẻ thư mục X cho người B)41,23,15.

• **relationship\_tuples**: Mô hình phân quyền dựa trên mối quan hệ (ReBAC) giúp xử lý các cấu hình chia sẻ dữ liệu phức tạp kiểu Google Drive42,43,16.

• **user\_delegations**: Quản lý việc ủy quyền cho phép một người hành động thay mặt người khác trong thời gian ngắn44,16.

5\. Nhóm Chính sách & Tuân thủ (Policies & Compliance)

Các bảng quản lý các quy tắc an ninh chung của tổ chức và các yêu cầu pháp lý3.

• **tenant\_security\_policies**: Quy định về độ dài mật khẩu, thời gian hết hạn phiên, IP Whitelist và bắt buộc MFA cho toàn tổ chức45,25,3.

• **tenant\_domains**: Xác thực tên miền sở hữu của doanh nghiệp để ngăn chặn Shadow IT và bắt buộc SSO46,47,48.

• **legal\_documents**: Lưu trữ các phiên bản Điều khoản sử dụng và Chính sách bảo mật49,3.

• **user\_consents**: Lưu vết bằng chứng kỹ thuật về việc người dùng đã đồng ý với phiên bản pháp lý nào tại thời điểm nào50,51,3.

• **security\_audit\_logs**: Nhật ký các hành động nhạy cảm liên quan đến cấu hình hệ thống và an ninh52,3.

Việc tách biệt các bảng này giúp hệ thống SaaS đảm bảo tính **Nhất quán mạnh (ACID)** cho các giao dịch quan trọng và tuân thủ các chuẩn bảo mật khắt khe như **ISO 27001** hay **SOC2**53,54,55.



thiết kế chi tiết bảng api\_keys dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và yêu cầu về bảo mật tích hợp máy-với-máy (Machine-to-Machine - M2M) từ các nguồn dữ liệu, bảng **api\_keys** được thiết kế để cung cấp mã truy cập cho các tích hợp tự động mà không cần thông qua giao diện người dùng12.

Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa hiệu năng trong môi trường cơ sở dữ liệu phân tán YugabyteDB nhờ tính chất sắp xếp theo thời gian, đồng thời đảm bảo tính duy nhất toàn cầu34.

1\. Thiết kế chi tiết bảng `api_keys`

Bảng này tuân thủ quy chuẩn đặt tên `snake_case` và các kiểu dữ liệu chuẩn PostgreSQL/YSQL được khuyến nghị trong các nguồn tài liệu56.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian thực37. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết đến tổ chức (Tenant) sở hữu API Key này2. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên gợi nhớ cho Key (Ví dụ: "Tích hợp ERP", "Sync dữ liệu")28. |
| **key\_prefix** | VARCHAR(10) | NO  |     |     | 10 ký tự đầu của Key để hiển thị trên giao diện quản trị (VD: `sk_live_...`)28. |
| **key\_hash** | TEXT | NO  |     | `UNIQUE` | **Tuyệt đối không lưu Key gốc**. Chỉ lưu bản băm (Hash) để đối soát khi xác thực28. |
| **scopes** | TEXT\[\] | NO  | `'{}'` |     | Mảng danh sách các quyền hạn được cấp (VD: `['crm:read', 'hrm:write']`)89. |
| **allowed\_ips** | CIDR\[\] | YES | `NULL` |     | Giới hạn các dải IP được phép truy cập (IP Whitelist) để tăng cường bảo mật9. |
| **expires\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm Key hết hạn. Nếu NULL là vô hạn (không khuyến nghị cho Enterprise)910. |
| **last\_used\_at** | TIMESTAMPTZ | YES | `NULL` |     | Ghi lại thời điểm cuối cùng Key này được sử dụng để truy cập hệ thống8. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo Key911. |
| **created\_by** | UUID | YES | `NULL` | `REFERENCES users(_id)` | ID của người dùng thực hiện tạo Key này910. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** để quản lý phiên bản dòng dữ liệu12. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Câu lệnh DDL dưới đây được tối ưu hóa cho YugabyteDB, đảm bảo tính nhất quán mạnh (ACID) và khả năng truy vấn nhanh chóng cho lớp xác thực Gateway1314.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE api_keys (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application layer
    tenant_id UUID NOT NULL,
    
    -- II. THÔNG TIN ĐỊNH DANH (IDENTIFICATION)
    name TEXT NOT NULL,
    key_prefix VARCHAR(10) NOT NULL,
    key_hash TEXT NOT NULL,
    
    -- III. QUYỀN HẠN & BẢO MẬT (SECURITY)
    scopes TEXT[] NOT NULL DEFAULT '{}',
    allowed_ips CIDR[], -- Kiểu dữ liệu chuyên dụng cho IP/Mạng trong Postgres
    
    -- IV. TRẠNG THÁI & TRUY VẾT (AUDIT)
    expires_at TIMESTAMPTZ,
    last_used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID,
    version BIGINT NOT NULL DEFAULT 1,

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_api_key_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_api_key_creator FOREIGN KEY (created_by) REFERENCES users(_id),
    CONSTRAINT uq_api_key_hash UNIQUE (key_hash),
    CONSTRAINT chk_api_key_name CHECK (LENGTH(name) > 0),
    CONSTRAINT chk_api_key_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng nhất: Hỗ trợ API Gateway tra cứu Key cực nhanh khi xác thực request
-- Query: SELECT tenant_id, scopes, allowed_ips FROM api_keys WHERE key_hash = ? AND (expires_at IS NULL OR expires_at > NOW());
CREATE INDEX idx_api_key_lookup 
ON api_keys (key_hash) 
WHERE expires_at IS NULL OR expires_at > NOW();

-- Index hỗ trợ Tenant quản lý danh sách Key của mình trong trang cấu hình
CREATE INDEX idx_api_key_tenant_list 
ON api_keys (tenant_id, created_at DESC);

-- Index GIN hỗ trợ tìm kiếm các Key có quyền (scope) cụ thể
CREATE INDEX idx_api_key_scopes 
ON api_keys USING GIN (scopes);
```

Các phân tích kỹ thuật từ nguồn dữ liệu:

• **Bảo mật tuyệt đối (Zero Trust):** Theo nguồn tài liệu, hệ thống chỉ lưu `key_hash` và không bao giờ lưu Key gốc28. Điều này đảm bảo rằng ngay cả khi cơ sở dữ liệu bị xâm nhập, kẻ tấn công cũng không thể sử dụng các API Key này8.

• **IP Whitelisting:** Việc sử dụng kiểu dữ liệu `CIDR[]` cho `allowed_ips` cho phép doanh nghiệp cấu hình chính xác dải IP của server đối tác, ngăn chặn các truy cập từ các nguồn lạ kể cả khi Key bị lộ9.

• **Hiệu năng xác thực:** Chỉ mục `idx_api_key_lookup` được thiết kế để API Gateway có thể xác định quyền hạn của request trong thời gian dưới 1ms, đặc biệt hiệu quả khi kết hợp với bộ nhớ đệm Redis như đã phân tích trong kiến trúc tổng thể1516.

• **Khả năng mở rộng:** Sử dụng `TEXT[]` cho `scopes` giúp hệ thống linh hoạt bổ sung các quyền hạn mới mà không cần thay đổi cấu trúc bảng1718.

**Ví von để dễ hiểu:** Bảng `api_keys` giống như một **danh sách thẻ ra vào đặc biệt dành cho robot**. Mỗi chiếc thẻ không có ảnh mặt người (không mật khẩu), nhưng có một mã số định danh mà máy quét (Gateway) nhận diện được. Tòa nhà (hệ thống) không giữ bản sao chìa khóa, chỉ giữ một bản in dấu vân tay của chìa (Hash). Nếu robot mang thẻ đến từ một hành lang lạ (IP không thuộc whitelist) hoặc thẻ đã quá hạn, cửa sẽ không mở.



thiết kế chi tiết bảng service\_accounts dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh (IAM) cho Enterprise SaaS và mô hình quản lý "tài khoản máy" từ các nguồn dữ liệu, bảng **service\_accounts** được thiết kế để quản lý các thực thể không phải con người (như Bot, CI/CD, hoặc các dịch vụ tích hợp bên thứ ba)1,2.

Việc sử dụng **UUID v7** cho khóa chính giúp tối ưu hóa việc phân tán dữ liệu trên các node của YugabyteDB và đảm bảo các bản ghi được sắp xếp theo thời gian thực một cách tự nhiên3,1.

1\. Thiết kế chi tiết bảng `service_accounts`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp tối ưu sharding3. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định tài khoản này thuộc về tổ chức nào4,1. |
| **name** | TEXT | NO  |     | `CHECK (LENGTH(name) > 0)` | Tên hiển thị (VD: "GitHub Action Bot", "ERP Sync")1. |
| **description** | TEXT | YES | `NULL` |     | Mô tả chi tiết mục đích sử dụng của tài khoản1. |
| **client\_id** | VARCHAR(64) | NO  |     | `UNIQUE` | Mã định danh duy nhất dùng để xác thực thay cho email1. |
| **client\_secret\_hash** | TEXT | NO  |     |     | Bản băm mật khẩu của tài khoản máy1. |
| **member\_id** | UUID | NO  |     | `REFERENCES tenant_members(_id)` | Liên kết sang bảng thành viên để gán quyền RBAC như người thật5. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kích hoạt của tài khoản1. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo tài khoản (UTC)6. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng7. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè đồng thời8. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Thiết kế này tuân thủ quy tắc `snake_case` và sử dụng các kiểu dữ liệu tối ưu cho YugabyteDB như `TEXT` và `TIMESTAMPTZ`9,6.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE service_accounts (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    member_id UUID NOT NULL,
    
    -- II. THÔNG TIN XÁC THỰC
    name TEXT NOT NULL,
    description TEXT,
    client_id VARCHAR(64) NOT NULL,
    client_secret_hash TEXT NOT NULL,
    
    -- III. TRẠNG THÁI & AUDIT
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_service_account_client_id UNIQUE (client_id),
    CONSTRAINT fk_service_account_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT fk_service_account_member FOREIGN KEY (member_id) REFERENCES tenant_members(_id),
    CONSTRAINT chk_service_account_name CHECK (LENGTH(name) > 0),
    CONSTRAINT chk_service_account_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ xác thực cực nhanh khi Bot gọi API
-- Query: SELECT * FROM service_accounts WHERE client_id = ? AND is_active = TRUE;
CREATE INDEX idx_service_account_auth 
ON service_accounts (client_id) 
WHERE is_active = TRUE;

-- Index hỗ trợ quản trị viên liệt kê các tài khoản máy theo Tenant
CREATE INDEX idx_service_account_tenant_list 
ON service_accounts (tenant_id, created_at DESC);
```

Các phân tích kỹ thuật quan trọng từ nguồn dữ liệu:

• **Hợp nhất phân quyền (Unified RBAC):** Thông qua cột `member_id`, hệ thống phân quyền (RBAC) có thể xử lý Bot và Người một cách thống nhất5. Khi tạo một `service_account`, hệ thống sẽ tự động tạo một bản ghi tương ứng trong `tenant_members` để gán vai trò (Roles)5.

• **Bảo mật:** Tương tự như mật khẩu người dùng, hệ thống chỉ lưu `client_secret_hash` chứ không lưu mật khẩu gốc để đảm bảo an toàn dữ liệu1.

• **Hiệu năng phân tán:** Việc sử dụng UUID v7 làm khóa chính giúp tránh hiện tượng "hotspot" (quá tải cục bộ) trên một node duy nhất khi có nhiều tài khoản được tạo mới đồng thời trong hệ thống phân tán của YugabyteDB3,10.

**Ví von:** Bảng `service_accounts` giống như việc cấp **thẻ ra vào cho robot tự hành** trong một tòa nhà văn phòng. Thay vì dùng dấu vân tay (mật khẩu con người), robot dùng mã quét (client\_id) và mã bảo mật (client\_secret). Tuy nhiên, để biết robot được phép vào phòng nào, nó vẫn cần được đăng ký như một "nhân viên" (member\_id) trong danh sách quản lý của tòa nhà.



thiết kế chi tiết bảng user\_devices dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về hệ thống quản trị định danh và bảo mật cho Enterprise SaaS từ các nguồn dữ liệu, bảng **user\_devices** đóng vai trò là một lớp phòng thủ chiều sâu (Defense-in-Depth)1. Bảng này giúp hệ thống nhận diện các thiết bị tin cậy, phát hiện đăng nhập lạ và ngăn chặn các cuộc tấn công chiếm quyền điều khiển tài khoản23.

Việc sử dụng **UUID v7** cho khóa chính là lựa chọn tối ưu cho YugabyteDB vì tính chất sắp xếp theo thời gian giúp giảm thiểu hiện tượng "hotspot" và tăng hiệu suất ghi trong môi trường phân tán45.

1\. Thiết kế chi tiết bảng `user_devices`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian thực46. |
| **user\_id** | UUID | NO  |     | `REFERENCES users(_id) ON DELETE CASCADE` | Liên kết với tài khoản người dùng chủ sở hữu thiết bị6. |
| **device\_fingerprint** | VARCHAR(255) | NO  |     | `UNIQUE` | Mã định danh thiết bị (được tạo từ trình duyệt, OS và phần cứng)6. |
| **name** | TEXT | YES | `NULL` |     | Tên gợi nhớ do người dùng đặt (VD: "Macbook Pro của An")6. |
| **user\_agent\_parsed** | JSONB | NO  | `'{}'` |     | Chứa thông tin chi tiết đã phân tách từ User Agent (OS, phiên bản trình duyệt)6. |
| **trust\_status** | VARCHAR(20) | NO  | `'UNTRUSTED'` | `CHECK (trust_status IN ('UNTRUSTED', 'TRUSTED', 'BLOCKED'))` | Trạng thái tin cậy của thiết bị để quyết định có cần yêu cầu MFA hay không6. |
| **last\_ip** | INET | YES | `NULL` |     | Địa chỉ IP cuối cùng thiết bị này sử dụng để truy cập6. |
| **last\_active\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cuối cùng thiết bị hoạt động trên hệ thống67. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm thiết bị lần đầu được ghi nhận7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL để tạo bảng và chỉ mục (Indexes)

Thiết kế này tận dụng kiểu dữ liệu `INET` chuyên dụng cho địa chỉ IP và `JSONB` để lưu trữ linh hoạt thông tin thiết bị mà không làm giảm hiệu năng truy vấn89.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE user_devices (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    user_id UUID NOT NULL,
    
    -- II. THÔNG TIN THIẾT BỊ (DEVICE INFO)
    device_fingerprint VARCHAR(255) NOT NULL,
    name TEXT,
    user_agent_parsed JSONB NOT NULL DEFAULT '{}',
    
    -- III. TRẠNG THÁI BẢO MẬT (SECURITY STATUS)
    trust_status VARCHAR(20) NOT NULL DEFAULT 'UNTRUSTED',
    last_ip INET,
    
    -- IV. TRUY VẾT THỜI GIAN (AUDIT)
    last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_device_user FOREIGN KEY (user_id) REFERENCES users(_id) ON DELETE CASCADE,
    CONSTRAINT uq_device_fingerprint UNIQUE (device_fingerprint),
    CONSTRAINT chk_device_trust_status CHECK (trust_status IN ('UNTRUSTED', 'TRUSTED', 'BLOCKED'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ xác thực nhanh thiết bị khi người dùng đăng nhập
-- Truy vấn: SELECT trust_status FROM user_devices WHERE user_id = ? AND device_fingerprint = ?;
CREATE INDEX idx_user_device_lookup 
ON user_devices (user_id, device_fingerprint);

-- Index hỗ trợ người dùng quản lý danh sách thiết bị của mình (Để thu hồi/Logout)
CREATE INDEX idx_user_devices_list 
ON user_devices (user_id, last_active_at DESC);

-- Index hỗ trợ Admin hệ thống tìm kiếm các thiết bị đang bị chặn (BLOCKED)
CREATE INDEX idx_blocked_devices 
ON user_devices (trust_status) 
WHERE trust_status = 'BLOCKED';
```

Phân tích sâu về kiến trúc từ các nguồn dữ liệu:

• **Tối ưu hóa Sharding với UUID v7:** Việc sử dụng UUID v7 làm khóa chính giúp các thiết bị mới được tạo ra được phân bổ đều trên các node trong cụm YugabyteDB, tránh hiện tượng nghẽn cổ chai khi có lượng lớn người dùng đăng nhập cùng lúc từ thiết bị mới45.

• **Cơ chế Tin cậy (Trust Mechanism):** Theo nguồn3, khi phát hiện một `device_fingerprint` mới chưa có trong DB, hệ thống sẽ tự động gửi cảnh báo "Đăng nhập thiết bị lạ" và yêu cầu xác thực MFA. Ngược lại, nếu trạng thái là `TRUSTED`, trải nghiệm người dùng sẽ mượt mà hơn vì có thể bỏ qua bước MFA1011.

• **Xử lý dữ liệu linh hoạt với JSONB:** Trường `user_agent_parsed` cho phép hệ thống lưu trữ các thuộc tính biến động của thiết bị (phiên bản trình duyệt nâng cấp, độ phân giải màn hình) mà không cần thay đổi cấu trúc bảng thường xuyên912.

• **Bảo mật dữ liệu:** Kết hợp với bảng `auth_logs`, dữ liệu từ `user_devices` giúp phát hiện các cuộc tấn công Brute-force hoặc chiếm đoạt tài khoản khi một User ID được sử dụng liên tục trên nhiều thiết bị lạ trong thời gian ngắn13.

**Ví von:** Bảng `user_devices` giống như một **"Sổ đăng ký phương tiện"** tại cổng an ninh của một tòa nhà doanh nghiệp. Khi bạn đến bằng một chiếc xe quen thuộc đã được đăng ký (`TRUSTED`), bảo vệ sẽ cho bạn vào nhanh. Nếu bạn đi một chiếc xe lạ (`UNTRUSTED`), bạn buộc phải xuất trình thêm giấy tờ (MFA). Nếu chiếc xe đó nằm trong danh sách đen (`BLOCKED`), cổng sẽ không bao giờ mở.



trong các bảng của phần Access & Security bảng nào nên lưu vào ClickHouse, bảng nào nên lưu vào MongoDB

Dựa trên triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) được đề cập trong các nguồn tài liệu, việc phân bổ các bảng thuộc phân hệ **Access & Security** vào ClickHouse hay MongoDB phụ thuộc vào tính chất của dữ liệu: là dữ liệu vận hành (Operational), dữ liệu quan hệ (ACID), hay dữ liệu phân tích/nhật ký (Analytics/Logs)12.

Dưới đây là phân tích chi tiết về việc lưu trữ các bảng này:

1\. Các bảng nên lưu vào ClickHouse (Dữ liệu Lớn & Phân tích)

ClickHouse đóng vai trò là **"Bộ nhớ vĩnh cửu"**, chuyên xử lý dữ liệu lịch sử, sự kiện với khối lượng khổng lồ, chỉ ghi thêm (Append-only) và ít khi sửa/xóa34. Trong phần Access & Security, các bảng sau đây thuộc diện này:

• **security\_audit\_logs** **(hoặc** **audit\_logs****):** Lưu trữ dấu vết "Ai làm gì, lúc nào?". Với hệ thống lớn, bảng này có thể lên tới hàng tỷ bản ghi, việc lưu vào ClickHouse giúp nén dữ liệu cực tốt (tỷ lệ 10:1) và truy vấn thống kê nhanh chóng4....

• **auth\_logs****:** Nhật ký chi tiết các lần đăng nhập thành công hoặc thất bại. Dữ liệu này cần thiết để phát hiện các cuộc tấn công Brute-force hoặc các hành vi đăng nhập bất thường theo thời gian78.

• **api\_usage\_logs****:** Ghi lại lịch sử sử dụng của các `api_keys`, bao gồm số lượng request, dung lượng bandwidth để phục vụ việc tính tiền (Billing) hoặc giới hạn băng thông (Rate Limit)910.

• **webhook\_delivery\_logs****:** Lưu lịch sử các lần hệ thống bắn thông báo đến các bên thứ ba, bao gồm kết quả thành công hay thất bại và phản hồi từ server đối tác1112.

**Lý do chọn ClickHouse:** Các bảng này mang tính chất bất biến (Immutable), không bao giờ cập nhật (Update) mà chỉ chèn mới (Insert). ClickHouse tối ưu hóa cho các truy vấn tổng hợp (SUM, COUNT) trên tập dữ liệu lớn mà các DB quan hệ hay Document sẽ bị quá tải413.

\--------------------------------------------------------------------------------

2\. Các bảng nên lưu vào MongoDB (Dữ liệu Động & Cấu hình)

MongoDB được coi là **"Bộ não linh hoạt"**, phù hợp với các dữ liệu có cấu trúc lồng nhau, thay đổi thường xuyên và khác biệt tùy theo ngữ cảnh của từng khách hàng (Tenant)14.

• **tenant\_app\_configs** **(phần liên quan đến bảo mật):** Nếu khách hàng muốn tự định nghĩa các quy trình phê duyệt động (Workflow definitions) hoặc các cài đặt bảo mật mang tính "sở thích" riêng biệt không nằm trong schema chuẩn, MongoDB là nơi lưu trữ lý tưởng nhờ tính schema-less1415.

• **custom\_fields****:** Định nghĩa các trường dữ liệu bổ sung mà Tenant tự thêm vào hồ sơ người dùng (ví dụ: "Mã số thẻ nhân viên", "Nhóm máu") phục vụ cho mục đích định danh nội bộ516.

• **user\_ui\_preferences****:** Lưu trữ các cấu hình giao diện bảo mật cá nhân của người dùng, như cài đặt chế độ hiển thị, ẩn/hiện các cột thông tin nhạy cảm trên Dashboard17.

**Lý do chọn MongoDB:** Các dữ liệu này thường được lấy ra trọn gói dưới dạng một đối tượng (Get whole object), giúp giảm thiểu việc JOIN nhiều bảng và linh hoạt khi mỗi Tenant có một yêu cầu cấu hình khác nhau mà không cần thực hiện lệnh `ALTER TABLE` gây khóa bảng14....

\--------------------------------------------------------------------------------

3\. Lưu ý quan trọng: Những bảng KHÔNG NÊN lưu vào ClickHouse/MongoDB

Theo nguồn tài liệu, các dữ liệu **Core Identity** yêu cầu tính nhất quán tuyệt đối (ACID) và quan hệ chặt chẽ thì bắt buộc phải lưu ở **YugabyteDB (Postgres)** thay vì ClickHouse hay MongoDB2021:

• **Dữ liệu định danh lõi:** `users`, `tenants`, `tenant_members`, `passwords` (hash). Các dữ liệu này nếu bị sai lệch (eventual consistency) sẽ dẫn đến rủi ro bảo mật nghiêm trọng1920.

• **Dữ liệu phân quyền:** `roles`, `permissions`, `user_roles`, `access_control_lists`, `tenant_security_policies`. Việc gán quyền và kiểm tra quyền yêu cầu tính nhất quán mạnh để đảm bảo người dùng không thể truy cập trái phép ngay sau khi bị thu hồi quyền20....

• **Dữ liệu xác thực:** `user_sessions`, `user_mfa_methods`, `api_keys`. Các bảng này cần sự an toàn tuyệt đối của một "Két sắt an toàn" như YugabyteDB2024.

Tóm tắt chiến lược dòng chảy dữ liệu (Data Flow)

Để hệ thống vận hành trơn tru, bạn nên áp dụng mô hình sau:

1\. **Ghi (Write):** Các hành động xác thực và cấu hình được ghi vào YugabyteDB hoặc MongoDB (tùy tính chất)25.

2\. **Đồng bộ (Sync):** Sử dụng **Kafka + Debezium (CDC)** để lắng nghe thay đổi từ YugabyteDB/MongoDB và đẩy dữ liệu sang ClickHouse để phân tích, tránh việc ứng dụng phải ghi đồng thời vào cả hai DB (Dual Write)1326.

3\. **Đọc (Read):** Ứng dụng truy vấn trực tiếp ClickHouse khi cần xem báo cáo hoặc tra cứu nhật ký audit để đảm bảo hiệu suất27.

**Sự ví von:** Việc phân chia này giống như trong một bệnh viện: **YugabyteDB** là hồ sơ bệnh án gốc và két sắt thuốc (phải cực kỳ chính xác và bảo mật), **MongoDB** là sơ đồ phòng bệnh và yêu cầu cá nhân của bệnh nhân (thay đổi linh hoạt tùy người), còn **ClickHouse** là nhật ký đo nhịp tim và camera an ninh (lưu trữ lượng dữ liệu khổng lồ theo thời gian để tra cứu khi có sự cố)4....



Phân biệt vai trò của bảng Features và bảng Configs trong SaaS.

Trong kiến trúc hệ thống SaaS quy mô lớn, việc phân tách rõ ràng giữa **Features** (Tính năng/Quyền lợi) và **Configs** (Cấu hình vận hành) là một quy tắc vàng để đảm bảo hệ thống vừa chặt chẽ về mặt thương mại, vừa linh hoạt về mặt vận hành1,2. Dưới đây là sự phân biệt chi tiết dựa trên các nguồn tài liệu:

1\. Bản chất và Mục đích sử dụng

• **Features (Tính năng - Quyền lợi thương mại):** Đây là các thuộc tính quy định **"Quyền lợi"** của khách hàng gắn liền với gói dịch vụ (Service Package) mà họ đã mua1. Nó trả lời cho câu hỏi: **"Tenant được phép làm gì?"** và **"Được dùng bao nhiêu?"**1. Features mang tính chất pháp lý và thương mại, là cơ sở để hệ thống kiểm tra quyền (Entitlement Check)3.

• **Configs (Cấu hình - Sở thích vận hành):** Đây là các thuộc tính quy định **"Sở thích vận hành"** hoặc logic xử lý riêng biệt của từng khách hàng1. Nó trả lời cho câu hỏi: **"Tenant muốn hệ thống hoạt động như thế nào?"**1. Configs mang tính chất tùy biến trải nghiệm và quy trình làm việc (Workflow) của người dùng4.

2\. So sánh chi tiết

| Đặc điểm | Features (Quyền lợi) | Configs (Cấu hình) |
| --- | --- | --- |
| **Câu hỏi đại diện** | "Được làm gì?" / "Được bao nhiêu?"1 | "Làm như thế nào?" / "Giao diện ra sao?"1 |
| **Ví dụ điển hình** | `max_users: 10`, `allow_export_excel: true`, `storage_gb: 50`1,5 | `theme_color: #blue`, `workflow_steps`, `language: vi-VN`1,6 |
| **Vị trí lưu trữ** | Thường lưu tại **YugabyteDB** (Postgres) trong bảng `service_packages` và được snapshot vào `tenant_subscriptions`1,7. | Thường lưu tại **MongoDB** trong bảng `tenant_app_configs` để tận dụng tính linh hoạt (Schema-less)8,4. |
| **Tính chất thay đổi** | Thay đổi khi khách hàng nâng cấp gói, mua thêm add-on hoặc gia hạn7,9. | Thay đổi khi Admin của Tenant vào trang cài đặt để chỉnh sửa theo ý muốn6. |
| **Tác động hệ thống** | Ảnh hưởng đến việc chặn/mở quyền truy cập hoặc giới hạn số lượng tài nguyên10. | Ảnh hưởng đến logic xử lý code, luồng phê duyệt hoặc hiển thị UI/UX4,6. |

3\. Chiến lược lưu trữ và Kỹ thuật

• **Đối với Features:** Do liên quan trực tiếp đến tiền nong và quyền lợi (Billing & Entitlement), dữ liệu này yêu cầu tính **nhất quán tuyệt đối (ACID)**8,11. Khi một Tenant mua gói, hệ thống phải thực hiện **Snapshot** (sao chép) toàn bộ Features từ gói gốc vào bảng đăng ký của khách hàng để tránh việc thay đổi giá hay quyền lợi ở gói gốc làm ảnh hưởng đến các hợp đồng cũ đang hiệu lực12,7.

• **Đối với Configs:** Vì mỗi khách hàng có thể có những cấu hình hoàn toàn khác nhau (Tenant A cần thêm trường dữ liệu X, Tenant B không cần), việc dùng **MongoDB** là tối ưu để tránh việc phải thực hiện lệnh `ALTER TABLE` gây khóa bảng trong SQL truyền thống mỗi khi có yêu cầu tùy biến mới4,11.

4\. Luồng xử lý dữ liệu (Data Flow)

• Khi người dùng đăng nhập, hệ thống sẽ kiểm tra **Features** từ cache (thường là Redis) để biết họ có quyền vào module đó không12,13.

• Sau khi đã vào được module, hệ thống mới tải các **Configs** từ MongoDB để biết phải hiển thị màu sắc gì, ngôn ngữ nào và quy trình phê duyệt gồm những bước nào cho người dùng đó4,6.

**Sự ví von để dễ hiểu:** Hãy tưởng tượng Tenant thuê một căn hộ trong tòa nhà SaaS. **Features** chính là các điều khoản trong hợp đồng thuê: căn hộ rộng bao nhiêu mét vuông, được ở tối đa mấy người, có được gửi xe hay không. Trong khi đó, **Configs** chính là cách Tenant bài trí căn hộ đó: sơn tường màu gì, đặt lịch bật đèn lúc mấy giờ, hay sắp xếp đồ đạc trong phòng ra sao. Chủ tòa nhà (Provider) kiểm soát Features, nhưng khách thuê (Tenant) có toàn quyền quyết định Configs trong phạm vi căn hộ của mình.



thiết kế chi tiết bảng auth\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên các phân tích về kiến trúc hệ thống Enterprise SaaS và quy chuẩn lưu trữ dữ liệu lớn (OLAP), bảng **auth\_logs** được thiết kế để lưu trữ trong **ClickHouse**. Đây là nơi đóng vai trò "Bộ nhớ vĩnh cửu", chuyên xử lý nhật ký truy cập với khối lượng khổng lồ (hàng tỷ bản ghi) nhờ vào khả năng nén dữ liệu cực tốt và tốc độ truy vấn tổng hợp vượt trội1,2.

Việc sử dụng **UUID v7** cho phép các bản ghi nhật ký được sắp xếp tự nhiên theo thời gian, giúp tối ưu hóa việc chèn dữ liệu (Insert) và tra cứu lịch sử trong môi trường phân tán3.

1\. Thiết kế chi tiết bảng `auth_logs` (ClickHouse)

Trong ClickHouse, chúng ta ưu tiên sử dụng các kiểu dữ liệu chuyên biệt như `IPv6` (hỗ trợ cả IPv4) và `Enum` để tối ưu hóa hiệu năng và dung lượng lưu trữ4,5.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**3. |
| **tenant\_id** | UUID | NO  |     |     | Định danh tổ chức sở hữu log này (Dùng để lọc dữ liệu)6,7. |
| **user\_id** | Nullable(UUID) | YES | `NULL` |     | ID người dùng nếu đăng nhập thành công hoặc email tồn tại8. |
| **impersonator\_id** | Nullable(UUID) | YES | `NULL` |     | ID nhân viên Support nếu đang sử dụng tính năng "Impersonation"9,10. |
| **email\_attempted** | String | NO  |     |     | Email người dùng đã nhập vào khi thử đăng nhập8. |
| **ip\_address** | IPv6 | NO  |     |     | Địa chỉ IP truy cập (Lưu chuẩn IPv6 để bao quát cả IPv4)8. |
| **user\_agent** | String | NO  |     |     | Thông tin trình duyệt và hệ điều hành (User Agent)8. |
| **is\_success** | Bool | NO  |     |     | `true` nếu thành công, `false` nếu thất bại5,8. |
| **login\_method** | Enum8(...) | NO  | `'PASSWORD'` | `PASSWORD`, `GOOGLE`, `SSO`, `MAGIC_LINK` | Phương thức xác thực được sử dụng4,8. |
| **failure\_reason** | Enum8(...) | NO  | `'NONE'` | `NONE`, `WRONG_PW`, `MFA_FAIL`, `LOCKED` | Lý do thất bại (nếu có) để phục vụ phân tích bảo mật8. |
| **created\_at** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm phát sinh sự kiện, chính xác đến mili giây4,5. |

\--------------------------------------------------------------------------------

2\. Mô tả chi tiết các thuộc tính kỹ thuật

• **UUID v7:** Giúp ClickHouse index dữ liệu tốt hơn vì các ID được sinh ra có tính tuần tự theo thời gian, tránh việc ghi dữ liệu ngẫu nhiên vào các phần (parts) khác nhau của ổ đĩa3.

• **Enum8:** Thay vì lưu chuỗi "PASSWORD" tốn nhiều byte, ClickHouse lưu dưới dạng số nguyên 8-bit giúp nén dữ liệu cực mạnh và tăng tốc độ lọc (Filtering)4,5.

• **Partitioning (Phân vùng):** Dữ liệu được chia theo tháng (`toYYYYMM`) để dễ dàng xóa dữ liệu cũ (Cold data) và tăng tốc độ truy vấn cho các báo cáo trong tháng7,11.

\--------------------------------------------------------------------------------

3\. Câu lệnh tạo bảng và Index trong ClickHouse

Trong ClickHouse, `ORDER BY` chính là chỉ mục chính (Primary Index). Chúng ta chọn `tenant_id` và `created_at` làm khóa sắp xếp để tối ưu cho truy vấn: "Lấy lịch sử đăng nhập của công ty A trong khoảng thời gian X"7.

```
CREATE TABLE auth_logs (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID,
    tenant_id UUID,
    user_id Nullable(UUID),
    impersonator_id Nullable(UUID),

    -- II. CHI TIẾT ĐĂNG NHẬP
    email_attempted String,
    ip_address IPv6,
    user_agent String,
    
    -- III. KẾT QUẢ & PHƯƠNG THỨC (Dùng Enum để tối ưu)
    is_success Bool,
    login_method Enum8(
        'PASSWORD' = 1, 
        'GOOGLE' = 2, 
        'SSO' = 3, 
        'MAGIC_LINK' = 4, 
        'PASSKEY' = 5
    ),
    failure_reason Enum8(
        'NONE' = 0, 
        'WRONG_PASSWORD' = 1, 
        'MFA_FAILED' = 2, 
        'USER_LOCKED' = 3, 
        'INVALID_TOKEN' = 4
    ),

    -- IV. THỜI GIAN
    created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng quản lý vòng đời (Retention Policy)
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant trước, thời gian sau để tối ưu truy vấn SaaS
ORDER BY (tenant_id, created_at, _id)
-- Cấu hình lưu trữ bổ sung (Tùy chọn)
SETTINGS index_granularity = 8192;

-- Tạo Index Bloom Filter cho trường email_attempted để tìm kiếm nhanh khi bị tấn công Brute-force
ALTER TABLE auth_logs ADD INDEX idx_email_search email_attempted TYPE bloom_filter(0.01) GRANULARITY 1;
```

**Sự ví von:** Bảng `auth_logs` trong ClickHouse giống như **"Camera an ninh ghi hình liên tục"** của tòa nhà SaaS2. Nó không dùng để điều khiển cửa ra vào (đó là việc của YugabyteDB), nhưng nó lưu lại mọi lượt ra vào. Khi có sự cố, bạn có thể tua lại băng ghi hình của hàng triệu lượt khách chỉ trong vài giây để tìm ra kẻ đột nhập nhờ cách sắp xếp ngăn nắp theo thời gian và khu vực (Tenant)12,7.



thiết kế chi tiết bảng security\_audit\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS dành cho dữ liệu lớn và kiến trúc "Polyglot Persistence", bảng **security\_audit\_logs** được lưu trữ tại **ClickHouse** để tận dụng khả năng nén dữ liệu vượt trội và tốc độ truy vấn phân tích trên hàng tỷ bản ghi1,2.

Việc sử dụng **UUID v7** làm khóa chính giúp các bản ghi được sắp xếp tuần tự theo thời gian ngay từ tầng định danh, hỗ trợ ClickHouse tối ưu hóa việc ghi dữ liệu vào các ổ đĩa3,4.

1\. Thiết kế chi tiết bảng `security_audit_logs` (ClickHouse)

Bảng này tập trung vào việc trả lời câu hỏi: "Ai đã làm gì, vào lúc nào, trên đối tượng nào và thông qua thiết bị gì?"5,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian3,4. |
| **tenant\_id** | UUID | NO  |     |     | Định danh tổ chức sở hữu hành động này để phân vùng dữ liệu7,8. |
| **actor\_id** | UUID | NO  |     |     | ID của người dùng thực hiện hành động6. |
| **impersonator\_id** | Nullable(UUID) | YES | `NULL` |     | ID nhân viên hỗ trợ nếu đang sử dụng tính năng "Impersonation" (giả danh)9,10. |
| **event\_category** | Enum8(...) | NO  |     | `IAM`, `AUTH`, `BILLING`, `DATA` | Nhóm sự kiện chính để lọc nhanh (Ví dụ: Bảo mật, Thanh toán)11,6. |
| **event\_action** | String | NO  |     |     | Hành động cụ thể (Ví dụ: `ROLE_ASSIGNED`, `API_KEY_CREATED`)6. |
| **target\_id** | Nullable(UUID) | YES | `NULL` |     | ID của đối tượng bị tác động (Ví dụ: ID của User bị khóa)6. |
| **resource\_type** | String | NO  |     |     | Loại tài nguyên bị tác động (Ví dụ: `USER`, `INVOICE`, `ROLE`)12. |
| **ip\_address** | IPv6 | NO  |     |     | Địa chỉ IP của người thực hiện (Lưu IPv6 để bao quát cả IPv4)6. |
| **user\_agent** | String | NO  |     |     | Thông tin trình duyệt và hệ điều hành6. |
| **details** | String | NO  | `'{}'` |     | Lưu chi tiết thay đổi dưới dạng **JSON String** (Dùng `JSONExtract` khi truy vấn)13,6. |
| **created\_at** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm xảy ra sự kiện, chính xác đến mili giây11,13. |

\--------------------------------------------------------------------------------

2\. Câu lệnh ClickHouse tạo bảng và chỉ mục (Index)

Trong ClickHouse, chỉ mục chính được định nghĩa qua `ORDER BY`. Chúng ta sẽ phân vùng dữ liệu theo tháng để dễ dàng quản lý vòng đời dữ liệu (Archiving)8,14.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE security_audit_logs (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID,
    tenant_id UUID,
    actor_id UUID,
    impersonator_id Nullable(UUID),

    -- II. CHI TIẾT SỰ KIỆN (Dùng Enum để nén dữ liệu cực tốt)
    event_category Enum8(
        'IAM' = 1, 
        'AUTH' = 2, 
        'BILLING' = 3, 
        'DATA' = 4, 
        'SYSTEM' = 5
    ),
    event_action String,
    target_id Nullable(UUID),
    resource_type String,

    -- III. THÔNG TIN MÔI TRƯỜNG
    ip_address IPv6,
    user_agent String,
    details String, -- Lưu JSON thô

    -- IV. THỜI GIAN
    created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng theo tháng để tối ưu việc xóa dữ liệu cũ (Data Archiving)
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant và Thời gian để phục vụ query Dashboard SaaS nhanh nhất
ORDER BY (tenant_id, created_at, _id)
SETTINGS index_granularity = 8192;

-- 2. CHIẾN LƯỢC ĐÁNH INDEX BỔ SUNG (SKIPPING INDEX)

-- Index giúp tìm kiếm nhanh các hành động cụ thể trong hàng tỷ bản ghi
ALTER TABLE security_audit_logs 
ADD INDEX idx_event_action event_action TYPE bloom_filter(0.01) GRANULARITY 1;

-- Index hỗ trợ tra cứu lịch sử tác động lên một tài nguyên cụ thể (target_id)
ALTER TABLE security_audit_logs 
ADD INDEX idx_target_lookup target_id TYPE bloom_filter(0.01) GRANULARITY 1;
```

3\. Các lưu ý kỹ thuật quan trọng từ nguồn dữ liệu

• **Hiệu năng:** Việc sắp xếp dữ liệu theo `(tenant_id, created_at)` cho phép hệ thống lấy ra toàn bộ nhật ký của một khách hàng trong một khoảng thời gian cụ thể chỉ trong vài mili giây, thay vì phải quét toàn bộ ổ đĩa2,8.

• **Tính bất biến:** Dữ liệu trong ClickHouse là **Append-only** (chỉ ghi thêm), đảm bảo tính toàn vẹn cho mục đích pháp lý vì log không bị sửa đổi5,15.

• **Tiết kiệm chi phí:** Nhờ lưu trữ dạng cột và kiểu dữ liệu Enum, ClickHouse có thể nén dữ liệu audit lên đến 10 lần so với các cơ sở dữ liệu truyền thống, giúp tiết kiệm đáng kể chi phí lưu trữ S3/SSD2,16.

**Sự ví von:** Bảng `security_audit_logs` trong ClickHouse giống như một **"Hộp đen máy bay"** của hệ thống SaaS. Nó ghi lại mọi thông số kỹ thuật và hành vi của phi hành đoàn (người dùng) một cách cực kỳ chi tiết và không thể tẩy xóa, giúp bạn có thể phục dựng lại toàn bộ diễn biến sự cố an ninh bất cứ lúc nào5,17.



liệt kê các bảng nhóm tính năng Quản lý truy cập

Dựa trên các nguồn tài liệu về kiến trúc hệ thống Enterprise SaaS, nhóm tính năng **Quản lý truy cập (Access Management)** đóng vai trò quyết định cách thức máy móc, dịch vụ tự động và con người duy trì phiên làm việc hoặc tích hợp với hệ thống12.

Dưới đây là danh sách chi tiết các bảng thuộc nhóm này:

1\. Nhóm truy cập tự động (Machine & Developer Access)

Nhóm này dành cho các tích hợp không thông qua giao diện người dùng truyền thống:

• **api\_keys**: Lưu trữ mã truy cập dành cho các tích hợp **Máy-với-Máy (Machine-to-Machine)**23. Bảng này chỉ lưu bản băm (hash) của chìa khóa để đảm bảo bảo mật và hỗ trợ giới hạn theo dải IP (IP Whitelist)23.

• **personal\_access\_tokens** **(PATs)**: Tương tự như mã truy cập của GitHub, dành cho lập trình viên hoặc các script tự động hóa14. PATs giúp người dùng thực hiện các lệnh API mà không cần dùng mật khẩu hay qua xác thực 2 lớp (MFA) vốn dành cho người thật1.

• **service\_accounts**: Quản lý các tài khoản dành riêng cho bot, CI/CD hoặc các dịch vụ bên thứ ba56. Các tài khoản này được gán một `member_id` để có thể nhận các quyền hạn (RBAC) tương tự như một thành viên bình thường trong tổ chức7.

2\. Nhóm quản lý phiên và thiết bị (Session & Device Management)

Nhóm này tập trung vào việc giám sát và duy trì trạng thái đăng nhập của người dùng:

• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động, bao gồm thông tin về **địa chỉ IP, loại thiết bị (mobile/desktop), hệ điều hành và vị trí địa lý**48. Bảng này cho phép thực hiện các tính năng an ninh như "Đăng xuất khỏi tất cả thiết bị" hoặc thu hồi quyền truy cập ngay lập tức910.

• **user\_devices**: Lưu vết các thiết bị đã từng đăng nhập để xác định mức độ tin cậy (`trust_status`)1112. Dựa vào đây, hệ thống có thể quyết định yêu cầu MFA nếu phát hiện đăng nhập từ một thiết bị lạ (Fingerprint mới)1213.

3\. Nhóm định tuyến và hạ tầng truy cập (Access Infrastructure)

Nhóm này đóng vai trò là "bản đồ" để dẫn hướng các yêu cầu truy cập vào đúng đích:

• **tenant\_app\_routes**: Được coi là bảng quan trọng nhất cho lớp định tuyến (Routing)14. Nó quy định tên miền nào (`domain`) hoặc đường dẫn nào (`path_prefix`) sẽ trỏ vào khách hàng nào (`tenant_id`) và ứng dụng cụ thể nào1516. Dữ liệu này thường được cache lên Redis để đạt tốc độ xử lý dưới 1ms1718.

• **tenant\_sso\_configs**: Chứa cấu hình đăng nhập doanh nghiệp qua các chuẩn như **SAML 2.0 hoặc OIDC**1920. Bảng này cho phép nhân viên của khách hàng Enterprise dùng tài khoản công ty (Azure AD, Okta, Google Workspace) để truy cập hệ thống mà không cần tạo mật khẩu riêng1921.

Tóm tắt vai trò các bảng chính

| Tên bảng | Đối tượng phục vụ | Mục đích chính |
| --- | --- | --- |
| **api\_keys** | Hệ thống bên thứ ba | Tích hợp máy-với-máy (M2M)2. |
| **personal\_access\_tokens** | Lập trình viên | Chạy script, tự động hóa tác vụ1. |
| **service\_accounts** | Bot / Dịch vụ tự động | Thực hiện các tác vụ hệ thống nhân danh Tenant5. |
| **user\_sessions** | Người dùng thực | Duy trì và kiểm soát phiên làm việc trực tuyến8. |
| **tenant\_app\_routes** | Gateway / Reverse Proxy | Định tuyến yêu cầu từ URL vào đúng Tenant/App1416. |

Hệ thống quản lý truy cập này giúp tách biệt hoàn toàn giữa việc **Xác thực con người** (Human Auth) và **Xác thực máy móc** (Machine Auth), đồng thời đảm bảo tính minh bạch thông qua các bản ghi nhật ký chi tiết1222.



bổ sung thêm các bảng nhóm tính năng Quản lý truy cập

Dựa trên các nguồn tài liệu và lịch sử thiết kế hệ thống SaaS Enterprise, nhóm tính năng **Quản lý truy cập (Access Management)** đóng vai trò là "cửa ngõ" điều phối luồng truy cập của con người và máy móc vào tài nguyên hệ thống1,2.

Dưới đây là danh sách chi tiết các bảng bổ sung cho nhóm tính năng này, được phân loại theo mục đích sử dụng cụ thể:

1\. Nhóm Truy cập Tự động và Lập trình viên (Machine & Developer Access)

Nhóm này quản lý các phương thức truy cập không qua giao diện người dùng (Non-interactive), dành cho tích hợp hệ thống3,4.

• **api\_keys**: Lưu trữ mã truy cập cho các tích hợp Máy-với-Máy (M2M)5,6. Bảng này chỉ lưu bản băm (`key_hash`) và giới hạn quyền hạn (`scopes`) cùng dải IP cho phép (`allowed_ips`) để đảm bảo an ninh5,7.

• **personal\_access\_tokens** **(PATs)**: Dành cho lập trình viên sử dụng để chạy script hoặc tự động hóa các tác vụ cá nhân4. Tương tự API Key, nó sử dụng cơ chế `token_hash` và có thời hạn sử dụng (`expires_at`)8.

• **service\_accounts**: Quản lý tài khoản dành riêng cho các dịch vụ tự động như Bot hoặc CI/CD3. Tài khoản này thường liên kết với một `member_id` để được gán quyền RBAC giống như một thành viên thực thụ9.

2\. Nhóm Tích hợp Doanh nghiệp và Định danh (Enterprise Identity & SSO)

Nhóm này giải quyết các yêu cầu khắt khe về quản trị tập trung của khách hàng Enterprise10,11.

• **tenant\_sso\_configs**: Lưu cấu hình đăng nhập một lần (Single Sign-On) qua chuẩn SAML 2.0 hoặc OIDC12,13. Nó cho phép bắt buộc nhân viên phải đăng nhập qua hệ thống của công ty (`is_enforced`)13.

• **tenant\_domains**: Quản lý các tên miền đã xác thực của tổ chức (ví dụ: `fpt.com`) để kiểm soát Shadow IT và tự động hóa việc đưa người dùng vào đúng Tenant dựa trên đuôi email14,15.

• **scim\_directories** **&** **scim\_mappings**: Hỗ trợ chuẩn SCIM 2.0 để tự động đồng bộ hóa việc tạo/xóa người dùng từ các nguồn như Azure AD hoặc Okta sang hệ thống SaaS16,17,18.

• **oauth\_clients**: Cho phép hệ thống SaaS đóng vai trò là một Identity Provider (IdP), cho phép các ứng dụng bên thứ ba hoặc ứng dụng nội bộ của khách hàng "Đăng nhập bằng tài khoản SaaS"19,20.

3\. Nhóm Quản lý Phiên và Thiết bị (Operational Security)

Nhóm này giám sát trạng thái thực tế của các luồng truy cập đang diễn ra21,22.

• **user\_sessions**: Quản lý các phiên làm việc đang hoạt động (Live), lưu trữ thông tin về địa chỉ IP, thiết bị, vị trí địa lý và hỗ trợ cơ chế xoay vòng token (`Rotation`) để chống trộm phiên23,24.

• **user\_devices**: Lưu vết các thiết bị tin cậy dựa trên dấu vân tay thiết bị (`device_fingerprint`)25. Bảng này giúp hệ thống quyết định có cần yêu cầu MFA khi phát hiện đăng nhập từ thiết bị lạ hay không26,27.

• **user\_delegations**: Quản lý việc ủy quyền hành động, cho phép một người (ví dụ: thư ký) thực hiện một số quyền hạn thay mặt người khác (giám đốc) trong một khoảng thời gian nhất định28,29.

4\. Nhóm Hạ tầng và Kiểm soát lưu lượng (Infrastructure & Traffic Control)

Nhóm này đóng vai trò điều hướng kỹ thuật cho các yêu cầu truy cập1,30.

• **tenant\_app\_routes**: "Bản đồ" định tuyến cực kỳ quan trọng, dùng để ánh xạ Domain hoặc Path cụ thể vào đúng Tenant và Ứng dụng xử lý1,2. Dữ liệu này thường được cache lên Redis để đạt tốc độ xử lý micro-seconds31,32.

• **tenant\_rate\_limits**: Cấu hình giới hạn tần suất gọi API (Throttling) cho từng Tenant hoặc từng gói cước để bảo vệ hệ thống khỏi các script lỗi hoặc tấn công DDoS nội bộ30,33.

• **webhooks**: Quản lý luồng truy cập ngược (Outbound), cho phép hệ thống chủ động đẩy dữ liệu sang các URL của khách hàng khi có sự kiện phát sinh10,34.

**Sự ví von:** Nếu hệ thống SaaS là một tòa nhà cao cấp, thì **tenant\_app\_routes** là bảng chỉ dẫn ở cổng, **tenant\_sso\_configs** là thẻ từ của công ty cấp, **api\_keys** là mã mở cửa cho robot giao hàng, và **user\_sessions** là nhật ký của bảo vệ trực tại sảnh ghi lại ai đang ở trong phòng nào35,36,37,38.



thiết kế chi tiết bảng tenant\_app\_routes dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Bảng **tenant\_app\_routes** đóng vai trò là "bản đồ định tuyến" trung tâm của hệ thống SaaS, cho phép API Gateway xác định chính xác yêu cầu từ người dùng (thông qua Domain và Path) thuộc về Tenant nào và ứng dụng cụ thể nào12. Dưới đây là thiết kế chi tiết đáp ứng mô hình đa sản phẩm, đa tên miền và tối ưu hóa hiệu năng trên YugabyteDB.

1\. Thiết kế chi tiết bảng `tenant_app_routes`

Bảng này sử dụng **UUID v7** làm khóa chính để đảm bảo tính phân tán và sắp xếp theo thời gian, đồng thời áp dụng các ràng buộc chặt chẽ để tránh xung đột định tuyến giữa các khách hàng3....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**36. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Liên kết với Tenant sở hữu route này67. |
| **app\_code** | VARCHAR(50) | NO  |     | `CHECK (LENGTH(app_code) > 0)` | Mã ứng dụng đích (VD: `HRM`, `CRM`, `DASHBOARD`)89. |
| **domain** | VARCHAR(255) | NO  |     | `CHECK (domain ~ '^[a-z0-9.-]+$')` | Tên miền truy cập (VD: `hrm.fpt.com`). Chỉ chứa chữ thường, số, dấu chấm và gạch ngang810. |
| **path\_prefix** | VARCHAR(100) | NO  | `'/'` | `CHECK (path_prefix ~ '^/[a-z0-9-/]*$')` | Đường dẫn tiền tố (VD: `/hrm`). Phải bắt đầu bằng dấu `/`710. |
| **is\_primary** | BOOLEAN | NO  | `FALSE` |     | `TRUE` nếu là Domain chính để hệ thống sinh link (Canonical URL)711. |
| **is\_custom\_domain** | BOOLEAN | NO  | `FALSE` |     | `TRUE` nếu là tên miền riêng của khách, `FALSE` nếu là subdomain hệ thống78. |
| **ssl\_status** | VARCHAR(20) | NO  | `'NONE'` | `CHECK (ssl_status IN ('NONE', 'PENDING', 'ACTIVE', 'FAILED'))` | Trạng thái chứng chỉ HTTPS cho custom domain711. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo cấu hình định tuyến (UTC)1112. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng5. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế Optimistic Locking để chống ghi đè đồng thời1314. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Hệ thống định tuyến yêu cầu tốc độ phản hồi dưới **1ms**. Để đạt được điều này, chúng ta sử dụng **Covering Index** trong YugabyteDB nhằm cho phép DB trả về dữ liệu ngay từ Index mà không cần đọc bảng gốc4....

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_app_routes (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    app_code VARCHAR(50) NOT NULL,

    -- II. CẤU HÌNH ĐỊNH TUYẾN
    domain VARCHAR(255) NOT NULL,
    path_prefix VARCHAR(100) NOT NULL DEFAULT '/',
    
    -- III. THÔNG TIN PHỤ TRỢ
    is_primary BOOLEAN NOT NULL DEFAULT FALSE,
    is_custom_domain BOOLEAN NOT NULL DEFAULT FALSE,
    ssl_status VARCHAR(20) NOT NULL DEFAULT 'NONE',
    
    -- IV. AUDIT & VERSIONING
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- V. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_routes_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT uq_domain_path UNIQUE (domain, path_prefix), -- Đảm bảo cặp Domain+Path là duy nhất toàn sàn [4, 10]
    CONSTRAINT chk_route_domain_fmt CHECK (domain ~ '^[a-z0-9.-]+$'),
    CONSTRAINT chk_route_path_fmt CHECK (path_prefix ~ '^/[a-z0-9-/]*$'),
    CONSTRAINT chk_ssl_status CHECK (ssl_status IN ('NONE', 'PENDING', 'ACTIVE', 'FAILED'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index "Thần thánh" cho Router (Covering Index)
-- Giúp API Gateway tìm nhanh tenant_id và app_code từ domain + path
-- Query: SELECT tenant_id, app_code FROM tenant_app_routes WHERE domain = ? AND path_prefix = ?;
CREATE UNIQUE INDEX idx_routes_fast_lookup 
ON tenant_app_routes (domain, path_prefix) 
INCLUDE (tenant_id, app_code, is_custom_domain); [15, 16]

-- Index hỗ trợ quản lý danh sách Route của một Tenant
CREATE INDEX idx_routes_tenant_list 
ON tenant_app_routes (tenant_id, created_at DESC); [4]
```

3\. Phân tích kỹ thuật chuyên sâu

• **Tính duy nhất toàn cục (Global Uniqueness):** Ràng buộc `UNIQUE (domain, path_prefix)` cực kỳ quan trọng để ngăn chặn trường hợp hai Tenant khác nhau cùng đăng ký một địa chỉ, gây lỗi cho bộ định tuyến417.

• **Tối ưu hóa hiệu năng với Redis:** Dữ liệu từ bảng này nên được đồng bộ lên **Redis Hash Map** (với key là `domain + path_prefix`) để đạt tốc độ tra cứu micro-seconds tại tầng API Gateway, giảm tải cho YugabyteDB18....

• **Xử lý UUID v7:** Việc dùng UUID v7 giúp các bản ghi định tuyến mới (khi khách hàng mua thêm app/domain) được sắp xếp tuần tự theo thời gian, tránh hiện tượng "hotspot" khi ghi dữ liệu vào các Tablet trong hệ thống phân tán của YugabyteDB2122.

• **Tính nhất quán mạnh (Strong Consistency):** Khác với MongoDB thường có độ trễ đồng bộ nhất định, việc lưu bảng này tại YugabyteDB đảm bảo ngay khi Admin cấu hình domain mới, hệ thống sẽ ghi nhận và thực thi ngay lập tức, tránh các lỗi "Route ma"1723.

**Ví dụ minh họa:** Một Tenant công ty ABC có thể cấu hình `abc.saas.com/` trỏ về Portal chính, nhưng `hr.abc.com/` trỏ thẳng vào App HRM2425. API Gateway sẽ tra cứu bảng này đầu tiên để biết cần kiểm tra quyền hạn (Subscription) của gói phần mềm nào tiếp theo2526.



thiết kế chi tiết bảng tenant\_rate\_limits dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về kiến trúc hệ thống SaaS Enterprise và nhu cầu bảo vệ tài nguyên hệ thống khỏi vấn đề "Noisy Neighbor" (một khách hàng dùng quá nhiều tài nguyên ảnh hưởng khách hàng khác), bảng **tenant\_rate\_limits** được thiết kế để quản lý giới hạn tần suất gọi API (Throttling) ở cấp độ Tenant hoặc Gói dịch vụ12.

Việc sử dụng **UUID v7** làm khóa chính giúp tối ưu hóa hiệu năng ghi trong cụm YugabyteDB phân tán và đảm bảo các cấu hình mới được sắp xếp theo thời gian thực34.

1\. Thiết kế chi tiết bảng `tenant_rate_limits`

Bảng này tuân thủ các quy chuẩn về kiểu dữ liệu (TIMESTAMPTZ, UUID) và quy tắc đặt tên `snake_case` đã thống nhất trong các nguồn dữ liệu56.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**3. |
| **tenant\_id** | UUID | YES | `NULL` | `REFERENCES tenants(_id)` | Liên kết tới Tenant. Nếu NULL nghĩa là áp dụng cho Global hoặc Package2. |
| **package\_id** | UUID | YES | `NULL` | `REFERENCES packages(_id)` | Liên kết tới gói cước. Dùng để áp giới hạn theo gói (VD: Gói Free giới hạn thấp hơn)2. |
| **api\_group** | VARCHAR(50) | NO  |     | `CHECK (LENGTH(api_group) > 0)` | Nhóm API cần giới hạn (VD: `REPORTING_API`, `AUTH_API`, `CORE_API`)2. |
| **limit\_count** | INT | NO  |     | `CHECK (limit_count > 0)` | Số lượng request tối đa được phép2. |
| **window\_seconds** | INT | NO  | `60` | `CHECK (window_seconds > 0)` | Khoảng thời gian (giây) áp dụng giới hạn2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái hiệu lực của cấu hình7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo (UTC)6. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng6. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè đồng thời8. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Indexes)

Cấu trúc lệnh dưới đây đảm bảo tính nhất quán mạnh (ACID) của YugabyteDB và tối ưu hóa việc tra cứu cho API Gateway910.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_rate_limits (
    -- I. ĐỊNH DANH & LIÊN KẾT
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID,
    package_id UUID,
    
    -- II. CẤU HÌNH GIỚI HẠN
    api_group VARCHAR(50) NOT NULL,
    limit_count INT NOT NULL,
    window_seconds INT NOT NULL DEFAULT 60,
    
    -- III. TRẠNG THÁI & TRUY VẾT
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_rate_limit_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    -- Lưu ý: Cần bảng packages tồn tại trước
    -- CONSTRAINT fk_rate_limit_package FOREIGN KEY (package_id) REFERENCES packages(_id),
    
    -- Đảm bảo mỗi cặp Tenant + Nhóm API chỉ có 1 cấu hình giới hạn duy nhất
    CONSTRAINT uq_tenant_api_group UNIQUE (tenant_id, api_group),
    
    CONSTRAINT chk_limit_count CHECK (limit_count > 0),
    CONSTRAINT chk_window_seconds CHECK (window_seconds > 0),
    CONSTRAINT chk_api_group_name CHECK (LENGTH(api_group) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ API Gateway tra cứu cấu hình giới hạn cực nhanh
-- Query: SELECT limit_count, window_seconds FROM tenant_rate_limits WHERE tenant_id = ? AND api_group = ? AND is_active = TRUE;
CREATE INDEX idx_rate_limit_lookup 
ON tenant_rate_limits (tenant_id, api_group) 
WHERE is_active = TRUE;

-- Index hỗ trợ quản trị viên hệ thống lọc cấu hình theo gói cước
CREATE INDEX idx_rate_limit_package 
ON tenant_rate_limits (package_id) 
WHERE package_id IS NOT NULL;
```

Phân tích bổ sung về vận hành:

• **Tính kế thừa (Inheritance Logic):** Dựa trên cấu trúc bảng, API Gateway sẽ tra cứu theo thứ tự ưu tiên: Giới hạn riêng của **Tenant** > Giới hạn theo **Gói cước** > Giới hạn **Mặc định hệ thống** (nơi cả `tenant_id` và `package_id` đều NULL)2.

• **Chiến lược đồng bộ (Data Flow):** Theo triết lý "The Right Tool for the Right Job", dữ liệu cấu hình này được lưu tại YugabyteDB làm "nguồn sự thật" (Source of Truth), nhưng sau đó cần được đồng bộ lên **Redis**1112. API Gateway sẽ đọc từ Redis để thực hiện đếm (counting) và chặn request với tốc độ micro-seconds nhằm không làm tăng độ trễ của hệ thống1314.

• **Bảo mật & Hiệu năng:** Sử dụng `UUID v7` giúp tránh các vấn đề về phân mảnh dữ liệu (fragmentation) và giúp việc sắp xếp các cấu hình mới nhất trong trang quản trị trở nên đơn giản mà không cần thêm cột phụ34.

**Ví von để dễ hiểu:** Bảng `tenant_rate_limits` giống như một **"Hệ thống điều tiết vòi nước"** trong tòa nhà chung cư SaaS. Tòa nhà có một mức tổng (Global), mỗi tầng có một hạn mức (Package), và nếu một căn hộ cụ thể dùng quá nhiều (Tenant), hệ thống sẽ tự động bóp vòi của riêng căn hộ đó để đảm bảo áp suất nước cho toàn bộ cư dân khác không bị sụt giảm.



thiết kế chi tiết bảng oauth\_clients dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Bảng **oauth\_clients** đóng vai trò hạt nhân để biến hệ thống SaaS của bạn thành một **Identity Provider (IdP)** chuyên nghiệp (tương tự Google hay Okta)1. Việc thiết kế bảng này trên YSQL (YugabyteDB) với **UUID v7** đảm bảo khả năng mở rộng quy mô toàn cầu và hiệu suất truy vấn cao cho các ứng dụng bên thứ ba hoặc ứng dụng nội bộ23.

1\. Thiết kế chi tiết bảng `oauth_clients`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và sharding24. |
| **tenant\_id** | UUID | YES | `NULL` | `REFERENCES tenants(_id) ON DELETE CASCADE` | Xác định ứng dụng này thuộc về tổ chức nào (nếu là ứng dụng nội bộ)1. |
| **client\_id** | VARCHAR(64) | NO  |     | `UNIQUE` | Mã định danh công khai của ứng dụng dùng để nhận diện khi đăng nhập1. |
| **client\_secret\_hash** | TEXT | NO  |     |     | Bản băm bảo mật của mã bí mật (Secret Key). Tuyệt đối không lưu plain-text1. |
| **name** | TEXT | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của ứng dụng khách (Ví dụ: "Mobile App", "Portal")3. |
| **logo\_url** | TEXT | YES | `NULL` |     | URL ảnh đại diện của ứng dụng hiển thị trên màn hình xin quyền3. |
| **redirect\_uris** | TEXT\[\] | NO  |     |     | Mảng các URL được phép quay lại sau khi xác thực thành công để chống tấn công chuyển hướng35. |
| **allowed\_scopes** | TEXT\[\] | YES | `NULL` |     | Danh sách các quyền (scopes) mà ứng dụng này được phép yêu cầu (Ví dụ: `openid`, `profile`)35. |
| **is\_trusted** | BOOLEAN | NO  | `FALSE` |     | Nếu `TRUE`, hệ thống sẽ tự động phê duyệt mà không hiển thị màn hình hỏi ý kiến người dùng (Consent)35. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi chuẩn UTC36. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cấu hình gần nhất6. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Index)

Để đạt hiệu suất tối ưu cho các luồng xác thực OAuth2/OIDC, hệ thống cần truy xuất thông tin Client cực nhanh dựa trên `client_id`37.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE oauth_clients (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ phía Application
    tenant_id UUID,
    
    -- II. THÔNG TIN XÁC THỰC (OAuth2 Core)
    client_id VARCHAR(64) NOT NULL,
    client_secret_hash TEXT NOT NULL,
    
    -- III. THÔNG TIN HIỂN THỊ & CẤU HÌNH
    name TEXT NOT NULL,
    logo_url TEXT,
    redirect_uris TEXT[] NOT NULL,
    allowed_scopes TEXT[],
    is_trusted BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- IV. TRUY VẾT & AUDIT
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT uq_oauth_clients_client_id UNIQUE (client_id),
    CONSTRAINT fk_oauth_clients_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_oauth_name_len CHECK (LENGTH(name) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng nhất: Phục vụ việc kiểm tra Client khi bắt đầu luồng login
-- Sử dụng Covering Index để Gateway lấy thông tin mà không cần đọc bảng gốc
CREATE UNIQUE INDEX idx_oauth_clients_lookup 
ON oauth_clients (client_id) 
INCLUDE (client_secret_hash, redirect_uris, is_trusted);

-- Index hỗ trợ quản lý: Admin xem danh sách các ứng dụng thuộc Tenant
CREATE INDEX idx_oauth_clients_tenant 
ON oauth_clients (tenant_id, created_at DESC) 
WHERE tenant_id IS NOT NULL;
```

Phân tích kiến trúc chuyên sâu:

• **Mở rộng hệ sinh thái:** Thiết kế này cho phép bạn xây dựng một "App Directory" hoặc Marketplace, nơi các đối tác thứ ba có thể viết phần mềm bổ trợ và xin quyền truy cập dữ liệu của Tenant thông qua cơ chế OAuth2 chuẩn hóa38.

• **An ninh bảo mật:** Bằng cách sử dụng mảng `redirect_uris`, hệ thống ngăn chặn triệt để các cuộc tấn công chiếm đoạt Token bằng cách chuyển hướng đến trang web giả mạo3.

• **Hiệu năng Sharding:** Sử dụng UUID v7 cho khóa chính giúp YugabyteDB phân tán dữ liệu các Client đồng đều trên cụm máy chủ, tránh hiện tượng nghẽn cổ chai khi có hàng triệu ứng dụng kết nối29.

**Ví von:** Bảng `oauth_clients` giống như một **"Văn phòng cấp phép hộ chiếu"** cho các ứng dụng. Mỗi ứng dụng muốn nói chuyện với dữ liệu người dùng đều phải đăng ký một "hộ chiếu" (client\_id). Khi ứng dụng gõ cửa, hệ thống sẽ kiểm tra xem "hộ chiếu" đó có hợp lệ không và nó được phép đi vào những khu vực nào (scopes) trong tòa nhà SaaS của bạn38.



thiết kế chi tiết bảng webhooks dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Bảng **webhooks** đóng vai trò là cơ chế "Push" dữ liệu chủ động từ hệ thống SaaS sang các ứng dụng bên thứ ba của khách hàng1. Theo triết lý **Polyglot Persistence**, bảng này được lưu tại **YugabyteDB** vì yêu cầu tính nhất quán cao và quan hệ chặt chẽ với dữ liệu định danh của Tenant23.

Dưới đây là thiết kế chi tiết sử dụng **UUID v7** để tối ưu hóa hiệu năng ghi và sắp xếp theo thời gian trong môi trường phân tán45.

1\. Thiết kế chi tiết bảng `webhooks`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**4. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id) ON DELETE CASCADE` | Thuộc sở hữu của Tenant nào3. |
| **target\_url** | TEXT | NO  |     | `CHECK (target_url ~* '^https?://')` | URL đích nhận thông báo. Dùng `TEXT` để tránh giới hạn độ dài36. |
| **secret\_key** | TEXT | NO  |     |     | Dùng để ký (sign) payload, giúp bên nhận xác thực dữ liệu từ hệ thống3. |
| **subscribed\_events** | TEXT\[\] | NO  |     |     | Mảng danh sách các sự kiện đăng ký (VD: `['user.created', 'invoice.paid']`)3. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái hoạt động của Webhook3. |
| **failure\_count** | INT | NO  | `0` | `CHECK (failure_count >= 0)` | Số lần gửi lỗi liên tiếp. Nếu quá 10 lần, hệ thống tự động tắt (`is_active = FALSE`)3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo (UTC)78. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng8. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Cơ chế **Optimistic Locking** chống ghi đè đồng thời9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL để tạo bảng và chỉ mục (Indexes)

Dữ liệu cấu hình Webhook thường được truy vấn thường xuyên bởi các **Event Worker** mỗi khi có một sự kiện nghiệp vụ phát sinh.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE webhooks (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. CẤU HÌNH KỸ THUẬT
    target_url TEXT NOT NULL,
    secret_key TEXT NOT NULL,
    subscribed_events TEXT[] NOT NULL,
    
    -- III. TRẠNG THÁI VẬN HÀNH
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    failure_count INT NOT NULL DEFAULT 0,
    
    -- IV. AUDIT & VERSIONING
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- V. CÁC RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_webhook_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_webhook_url_fmt CHECK (target_url ~* '^https?://'),
    CONSTRAINT chk_webhook_fail_count CHECK (failure_count >= 0),
    CONSTRAINT chk_webhook_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ Event Worker tìm nhanh các webhook đang đăng ký một sự kiện cụ thể
-- Query: SELECT target_url, secret_key FROM webhooks WHERE is_active = TRUE AND 'user.created' = ANY(subscribed_events);
CREATE INDEX idx_webhooks_active_events 
ON webhooks USING GIN (subscribed_events) 
WHERE is_active = TRUE;

-- Index hỗ trợ Tenant quản lý danh sách Webhook của mình
CREATE INDEX idx_webhooks_tenant_list 
ON webhooks (tenant_id, created_at DESC);
```

3\. Phân tích bổ sung từ các nguồn dữ liệu

• **Xử lý dữ liệu lớn:** Nhật ký chi tiết của mỗi lần gửi Webhook (Response code, Payload, Thời gian phản hồi) không nên lưu ở bảng này mà nên đẩy vào **ClickHouse** (`webhook_delivery_logs`) để phục vụ phân tích và giúp khách hàng tự debug10.

• **Bảo mật:** Trường `secret_key` đóng vai trò quan trọng trong việc ký payload. Bên nhận sẽ dùng key này để tính toán mã HMAC và so sánh với header nhận được, đảm bảo dữ liệu không bị thay đổi trên đường truyền3.

• **Hiệu năng Sharding:** Sử dụng `UUID v7` giúp các cấu hình Webhook mới của các Tenant được phân bổ đều trên các Tablet của YugabyteDB, tránh hiện tượng nghẽn cổ chai khi có lượng lớn khách hàng cùng cấu hình Webhook một lúc5.

• **Độ tin cậy:** Kết hợp với **Outbox Pattern**, khi một sự kiện (như `TENANT_CREATED`) được ghi vào bảng `outbox_events`, một Worker sẽ đọc dữ liệu từ đó và tra cứu bảng `webhooks` này để bắn dữ liệu đi, đảm bảo không bỏ sót thông báo ngay cả khi hệ thống gặp sự cố mạng1112.

**Ví von:** Bảng `webhooks` giống như một **"Tổng đài chuyển tiếp tự động"**. Khi có một "tin tức" (sự kiện) mới xảy ra trong tòa nhà SaaS, tổng đài sẽ tra cứu danh sách những ai đã đăng ký nhận tin (`subscribed_events`) và chủ động gọi điện (`target_url`) để thông báo cho họ, kèm theo một "mật mã xác nhận" (`secret_key`) để người nghe biết chắc chắn đó là tin chính thống từ ban quản lý.



thiết kế chi tiết bảng api\_usage\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên triết lý **"Polyglot Persistence"** và các tiêu chuẩn thiết kế hệ thống SaaS Enterprise từ các nguồn tài liệu, bảng **api\_usage\_logs** được đặt tại **ClickHouse** để phục vụ bài toán dữ liệu lớn, phân tích hiệu năng và tính tiền theo mức sử dụng (Metering)1,2,3.

Việc sử dụng **UUID v7** giúp dữ liệu được sắp xếp tuần tự theo thời gian, tối ưu hóa việc ghi và truy vấn trong ClickHouse4,5.

1\. Thiết kế chi tiết bảng `api_usage_logs` (ClickHouse)

Bảng này được thiết kế để ghi lại mọi hành động tiêu dùng API, phục vụ việc tổng hợp dữ liệu sang YugabyteDB để tính hóa đơn (Billing) và kiểm soát giới hạn (Rate Limit)6,3.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**4,5. |
| **tenant\_id** | UUID | NO  |     |     | Định danh khách hàng sở hữu log7. |
| **app\_code** | String | NO  |     | `CHECK (length(app_code) > 0)` | Mã ứng dụng (VD: HRM, CRM, POS)8,7. |
| **api\_endpoint** | String | NO  |     |     | Đường dẫn API đã gọi8. |
| **api\_method** | Enum8(...) | NO  |     | `GET=1, POST=2, PUT=3, DELETE=4...` | Phương thức HTTP (Dùng Enum để nén dữ liệu)9,10. |
| **status\_code** | Int16 | NO  |     |     | Mã phản hồi HTTP (VD: 200, 401, 500)3. |
| **request\_size** | Int64 | NO  | `0` | `CHECK (request_size >= 0)` | Dung lượng request (bytes) để tính bandwidth3. |
| **response\_size** | Int64 | NO  | `0` | `CHECK (response_size >= 0)` | Dung lượng response (bytes) để tính bandwidth3. |
| **latency\_ms** | Int32 | NO  |     |     | Thời gian xử lý của API (mili giây)2. |
| **api\_key\_id** | Nullable(UUID) | YES | `NULL` |     | ID của API Key nếu dùng Machine-to-Machine11,12. |
| **created\_at** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm ghi log, độ chính xác mili-giây9,10. |

\--------------------------------------------------------------------------------

2\. Câu lệnh SQL tạo bảng và Index trong ClickHouse

Trong ClickHouse, chiến lược đánh chỉ mục quan trọng nhất nằm ở `ORDER BY` (Sorting Key). Chúng ta chọn `tenant_id` đứng đầu để tối ưu cho các truy vấn lọc dữ liệu theo từng khách hàng trong mô hình SaaS7.

```
-- 1. Câu lệnh tạo bảng api_usage_logs
CREATE TABLE api_usage_logs (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID,
    tenant_id UUID,
    app_code String,
    
    -- II. CHI TIẾT GIAO DỊCH API
    api_endpoint String,
    api_method Enum8(
        'GET' = 1, 
        'POST' = 2, 
        'PUT' = 3, 
        'DELETE' = 4, 
        'PATCH' = 5, 
        'OPTIONS' = 6
    ),
    status_code Int16,
    
    -- III. METRICS (Để tính tiền Bandwidth & Quota)
    request_size Int64 DEFAULT 0,
    response_size Int64 DEFAULT 0,
    latency_ms Int32,
    
    -- IV. TRUY VẾT XÁC THỰC
    api_key_id Nullable(UUID),
    
    -- V. THỜI GIAN
    created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng xóa dữ liệu cũ (Retention Policy) [2], [7]
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant trước, mã ứng dụng và thời gian sau [7]
ORDER BY (tenant_id, app_code, created_at, _id)
-- Cấu hình hạt nhân cho chỉ mục
SETTINGS index_granularity = 8192;

-- 2. Tạo Skipping Index (Bloom Filter) cho api_endpoint
-- Giúp tìm kiếm nhanh các endpoint cụ thể khi phân tích hiệu năng mà không cần quét toàn bảng
ALTER TABLE api_usage_logs 
ADD INDEX idx_endpoint_search api_endpoint TYPE bloom_filter(0.01) GRANULARITY 1;

-- 3. Tạo Skipping Index cho status_code
-- Phục vụ việc lọc nhanh các yêu cầu lỗi (status_code >= 400)
ALTER TABLE api_usage_logs 
ADD INDEX idx_status_code status_code TYPE minmax GRANULARITY 1;
```

3\. Giải thích các lựa chọn kỹ thuật dựa trên nguồn tài liệu

• **Metering & Billing:** Bảng này lưu trữ `request_size` và `response_size` để đáp ứng mô hình tính tiền dựa trên lượng dùng thực tế (Usage-based Pricing)13,6. Một Worker sẽ chạy định kỳ để query từ bảng này trong ClickHouse và "bơm" kết quả tổng hợp sang bảng `tenant_usages` ở YugabyteDB6,14.

• **Hiệu năng nén:** Việc sử dụng `Enum8` cho `api_method` giúp ClickHouse nén dữ liệu cực tốt (tỷ lệ 10:1), tiết kiệm đáng kể chi phí ổ cứng khi lưu trữ hàng tỷ dòng log2,10.

• **Tính nhất quán cuối cùng (Eventual Consistency):** Theo nguồn tài liệu, không nên dùng ứng dụng ghi trực tiếp vào ClickHouse (Dual Write). Thay vào đó, dữ liệu có thể được đẩy qua **Kafka + Debezium (CDC)** hoặc ghi log dạng file rồi dùng công cụ đẩy vào ClickHouse để đảm bảo hệ thống không bị chậm khi tải cao15,16.

**Ví dụ phân tích:** Khi cần tính tổng dung lượng bandwidth của Tenant A trong tháng 1, hệ thống chỉ cần quét các cột `request_size` và `response_size` trong phân vùng (Partition) của tháng đó, giúp trả về kết quả trong vài mili giây thay vì vài phút như các DB truyền thống2,17.



thiết kế chi tiết bảng webhook\_delivery\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên kiến trúc hệ thống SaaS quy mô lớn và triết lý **Polyglot Persistence**, bảng **webhook\_delivery\_logs** được đặt tại **ClickHouse** để đảm bảo khả năng lưu trữ hàng tỷ bản ghi lịch sử gửi tin mà không làm chậm hệ thống giao dịch chính (YugabyteDB)1,2.

Bảng này đóng vai trò là "hệ thống đối soát" giúp khách hàng tự kiểm tra (debug) xem dữ liệu đã được bắn đi thành công hay thất bại, phản hồi từ phía họ là gì3. Việc sử dụng **UUID v7** giúp dữ liệu log được sắp xếp tự nhiên theo thời gian, tối ưu hóa hiệu suất ghi (Insert)4,5.

1\. Thiết kế chi tiết bảng `webhook_delivery_logs` (ClickHouse)

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian4. |
| **tenant\_id** | UUID | NO  |     |     | ID tổ chức sở hữu webhook (Dùng để phân vùng truy vấn)6. |
| **webhook\_id** | UUID | NO  |     |     | Tham chiếu đến cấu hình webhook gốc tại YugabyteDB7. |
| **event\_type** | String | NO  |     |     | Loại sự kiện (Ví dụ: `user.created`, `invoice.paid`)7. |
| **target\_url** | String | NO  |     | `CHECK (target_url ~* '^https?://')` | URL đích nhận dữ liệu7. |
| **payload** | String | NO  |     |     | Nội dung dữ liệu (JSON) đã gửi đi3. |
| **response\_body** | String | YES | `NULL` |     | Nội dung phản hồi từ hệ thống của khách hàng3. |
| **status\_code** | Int16 | NO  |     |     | Mã trạng thái HTTP trả về (Ví dụ: 200, 404, 500)8. |
| **is\_success** | Bool | NO  |     |     | Trạng thái gửi thành công hay thất bại9. |
| **latency\_ms** | Int32 | NO  |     |     | Thời gian xử lý của phía khách hàng (mili giây)2. |
| **attempt\_number** | Int8 | NO  | `1` |     | Số lần thử lại (Retry) cho sự kiện này7. |
| **created\_at** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm thực hiện gửi tin (Chính xác đến ms)9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh tạo bảng và Index trong ClickHouse

Để tối ưu cho mô hình SaaS đa khách hàng, chúng ta sắp xếp dữ liệu theo `tenant_id` trước, sau đó mới đến thời gian. Điều này giúp khi một khách hàng vào Dashboard xem log, ClickHouse chỉ cần quét một vùng dữ liệu rất nhỏ trên ổ đĩa2,10.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE webhook_delivery_logs (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID,
    tenant_id UUID,
    webhook_id UUID,

    -- II. CHI TIẾT GỬI TIN
    event_type String,
    target_url String,
    payload String,
    response_body String,
    
    -- III. KẾT QUẢ VẬN HÀNH
    status_code Int16,
    is_success Bool,
    latency_ms Int32,
    attempt_number Int8 DEFAULT 1,

    -- IV. THỜI GIAN
    created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng xóa log cũ (Retention Policy) [2]
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo Tenant và Thời gian để phục vụ truy vấn Dashboard SaaS nhanh nhất [10]
ORDER BY (tenant_id, created_at, _id)
-- Cấu hình hạt nhân cho chỉ mục
SETTINGS index_granularity = 8192;

-- 2. CHIẾN LƯỢC ĐÁNH INDEX BỔ SUNG (SKIPPING INDEX)

-- Index giúp tìm kiếm nhanh các log liên quan đến một Webhook cụ thể trong hàng tỷ bản ghi
ALTER TABLE webhook_delivery_logs 
ADD INDEX idx_webhook_lookup webhook_id TYPE bloom_filter(0.01) GRANULARITY 1;

-- Index hỗ trợ lọc nhanh các yêu cầu bị lỗi (status_code >= 400) để bắn cảnh báo [2]
ALTER TABLE webhook_delivery_logs 
ADD INDEX idx_status_code status_code TYPE minmax GRANULARITY 1;

-- Index hỗ trợ tìm kiếm theo URL đích nếu khách hàng dùng nhiều endpoint
ALTER TABLE webhook_delivery_logs 
ADD INDEX idx_url_search target_url TYPE tokenbf_v1(4096, 2, 0) GRANULARITY 1;
```

3\. Giải thích các lựa chọn kỹ thuật

• **UUID v7 làm Khóa chính:** ClickHouse hoạt động cực tốt với dữ liệu chèn theo thứ tự thời gian. UUID v7 mang đặc tính này, giúp tránh việc phân mảnh ổ đĩa và tăng tốc độ ghi dữ liệu4.

• **Lưu Payload và Response Body dạng String:** Mặc dù ClickHouse hỗ trợ JSON, nhưng việc lưu dạng String (đã nén) thường ổn định hơn cho các log có cấu trúc payload thay đổi liên tục tùy theo loại sự kiện8.

• **Cơ chế Phân vùng (Partitioning):** Do dữ liệu webhook log rất lớn, chúng ta chia nhỏ theo tháng. Khi cần xóa log cũ hơn 1 năm để tiết kiệm dung lượng, hệ thống chỉ cần xóa các "Partition" tương ứng thay vì chạy lệnh DELETE tốn kém2.

**Sự ví von:** Bảng `webhook_delivery_logs` giống như **"Nhật ký của một nhân viên đưa thư"**. Nó ghi lại chi tiết: ai gửi, gửi đi đâu, gói hàng là gì, người nhận có ký nhận không (status code) và mất bao lâu để giao hàng. Nếu khách hàng báo "tôi chưa nhận được tin", bạn chỉ cần mở cuốn nhật ký này ra là thấy ngay bằng chứng xác thực.



liệt kê các bảng log của phần Identity & Security

Dựa trên các nguồn tài liệu về kiến trúc hệ thống Enterprise SaaS và triết lý "Polyglot Persistence", các bảng log (nhật ký) của phần Identity & Security thường được ưu tiên lưu trữ tại **ClickHouse** (CSDL phân tích - OLAP) để xử lý khối lượng dữ liệu khổng lồ, chỉ ghi thêm (append-only) và tối ưu hóa hiệu năng truy vấn báo cáo1....

Dưới đây là danh sách chi tiết các bảng log thuộc nhóm tính năng Định danh và Bảo mật:

1\. Nhóm nhật ký An ninh và Truy vết (Security & Audit)

Đây là các bảng quan trọng nhất để trả lời câu hỏi "Ai đã làm gì, vào lúc nào và ở đâu?" phục vụ mục đích tuân thủ (Compliance) và tra soát bảo mật34.

• **audit\_logs** **(Nhật ký kiểm tra hệ thống):** Lưu vết toàn bộ các hành động thay đổi dữ liệu của người dùng trên hệ thống34. Đặc biệt, bảng này trong mô hình Enterprise sẽ bao gồm trường `impersonator_id` để ghi lại định danh của nhân viên hỗ trợ nếu họ đang sử dụng tính năng "Impersonation" (giả danh khách hàng) để xử lý sự cố5....

• **security\_audit\_logs** **(Nhật ký an ninh lõi):** Tập trung vào các sự kiện an ninh cấp độ hệ thống như: đăng nhập thất bại, gán vai trò (role) cho người dùng, tạo API Key, hoặc thay đổi chính sách bảo mật8.

• **auth\_logs** **(Nhật ký xác thực):** Lưu trữ lịch sử chi tiết của mọi lần thử đăng nhập, bao gồm email sử dụng, địa chỉ IP, User Agent, phương thức xác thực (Mật khẩu, Google, SSO) và lý do thất bại cụ thể như sai mật khẩu, sai mã MFA hoặc tài khoản bị khóa910. Dữ liệu này thường được phân vùng (partition) theo tháng để tối ưu việc xóa log cũ11.

• **login\_risk\_logs** **(Nhật ký rủi ro đăng nhập):** Lưu trữ kết quả đánh giá rủi ro của hệ thống xác thực thích ứng (Adaptive Auth), ghi nhận các yếu tố như đăng nhập từ IP lạ hoặc di chuyển bất thường (impossible travel)1213.

2\. Nhóm nhật ký Vận hành và Sử dụng (Usage & Operational)

Các bảng này phục vụ việc giám sát hiệu năng hệ thống và tính tiền dựa trên mức sử dụng (Metering/Billing)314.

• **api\_usage\_logs** **hoặc** **usage\_events** **(Nhật ký sử dụng API):** Ghi lại số lượng request, dung lượng băng thông (bandwidth) và các hành động tiêu dùng tài nguyên của từng Tenant14.... Dữ liệu này sẽ được tổng hợp theo định kỳ để tính hóa đơn1718.

• **webhook\_delivery\_logs** **(Nhật ký gửi Webhook):** Theo dõi lịch sử hệ thống bắn thông báo sang ứng dụng của khách hàng, bao gồm URL đích, nội dung payload, mã trạng thái phản hồi (HTTP status) và nội dung phản hồi từ phía khách hàng để họ tự debug1920.

• **http\_events** **(Sự kiện HTTP):** Lưu trữ thô (raw) các yêu cầu và phản hồi HTTP để phục vụ việc tìm lỗi (debug) hoặc phân tích hiệu năng sâu14.

3\. Nhóm nhật ký Thay đổi Dữ liệu và Tài chính (Data & Financial Logs)

Khác với các nhóm trên, nhóm này thường được lưu trữ tại **YugabyteDB** (SQL phân tán) để đảm bảo tính nhất quán tuyệt đối và quan hệ chặt chẽ với các thực thể nghiệp vụ121.

• **entity\_change\_history** **(Lịch sử thay đổi thực thể):** Lưu lại sự khác biệt (Diff) của từng lần cập nhật các trường dữ liệu quan trọng (ví dụ: thay đổi lương cơ bản từ 10tr lên 12tr), cho phép xem lại dòng thời gian thay đổi của một đối tượng cụ thể2223.

• **wallet\_transactions** **(Nhật ký giao dịch ví):** Lưu trữ mọi biến động số dư trong ví tín dụng của Tenant. Bảng này mang tính bất biến (Immutable), chỉ được phép thêm mới bản ghi mà không được sửa xóa để đảm bảo đối soát tài chính chính xác2425.

• **outbox\_events** **(Nhật ký sự kiện đầu ra):** Lưu các sự kiện nghiệp vụ (như "Tenant đã tạo") ngay trong cùng một giao dịch (transaction) với dữ liệu chính để đảm bảo sau đó sự kiện sẽ được bắn sang Kafka một cách tin cậy, tránh mất dữ liệu2627.

**Sự ví von:** Nếu hệ thống SaaS của bạn là một ngân hàng, thì các bảng nghiệp vụ chính là **"Sổ cái"**, còn các bảng log này đóng vai trò như **"Hệ thống Camera an ninh"** và **"Băng ghi âm tổng đài"**. Chúng không trực tiếp thực hiện giao dịch, nhưng là bằng chứng duy nhất để tra soát khi có sự cố hoặc để hiểu rõ thói quen của khách hàng328.



bảng wallet\_transactions nên lưu vào clickhouse hay yugabytedb ?

Dựa trên các quy tắc thiết kế hệ thống SaaS và triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) từ các nguồn tài liệu, bảng **wallet\_transactions** nên được lưu trữ tại **YugabyteDB**1,2.

Dưới đây là các lý do chi tiết và phân tích kỹ thuật giải thích tại sao YugabyteDB là lựa chọn tối ưu cho loại dữ liệu này so với ClickHouse:

1\. Đảm bảo tính toàn vẹn dữ liệu tuyệt đối (ACID)

• **Két sắt an toàn:** YugabyteDB được thiết kế làm "Core Transactional Database" (CSDL giao dịch lõi) dành cho các dữ liệu quan trọng (Critical Data) yêu cầu tính đúng đắn tuyệt đối3,2.

• **Tránh rủi ro tài chính:** Theo quy tắc thiết kế, nếu một dữ liệu mà khi sai hoặc lệch (như số tiền) có thể dẫn đến việc "mất tiền hoặc đi tù", thì dữ liệu đó bắt buộc phải nằm ở YugabyteDB4. Giao dịch ví tiền (`wallet_transactions`) trực tiếp ảnh hưởng đến tài sản của khách hàng, nên không thể chấp nhận bất kỳ sự sai sót nào.

2\. Khả năng nhất quán mạnh (Strong Consistency)

• **Cập nhật tức thời:** YugabyteDB đảm bảo khi một giao dịch ví vừa thực hiện xong, số dư mới phải được ghi nhận đồng nhất ngay lập tức trên tất cả các node trong hệ thống phân tán2.

• **Giao dịch phức tạp:** Trong kịch bản người dùng thanh toán gói cước, hệ thống cần thực hiện một giao dịch bao gồm nhiều bước: trừ tiền trong bảng ví, cập nhật trạng thái gói cước và tạo bản ghi hóa đơn5. YugabyteDB hỗ trợ các giao dịch phân tán (Distributed ACID) để đảm bảo hoặc là tất cả các bước thành công, hoặc là không có bước nào được thực thi6,5.

3\. Đặc tính kỹ thuật của bảng `wallet_transactions`

• **Kiểu dữ liệu chính xác:** Dữ liệu tiền tệ trong bảng này yêu cầu kiểu `NUMERIC(19, 4)` để đảm bảo độ chính xác đến 4 số lẻ, một thế mạnh của YugabyteDB7,8.

• **Tính bất biến (Immutable):** Mặc dù bảng này tuân theo nguyên tắc chỉ được `INSERT` (không bao giờ `UPDATE` hoặc `DELETE`), nó vẫn cần nằm trong hệ sinh thái quan hệ chặt chẽ với các bảng như `users`, `tenants` và `subscriptions` vốn đã nằm sẵn ở YugabyteDB để phục vụ các truy vấn tài chính phức tạp (JOIN, GROUP BY)2,6,9.

4\. Tại sao không chọn ClickHouse cho bảng này?

• **Mục đích sử dụng khác biệt:** ClickHouse là CSDL phân tích (OLAP), phù hợp cho dữ liệu lớn, chỉ ghi thêm như nhật ký truy cập (`access_logs`), nhật ký kiểm tra (`audit_logs`) hoặc các báo cáo thống kê1,6.

• **Tính nhất quán cuối cùng:** ClickHouse thường ưu tiên tốc độ ghi và nén dữ liệu hơn là tính nhất quán tức thời (Strong Consistency). Nếu dùng ClickHouse để lưu giao dịch ví, có thể xảy ra độ trễ khiến người dùng đã bị trừ tiền nhưng số dư hiển thị chưa cập nhật ngay, gây hoang mang và thiếu tin cậy2,10.

Tổng kết lựa chọn

| Đặc điểm | YugabyteDB (Lựa chọn ưu tiên) | ClickHouse (Không nên dùng) |
| --- | --- | --- |
| **Loại dữ liệu** | Giao dịch tài chính, số dư ví2. | Nhật ký, báo cáo, dữ liệu lớn1. |
| **Tính nhất quán** | Nhất quán mạnh (Strong Consistency)2. | Nhất quán cuối cùng (Eventual Consistency)10. |
| **Ràng buộc** | Khóa ngoại, ACID, quan hệ chặt chẽ3. | Append-only, nén cao, không khóa ngoại6. |

**Lời khuyên:** Bạn nên dùng YugabyteDB làm "nguồn sự thật" (Source of Truth) cho bảng `wallet_transactions` để đảm bảo an toàn tài chính2. Nếu sau này cần phân tích xu hướng tiêu dùng từ hàng tỷ giao dịch cũ, bạn có thể dùng **Kafka + Debezium (CDC)** để đồng bộ dữ liệu từ YugabyteDB sang ClickHouse nhằm phục vụ mục đích báo cáo chuyên sâu mà không làm ảnh hưởng đến hiệu năng giao dịch11,10.

\--------------------------------------------------------------------------------

**Sự ví von:** YugabyteDB giống như một **"Cuốn sổ cái của ngân hàng"**, nơi mỗi dòng ghi chép phải chính xác từng xu và không được phép sai lệch. Trong khi đó, ClickHouse giống như một **"Thư viện lưu trữ khổng lồ"**, nơi bạn cất giữ hàng triệu tờ báo cũ để sau này tra cứu xu hướng, nhưng không ai dùng thư viện để quản lý số dư tài khoản ngân hàng thực tế cả.



thiết kế chi tiết bảng audit\_logs dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên triết lý **"Polyglot Persistence"** và các tiêu chuẩn thiết kế hệ thống SaaS Enterprise, bảng **audit\_logs** được đặt tại **ClickHouse** để tối ưu hóa việc lưu trữ hàng tỷ bản ghi với khả năng nén cực tốt (tỷ lệ 10:1) và tốc độ truy vấn tổng hợp vượt trội1,2,3.

Việc sử dụng **UUID v7** cho khóa chính giúp đảm bảo các bản ghi được sắp xếp tuần tự theo thời gian ngay từ mức lưu trữ vật lý, cực kỳ hiệu quả cho các dòng dữ liệu log4,5.

1\. Thiết kế chi tiết bảng `audit_logs` (ClickHouse)

Bảng này được thiết kế để trả lời đầy đủ các câu hỏi về an ninh: **Ai (User/Impersonator)** đã làm **gì (Action)**, trên **đối tượng nào (Resource)**, vào **lúc nào (Time)** và từ **đâu (IP/Device)**3,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**4,7. |
| **tenant\_id** | UUID | NO  |     |     | Định danh khách hàng (Dùng để lọc dữ liệu theo Tenant)8,9. |
| **user\_id** | UUID | NO  |     |     | ID của người dùng thực hiện hành động6. |
| **impersonator\_id** | UUID | YES | `NULL` |     | ID nhân viên Support nếu đang sử dụng tính năng "Impersonation"10,11. |
| **event\_time** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm xảy ra sự kiện, chính xác đến mili giây12,7. |
| **action** | String | NO  |     | `CHECK (length(action) > 0)` | Loại hành động (VD: `UPDATE_SALARY`, `DELETE_USER`)10,11. |
| **resource** | String | NO  |     |     | Tên thực thể bị tác động (VD: `employees`, `invoices`)10,11. |
| **resource\_id** | String | YES | `NULL` |     | ID của bản ghi cụ thể bị tác động. |
| **details** | String | YES | `NULL` |     | Lưu snapshot thay đổi (thường là JSON lưu Diff cũ/mới)7,13. |
| **ip\_address** | String | NO  |     |     | Địa chỉ IP của người thực hiện13. |
| **user\_agent** | String | YES | `NULL` |     | Thông tin trình duyệt và thiết bị13. |
| **status** | Enum8(...) | NO  | `'SUCCESS'` | `'SUCCESS'=1, 'FAILED'=2` | Trạng thái thực hiện hành động12,7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh SQL tạo bảng và Chỉ mục (Index)

Trong ClickHouse, "Index" thực tế được quyết định bởi cấu trúc `ORDER BY`. Chúng ta sử dụng chiến lược sắp xếp theo `tenant_id` trước để tối ưu cho mô hình SaaS đa khách hàng9.

```
-- 1. Câu lệnh tạo bảng audit_logs
CREATE TABLE audit_logs (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID,
    tenant_id UUID,
    user_id UUID,
    impersonator_id Nullable(UUID),
    
    -- II. CHI TIẾT SỰ KIỆN
    event_time DateTime64(3) DEFAULT now(),
    action String,
    resource String,
    resource_id Nullable(String),
    details String,
    
    -- III. CONTEXT & SECURITY
    ip_address String,
    user_agent String,
    status Enum8('SUCCESS' = 1, 'FAILED' = 2) DEFAULT 'SUCCESS'
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng xóa log cũ (Retention Policy) [9], [14]
PARTITION BY toYYYYMM(event_time)
-- Sắp xếp theo Tenant và Thời gian để tối ưu truy vấn tra soát [9], [11]
ORDER BY (tenant_id, event_time, _id)
-- Cấu hình hạt nhân cho chỉ mục
SETTINGS index_granularity = 8192;

-- 2. Tạo Skipping Index cho trường 'action'
-- Giúp tìm kiếm nhanh các hành động cụ thể trong hàng tỷ bản ghi mà không cần quét toàn bảng
ALTER TABLE audit_logs 
ADD INDEX idx_action_search action TYPE bloom_filter(0.01) GRANULARITY 1;

-- 3. Tạo Skipping Index cho trường 'user_id'
-- Giúp tra soát lịch sử của một nhân viên cụ thể nhanh hơn
ALTER TABLE audit_logs 
ADD INDEX idx_user_search user_id TYPE minmax GRANULARITY 1;
```

3\. Phân tích kỹ thuật và Lý do thiết kế

• **Tối ưu hóa Sharding:** Bằng cách đưa `tenant_id` vào đầu chuỗi `ORDER BY`, ClickHouse sẽ gom nhóm dữ liệu của cùng một khách hàng lại gần nhau trên ổ đĩa. Khi Admin của khách hàng xem log, hệ thống chỉ cần đọc một phân đoạn dữ liệu rất nhỏ, giúp phản hồi cực nhanh9,14.

• **Tính minh bạch (Compliance):** Cột `impersonator_id` là bắt buộc cho chuẩn Enterprise. Nó cho phép doanh nghiệp biết rõ hành động đó là do nhân viên của họ làm hay do nhân viên Support của nhà cung cấp SaaS thực hiện nhân danh họ6,11.

• **Lưu trữ thông minh:** Sử dụng `DateTime64(3)` để đảm bảo thứ tự các hành động xảy ra gần nhau không bị đảo lộn7. Kiểu `Enum8` cho `status` giúp tiết kiệm dung lượng đáng kể so với lưu chuỗi `String` truyền thống12,7.

• **Khả năng mở rộng:** Cột `details` dùng kiểu `String` thay vì `JSONB` trong ClickHouse để đạt hiệu suất nén cao nhất. Dữ liệu này có thể được truy vấn bằng các hàm chuyên dụng như `JSONExtract` khi cần phân tích sâu7.

**Sự ví von:** Bảng `audit_logs` giống như một **"Hộp đen máy bay"**. Nó ghi lại mọi thông số kỹ thuật và hành động của phi hành đoàn một cách bất biến. Khi có sự cố (tranh chấp dữ liệu), đây là bằng chứng duy nhất và cuối cùng để xác định nguyên nhân mà không ai có thể sửa đổi được15,16.



outbox\_events nên lưu vào YugabyteDB hay ClickHouse?

Dựa trên các quy tắc kiến trúc và triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) từ các nguồn tài liệu, bảng **outbox\_events** bắt buộc phải được lưu tại **YugabyteDB**1,2,3.

Dưới đây là các phân tích chi tiết và lý do kỹ thuật tại sao YugabyteDB là lựa chọn duy nhất đúng đắn cho bảng này:

1\. Đảm bảo tính nhất quán giao dịch (Transactional ACID)

• **Nguyên lý cốt lõi:** Bảng `outbox_events` là thành phần then chốt của mô hình **Transactional Outbox Pattern**. Mục đích của nó là đảm bảo rằng một sự kiện (event) chỉ được ghi lại **nếu và chỉ nếu** giao dịch nghiệp vụ chính (như tạo Tenant hoặc cập nhật Gói cước) thành công4,2.

• **Giao dịch nguyên tử:** YugabyteDB hỗ trợ giao dịch phân tán (Distributed ACID)5,6. Điều này cho phép ứng dụng thực hiện việc ghi dữ liệu nghiệp vụ và ghi sự kiện vào bảng `outbox_events` trong **cùng một transaction**2. Nếu việc ghi dữ liệu nghiệp vụ thất bại, sự kiện cũng sẽ không được ghi, tránh tình trạng hệ thống phát đi những thông báo sai lệch2,7.

2\. Tránh rủi ro "Ghi kép" (Dual Write)

• Nguồn tài liệu nhấn mạnh việc tránh để ứng dụng tự ghi đồng thời vào hai hệ thống (ví dụ: ghi vào DB và bắn tin sang Kafka) vì rất dễ xảy ra lỗi một bên thành công, một bên thất bại4,8.

• Việc lưu `outbox_events` tại YugabyteDB giúp ứng dụng chỉ cần tập trung vào việc ghi vào một nguồn sự thật duy nhất (Single Source of Truth)4. Sau đó, một Worker hoặc công cụ CDC (như Debezium) sẽ đọc từ bảng này để đẩy sang Kafka một cách tin cậy9,2.

3\. Yêu cầu về tính nhất quán mạnh (Strong Consistency)

• **YugabyteDB** cung cấp tính nhất quán mạnh, đảm bảo ngay sau khi transaction commit, dữ liệu sự kiện đã sẵn sàng để các tiến trình phía sau xử lý5.

• Ngược lại, **ClickHouse** là cơ sở dữ liệu phân tích (OLAP), được thiết kế cho dữ liệu lớn, chỉ ghi thêm (append-only) và thường ưu tiên hiệu năng truy vấn hơn là tính nhất quán giao dịch tức thời6,10. ClickHouse không hỗ trợ các giao dịch ACID đa bảng cần thiết để thực hiện Outbox Pattern một cách an toàn10,4.

4\. Vị trí trong kiến trúc hệ thống

• Trong phân tầng dữ liệu, `outbox_events` nằm ở **Tier 2 (Core Transactional Database)** cùng với các bảng định danh (users, tenants) và tài chính (billing)5,3.

• Dữ liệu từ YugabyteDB sau khi được xử lý qua Kafka có thể được đẩy vào **ClickHouse** để lưu trữ dưới dạng nhật ký lâu dài (ví dụ: `audit_logs` hoặc `webhook_delivery_logs`), nhưng bản thân bảng điều phối sự kiện ban đầu phải nằm ở YugabyteDB9,7.

**Sự ví von:** Bảng `outbox_events` giống như **"Cuống biên lai"** trong một quyển sổ hóa đơn. Khi bạn viết một hóa đơn bán hàng (dữ liệu nghiệp vụ), bạn đồng thời để lại một cuống biên lai trong sổ (outbox event). Nếu bạn xé tờ hóa đơn đó đi vì viết sai, cuống biên lai cũng không tồn tại. YugabyteDB đóng vai trò là "quyển sổ đóng gáy" giữ cho hai thứ này luôn đi liền với nhau, trong khi ClickHouse giống như một "thùng hồ sơ lưu trữ" dùng để cất giữ hàng triệu biên lai cũ sau khi việc bán hàng đã hoàn tất5,10,2.



thiết kế chi tiết bảng outbox\_events dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Bảng **outbox\_events** là thành phần then chốt trong mô hình **Transactional Outbox Pattern**, giúp đảm bảo tính nhất quán tuyệt đối giữa dữ liệu nghiệp vụ và các sự kiện được bắn ra hệ thống bên ngoài (như Kafka)1,2. Việc lưu bảng này tại **YugabyteDB** cho phép hệ thống ghi dữ liệu nghiệp vụ và sự kiện vào cùng một giao dịch (transaction) ACID duy nhất2.

1\. Thiết kế chi tiết bảng `outbox_events`

Sử dụng **UUID v7** giúp các sự kiện được sắp xếp tuần tự theo thời gian phát sinh, tối ưu hóa việc quét dữ liệu cho các Worker xử lý sự kiện3,2.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sharding và sắp xếp thời gian4,3. |
| **tenant\_id** | UUID | NO  |     | `REFERENCES tenants(_id)` | Xác định sự kiện thuộc về khách hàng nào để hỗ trợ lọc và phân mảnh dữ liệu5,6. |
| **aggregate\_type** | VARCHAR(50) | NO  |     | `CHECK (length(aggregate_type) > 0)` | Loại thực thể phát sinh sự kiện (VD: `TENANT`, `USER`, `ORDER`)2. |
| **aggregate\_id** | UUID | NO  |     |     | ID của bản ghi nghiệp vụ cụ thể vừa thay đổi2. |
| **event\_type** | VARCHAR(50) | NO  |     |     | Tên hành động cụ thể (VD: `TENANT_CREATED`, `PLAN_UPGRADED`)7. |
| **payload** | JSONB | NO  | `'{}'` |     | Dữ liệu snapshot của thực thể tại thời điểm phát sinh sự kiện để các service khác xử lý8,7. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (status IN ('PENDING', 'PUBLISHED', 'FAILED'))` | Trạng thái xử lý của sự kiện bởi Event Worker7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm sự kiện được tạo ra (chuẩn UTC)9,7. |
| **published\_at** | TIMESTAMPTZ | YES | `NULL` |     | Thời điểm sự kiện đã được đẩy thành công sang Kafka7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và chỉ mục (Index)

Để Worker có thể quét nhanh các sự kiện chưa xử lý mà không làm ảnh hưởng đến hiệu năng chung của cụm DB, chúng ta sử dụng **Partial Index** lọc theo trạng thái `PENDING`7.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE outbox_events (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ tầng Application
    tenant_id UUID NOT NULL,
    
    -- II. CHI TIẾT SỰ KIỆN (EVENT SPEC)
    aggregate_type VARCHAR(50) NOT NULL,
    aggregate_id UUID NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    
    -- III. DỮ LIỆU & TRẠNG THÁI
    payload JSONB NOT NULL DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    
    -- IV. TRUY VẾT THỜI GIAN
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    published_at TIMESTAMPTZ,

    -- V. RÀNG BUỘC (CONSTRAINTS)
    CONSTRAINT fk_outbox_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_outbox_status CHECK (status IN ('PENDING', 'PUBLISHED', 'FAILED')),
    CONSTRAINT chk_aggregate_type CHECK (LENGTH(aggregate_type) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng nhất: Dùng cho Worker quét các sự kiện chưa bắn (Partial Index)
-- Giúp tìm nhanh những gì cần làm mà không phải quét toàn bộ bảng triệu dòng.
CREATE INDEX idx_outbox_pending_events 
ON outbox_events (created_at ASC) 
WHERE status = 'PENDING';

-- Index hỗ trợ tra soát (Audit): Tìm lịch sử sự kiện theo Tenant hoặc một đối tượng cụ thể
CREATE INDEX idx_outbox_audit_lookup 
ON outbox_events (tenant_id, aggregate_type, aggregate_id);
```

3\. Phân tích bổ sung từ kiến trúc nguồn

• **Tính nhất quán tuyệt đối:** Bằng cách đặt bảng này trong cùng database **YugabyteDB** với dữ liệu nghiệp vụ, bạn tránh được lỗi "ghi kép" (Dual Write) - nơi dữ liệu nghiệp vụ đã lưu nhưng sự kiện gửi đi bị thất bại do lỗi mạng10,2.

• **Hiệu năng ghi phân tán:** Sử dụng UUID v7 đảm bảo dữ liệu sự kiện mới được chèn vào theo thứ tự thời gian nhưng vẫn được phân bổ đều qua các tablet server của YugabyteDB, tránh hiện tượng "Hotspot" khi ghi tải cao3,11.

• **Vòng đời dữ liệu:** Vì đây là bảng trung chuyển, sau khi trạng thái chuyển sang `PUBLISHED`, dữ liệu có thể được xóa định kỳ hoặc đẩy sang **ClickHouse** để lưu trữ lịch sử lâu dài nhằm giữ cho bảng `outbox_events` luôn nhẹ12,13.

Bảng **outbox\_events** giống như một **"Cuống biên lai"** trong quyển sổ hóa đơn. Khi bạn viết một hóa đơn bán hàng (dữ liệu nghiệp vụ), bạn đồng thời tạo ra một cuống biên lai nằm lại trong sổ. Nếu tờ hóa đơn bị xé bỏ vì viết sai (Rollback), cuống biên lai cũng không tồn tại. Điều này đảm bảo rằng mọi thông tin gửi đi cho các bộ phận khác luôn khớp 100% với những gì thực sự đã xảy ra14.



thống kê truy cập, thống kê đăng nhập hay thống kê người dùng đăng ký mới thì lưu vào đâu?

Dựa trên triết lý kiến trúc **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) được đề cập trong các nguồn tài liệu, việc lưu trữ các loại dữ liệu thống kê này sẽ được phân chia dựa trên đặc tính truy cập và mục đích sử dụng của chúng1,2.

Dưới đây là phân tích chi tiết về nơi lưu trữ cho từng loại thống kê bạn đã nêu:

1\. Thống kê truy cập (Access Statistics) và Thống kê đăng nhập (Login Statistics)

Cả hai loại dữ liệu này đều thuộc nhóm **Dữ liệu Lớn / Analytics (Cold/Warm Data)**1,3.

• **Nơi lưu trữ:** **ClickHouse**1,4.

• **Lý do kỹ thuật:**

    ◦ **Khối lượng cực lớn:** Nhật ký truy cập (Access Logs) và nhật ký xác thực (Auth Logs) có thể lên tới hàng tỷ bản ghi mỗi năm4,5. ClickHouse có khả năng nén dữ liệu cực tốt (tỷ lệ 10:1), giúp tiết kiệm chi phí lưu trữ đáng kể so với các DB truyền thống4.    ◦ **Tốc độ tổng hợp (Aggregation):** Khi cần tính toán các chỉ số như "Số lượt truy cập trung bình mỗi giờ" hay "Tỷ lệ đăng nhập thất bại trong tuần qua", ClickHouse có thể xử lý trên hàng tỷ dòng dữ liệu chỉ trong vài mili-giây4.    ◦ **Cấu trúc Append-only:** Các dữ liệu này thường chỉ ghi thêm mà không bao giờ sửa đổi, rất phù hợp với cơ chế lưu trữ dạng cột (Columnar Storage) của ClickHouse3,4.

• **Bảng liên quan:** `api_usage_logs`6, `auth_logs`5, `security_audit_logs`7.

2\. Thống kê người dùng đăng ký mới (New User Registration Statistics)

Loại dữ liệu này có tính chất đặc biệt vì nó liên quan đến cả **Giao dịch (ACID)** và **Phân tích (OLAP)**8,9.

• **Dữ liệu gốc (Source of Truth):** Lưu tại **YugabyteDB**1,8.

    ◦ Khi một người dùng đăng ký, thông tin định danh của họ (email, mật khẩu, thông tin cá nhân) phải được lưu vào bảng `users` tại YugabyteDB để đảm bảo tính nhất quán tuyệt đối và cho phép họ đăng nhập ngay lập tức8,10.

• **Dữ liệu phục vụ thống kê:** Lưu tại **ClickHouse** thông qua cơ chế đồng bộ11,12.

    ◦ Để phục vụ các biểu đồ tăng trưởng người dùng trên Dashboard mà không làm chậm hệ thống đang vận hành, các sự kiện đăng ký mới sẽ được bắn qua **Kafka (CDC)** và đẩy vào ClickHouse11,12.    ◦ Khi CEO hoặc Admin muốn xem "Biểu đồ năng suất hoặc tăng trưởng nhân viên trong 12 tháng", hệ thống sẽ truy vấn ClickHouse thay vì YugabyteDB để trả về kết quả nhanh nhất mà không ảnh hưởng đến các giao dịch khác9.

3\. Tóm tắt quy tắc quyết định (Decision Matrix)

Để quyết định đặt tính năng thống kê vào đâu, bạn có thể áp dụng các câu hỏi kiểm tra sau từ nguồn tài liệu13,12:

| Câu hỏi kiểm tra | Nếu "Có" -> Chọn | Tại sao? |
| --- | --- | --- |
| Dữ liệu có vượt quá 100 triệu dòng/năm không? | **ClickHouse** | Tránh làm phình và chậm DB giao dịch13. |
| Có cần tính SUM, AVG, COUNT trên tập dữ liệu lớn không? | **ClickHouse** | Đây là sở trường của CSDL phân tích12. |
| Dữ liệu có bao giờ bị sửa (Update) không? | **ClickHouse** (Nếu chỉ Insert) | Tối ưu cho việc ghi nhật ký liên tục12. |
| Dữ liệu có cần tính đúng đắn tuyệt đối để đăng nhập/thanh toán? | **YugabyteDB** | Đảm bảo tính nhất quán ACID13. |

**Lời khuyên về dòng chảy dữ liệu:** Bạn nên áp dụng mô hình **CQRS** (Tách biệt ghi và đọc)11. Mọi hành động đăng nhập hay đăng ký sẽ được ghi vào YugabyteDB (để thực thi nghiệp vụ), sau đó dùng **Debezium/Kafka** để "bơm" các sự kiện này sang ClickHouse để phục vụ báo cáo thống kê14,12. Cách tiếp cận này giúp hệ thống của bạn "Bắt đầu chặt chẽ, mở rộng linh hoạt"15.

\--------------------------------------------------------------------------------

**Ví von để dễ hình dung:** **YugabyteDB** giống như một **"Cuốn sổ cái của kế toán"**, ghi chép chính xác từng nhân viên, từng đồng tiền. Còn **ClickHouse** giống như một **"Hệ thống Camera an ninh và Cảm biến"**, ghi lại mọi lượt người ra vào tòa nhà để cuối tháng bạn xuất ra một báo cáo thống kê về mật độ giao thông mà không cần phải lật lại từng trang trong cuốn sổ cái kế toán4,9.



cụ thể hơn việc thống kê số lượng người dùng đăng ký đi

Việc thống kê số lượng người dùng đăng ký là một bài toán kết hợp giữa **dữ liệu giao dịch (Transactional)** và **dữ liệu phân tích (Analytical)**1. Theo triết lý **Polyglot Persistence**, dữ liệu này sẽ được quản lý ở hai nơi với hai vai trò khác nhau để đảm bảo hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt"2,3.

Dưới đây là chi tiết quy trình và thiết kế kỹ thuật cho việc thống kê này:

1\. Luồng dữ liệu: Từ Giao dịch đến Thống kê

Để đảm bảo hiệu năng, hệ thống không đếm trực tiếp trên bảng người dùng đang hoạt động mà sử dụng mô hình **CQRS** (Tách biệt lệnh ghi và truy vấn đọc)4:

• **Bước 1 (Ghi - YugabyteDB):** Khi có người dùng mới, thông tin định danh được lưu vào bảng `users` để phục vụ đăng nhập tức thì1,5. Đồng thời, một sự kiện `USER_CREATED` được ghi vào bảng `outbox_events` trong cùng một giao dịch ACID để đảm bảo tính nhất quán6,7.

• **Bước 2 (Đồng bộ - CDC/Kafka):** Công cụ **Debezium** lắng nghe thay đổi từ YugabyteDB, đẩy sự kiện qua **Kafka**1.

• **Bước 3 (Phân tích - ClickHouse):** Một Worker hoặc ClickHouse Kafka Engine sẽ tiêu thụ sự kiện này và ghi vào bảng chuyên biệt cho thống kê8,1.

2\. Thiết kế chi tiết bảng `user_registration_logs` (ClickHouse)

Bảng này lưu trữ "vết" của các lượt đăng ký để phục vụ việc vẽ biểu đồ tăng trưởng nhân viên hoặc người dùng theo thời gian mà không làm chậm hệ thống đang chạy8,1.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh chuẩn **UUID v7** để tối ưu sắp xếp thời gian9. |
| **tenant\_id** | UUID | NO  |     |     | ID của tổ chức mà người dùng tham gia10. |
| **user\_id** | UUID | NO  |     |     | ID gốc của người dùng bên bảng `users`11. |
| **registration\_source** | Enum8(...) | NO  | `'DIRECT'` | `'DIRECT'=1, 'SSO'=2, 'INVITE'=3` | Nguồn đăng ký (Trực tiếp, qua SSO, hoặc được mời)12. |
| **data\_region** | String | NO  |     |     | Vùng lưu trữ dữ liệu (VD: `ap-southeast-1`)13. |
| **created\_at** | DateTime64(3) | NO  | `now()` | UTC | Thời điểm đăng ký chính xác đến mili-giây12. |

3\. Câu lệnh SQL tạo bảng và Index (ClickHouse)

ClickHouse sử dụng **Columnar Storage**, giúp việc tính tổng hay đếm trên hàng tỷ bản ghi chỉ mất vài mili-giây14.

```
CREATE TABLE user_registration_logs (
    _id UUID,
    tenant_id UUID,
    user_id UUID,
    registration_source Enum8('DIRECT' = 1, 'SSO' = 2, 'INVITE' = 3),
    data_region String,
    created_at DateTime64(3) DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng theo tháng để quản lý vòng đời dữ liệu
PARTITION BY toYYYYMM(created_at)
-- Sắp xếp theo tenant_id trước để khách hàng xem báo cáo của họ cực nhanh
ORDER BY (tenant_id, created_at, _id)
SETTINGS index_granularity = 8192;

-- Index bổ sung để lọc nhanh theo vùng địa lý
ALTER TABLE user_registration_logs 
ADD INDEX idx_region data_region TYPE bloom_filter(0.01) GRANULARITY 1;
```

4\. Các kịch bản truy vấn phân tích (Use Cases)

Dựa trên thiết kế này, bạn có thể thực hiện các báo cáo chuyên sâu mà nguồn dữ liệu truyền thống khó đáp ứng hiệu quả14,15:

• **Thống kê tăng trưởng người dùng (User Growth):**

    ◦ _Câu hỏi:_ "Tháng này có bao nhiêu người đăng ký mới ở từng Tenant?"    ◦ _Thực thi:_ ClickHouse sẽ quét cột `created_at` trong Partition của tháng hiện tại, thực hiện lệnh `COUNT` cực nhanh mà không cần chạm vào bảng `users` ở YugabyteDB14,8.

• **Phân tích nguồn gốc (Source Analytics):**

    ◦ _Câu hỏi:_ "Tỷ lệ người dùng đăng ký qua SSO so với đăng ký trực tiếp là bao nhiêu?"    ◦ _Thực thi:_ Dựa trên trường `registration_source` để tối ưu các chiến dịch marketing hoặc tích hợp12.

• **Phân bổ địa lý (Geographic Distribution):**

    ◦ _Câu hỏi:_ "Vùng nào đang có lượng người dùng mới cao nhất?"    ◦ _Thực thi:_ Sử dụng `data_region` để xác định xu hướng mở rộng thị trường16.

**Sự ví von:** Việc thống kê này giống như việc bạn có một **"Cuốn sổ điểm danh"** đặt tại cửa ra vào (ClickHouse). Mỗi khi có người mới vào tòa nhà (đăng ký), nhân viên lễ tân ghi một dòng vào sổ. Khi ban quản lý (CEO/Admin) muốn biết hôm nay có bao nhiêu người mới, họ chỉ cần đếm các dòng trong cuốn sổ này thay vì phải đi gõ cửa từng căn phòng (YugabyteDB) để hỏi xem ai mới chuyển đến.



liệt kê các bảng thuộc nhóm Billing & FinOps products, subscriptions, usages, wallets, transactions Thu tiền (Fixed + Usage + Prepaid)

Dựa trên triết lý **Polyglot Persistence** (Dùng đúng công cụ cho đúng việc) từ các nguồn tài liệu, nhóm bảng **Billing & FinOps** được thiết kế để xử lý linh hoạt cả ba mô hình thu tiền: **Cố định (Fixed)**, **Theo mức sử dụng (Usage-based)** và **Trả trước (Prepaid)**12. Các dữ liệu yêu cầu tính nhất quán cao và giao dịch (ACID) sẽ được lưu tại **YugabyteDB**, trong khi các dữ liệu phân tích lớn được lưu tại **ClickHouse**34.

Dưới đây là danh sách chi tiết các bảng được phân loại theo từng nhóm chức năng:

1\. Nhóm Danh mục Sản phẩm & Gói dịch vụ (Products & Packages)

Nhóm này định nghĩa các "mặt hàng" phần mềm mà hệ thống SaaS cung cấp cho khách hàng.

• **products** **(Dòng sản phẩm):** Lưu trữ thông tin về các dòng sản phẩm thương mại chính (ví dụ: "Bộ giải pháp Nhân sự", "Hệ thống CRM")56.

• **service\_packages** **(Danh mục gói cước):** Định nghĩa các gói Combo bán hàng (ví dụ: Gói Starter, Pro, Enterprise)7.... Bảng này sử dụng cột `included_apps_config` dạng **JSONB** để lưu cấu hình các ứng dụng và giới hạn mặc định đi kèm trong gói10.

• **app\_capabilities** **(Định nghĩa tính năng & giới hạn):** Lưu danh sách các tính năng (Boolean) và giới hạn (Number) mà từng ứng dụng hỗ trợ (ví dụ: `max_users`, `storage_gb`)1112.

2\. Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)

Nhóm này quản lý các hợp đồng đang hiệu lực của khách hàng, phục vụ mô hình thu phí định kỳ (Subscription).

• **tenant\_subscriptions** **(Hợp đồng mua bán):** Đây là bảng quan trọng nhất, lưu trữ "Snapshot" quyền lợi thực tế của Tenant tại thời điểm mua813. Toàn bộ giá và quyền lợi phải được **copy** vào đây để tránh lỗi khi giá gốc thay đổi14. Cột `granted_entitlements` dạng **JSONB** cho phép ghi đè (Override) các giới hạn mặc định để hỗ trợ bán thêm Add-on15....

• **subscription\_orders** **(Lệnh mua gói):** Ghi lại các lệnh thực hiện mua hoặc nâng cấp gói cước từ phía Tenant18.

• **subscription\_invoices** **(Hóa đơn thuê bao):** Lưu lịch sử hóa đơn, số tiền phải thanh toán (dùng kiểu dữ liệu `NUMERIC(19,4)`) và trạng thái thanh toán8....

3\. Nhóm Theo mức sử dụng (Metering & Usage-based Billing)

Hỗ trợ mô hình thu phí linh hoạt dựa trên lượng tiêu dùng thực tế của khách hàng (ví dụ: $0.01 cho mỗi Email).

• **usage\_events** **(ClickHouse):** Lưu nhật ký thô về mọi hành động tiêu dùng tài nguyên của Tenant (ví dụ: số lần gọi API, dung lượng bandwidth)20.... Dữ liệu ở đây mang tính chất **Append-only** và có khối lượng cực lớn423.

• **api\_usage\_logs** **(ClickHouse):** Một dạng log chuyên biệt để đếm số lượng Request và dung lượng sử dụng để làm căn cứ tính tiền hoặc giới hạn Rate Limit924.

• **tenant\_usages** **(YugabyteDB):** Dữ liệu tổng hợp từ ClickHouse sau khi qua các Job xử lý định kỳ2526. Bảng này tách biệt việc ghi log tải cao (ClickHouse) và việc tính tiền chính xác (YugabyteDB), giúp hệ thống xuất hóa đơn không bị chậm627.

4\. Nhóm Ví điện tử & Giao dịch (Wallets & Prepaid)

Phục vụ mô hình nạp tiền trước (Prepaid) và trừ dần theo thời gian sử dụng, giúp doanh nghiệp tối ưu dòng tiền2829.

• **tenant\_wallets** **(Ví tiền):** Lưu trữ số dư khả dụng (`balance`) và mã tiền tệ của từng Tenant2930. Đây là dữ liệu **Critical** yêu cầu tính nhất quán mạnh331.

• **wallet\_transactions** **(Nhật ký giao dịch ví):** Lưu trữ mọi biến động số dư (Nạp tiền, Trừ phí, Hoàn tiền). Bảng này được thiết kế theo nguyên tắc **Double-Entry Ledger**, chỉ cho phép `INSERT` và mang tính bất biến (Immutable) để phục vụ đối soát tài chính31....

5\. Nhóm Quản trị Tài chính (FinOps & Compliance)

Hỗ trợ các tính năng quản lý tài chính chuyên sâu cho doanh nghiệp và tập đoàn.

• **cost\_centers** **(Trung tâm chi phí):** Quản lý ngân sách theo từng phòng ban hoặc dự án, giúp Budget Owner theo dõi việc chi tiêu tài nguyên3435.

• **license\_allocations** **(Phân bổ giấy phép):** Quản lý số lượng "ghế" (Seat) đã mua và đã gán, ngăn chặn việc mời người dùng vượt quá hạn mức gói cước3637.

• **price\_adjustments****:** Lưu thông tin về các khoản điều chỉnh giá (giảm giá, khuyến mãi) để minh bạch hóa đơn cho khách hàng14.

**Sự ví von:** Toàn bộ hệ thống Billing & FinOps này giống như một **"Hệ thống quản lý khách sạn thông minh"**. Bảng `packages` là Menu giá phòng; `tenant_subscriptions` là phiếu đăng ký thuê phòng của khách; `tenant_usages` giống như hóa đơn mini-bar (dùng bao nhiêu tính bấy nhiêu); còn `tenant_wallets` là khoản tiền khách đã đặt cọc trước tại quầy lễ tân để trừ dần cho các dịch vụ.



cải tiến Nhóm Danh mục Sản phẩm & Gói dịch vụ

Dựa trên các quy tắc thiết kế hệ thống SaaS quy mô lớn từ các nguồn tài liệu, việc cải tiến **Nhóm Danh mục Sản phẩm & Gói dịch vụ** không chỉ dừng lại ở việc lưu trữ tên gói và giá tiền, mà cần chuyển đổi sang mô hình **Phân cấp Sản phẩm chuyên sâu (Advanced Product Catalog)** để hỗ trợ các kịch bản bán hàng phức tạp như bán Combo, bán theo tính năng hoặc tính tiền theo mức sử dụng12.

Dưới đây là các hướng cải tiến chi tiết dựa trên triết lý **"Bắt đầu chặt chẽ, mở rộng linh hoạt"**3:

1\. Tái cấu trúc mô hình Phân cấp (4 Tầng)

Thay vì chỉ có một bảng gói cước duy nhất, hệ thống cần được phân tách thành 4 tầng thực thể để tách biệt giữa thương mại và kỹ thuật2:

• **Product (Dòng sản phẩm):** Nhóm thương mại lớn (VD: "Bộ giải pháp Nhân sự", "Hệ thống CRM")24.

• **Application (Ứng dụng):** Đơn vị phần mềm kỹ thuật cụ thể (VD: "App Tuyển dụng", "App Chấm công")25.

• **Capability Definitions (Định nghĩa khả năng):** Đây là "Menu" các tính năng (Features - kiểu Boolean) và giới hạn (Limits - kiểu Number) mà từng App hỗ trợ26.

• **Package (Gói cước):** Đơn vị bán hàng thực tế, kết hợp nhiều App và cấu hình các quyền hạn cụ thể27.

2\. Sử dụng JSONB để quản lý Quyền hạn (Entitlements)

Cải tiến lớn nhất là sử dụng cột **JSONB** trong YugabyteDB cho trường `entitlements_config` thay vì tách quá nhiều bảng con78. Cách này mang lại các lợi ích:

• **Hỗ trợ bán Combo (Bundle):** Một gói "Enterprise" có thể chứa cả HRM (giới hạn 50 người dùng) và CRM (giới hạn 1000 khách hàng) chỉ trong một dòng dữ liệu9....

• **Linh hoạt cao:** Bạn có thể thêm/bớt tính năng mới cho một App mà không cần chạy câu lệnh `ALTER TABLE` gây khóa bảng1213.

• **Hiệu năng truy vấn:** Kết hợp với **GIN Index**, hệ thống có thể kiểm tra quyền "Tenant A có được dùng App X không?" cực nhanh mà không cần JOIN nhiều bảng11....

3\. Chiến lược "Snapshot" và Ghi đè (Overrides)

Để đảm bảo hệ thống vận hành ổn định và minh bạch về tài chính, cần áp dụng các quy tắc:

• **Quy tắc Snapshot:** Khi Tenant mua gói, toàn bộ cấu hình giá và quyền hạn từ `packages` phải được **COPY (Snapshot)** vào bảng `tenant_subscriptions`1617. Điều này bảo vệ khách hàng khỏi việc bị thay đổi quyền lợi khi Admin hệ thống cập nhật gói cước gốc16.

• **Hỗ trợ Add-on (Ghi đè):** Cải tiến bảng `tenant_subscriptions` với cột `granted_entitlements` (JSONB) cho phép nhân viên kinh doanh "nới" giới hạn cho khách VIP (VD: Tặng thêm 50GB dung lượng) mà không làm ảnh hưởng đến cấu trúc gói chuẩn18....

4\. Tích hợp mô hình "Metering" (Tính tiền theo lượng dùng)

Cải tiến hệ thống danh mục để hỗ trợ **Usage-based Pricing** (trả tiền theo mỗi Email gửi đi hoặc mỗi GB lưu trữ)2122:

• **Kết nối ClickHouse:** Dữ liệu tiêu dùng thô được ghi tại ClickHouse để đảm bảo tải cao2123.

• **Tổng hợp sang YugabyteDB:** Một Worker sẽ định kỳ tổng hợp dữ liệu từ ClickHouse và đẩy vào bảng `tenant_usages` tại YugabyteDB để đối soát với giới hạn trong gói cước2425.

5\. Thiết kế bảng `service_packages` cải tiến (YugabyteDB)

| Tên trường (Field) | Kiểu dữ liệu | Mô tả & Quy tắc nghiệp vụ |
| --- | --- | --- |
| **\_id** | UUID | Khóa chính chuẩn UUID v72627. |
| **product\_id** | UUID | Tham chiếu đến dòng sản phẩm chính4. |
| **code** | VARCHAR(50) | Mã định danh duy nhất (VD: `HRM_PRO_MONTHLY`)7. |
| **price\_amount** | NUMERIC(19,4) | Giá niêm yết (Tuyệt đối không dùng Float/Double)728. |
| **currency\_code** | VARCHAR(3) | Mã tiền tệ (ISO 4217)2829. |
| **entitlements\_config** | **JSONB** | Chứa cấu hình lồng nhau: App nào được bật, tính năng nào là `true/false`, giới hạn bao nhiêu710. |
| **is\_active** | BOOLEAN | Trạng thái gói (Dùng Boolean, không dùng Int)730. |

**Lời khuyên từ các nguồn:** Một hệ thống danh mục sản phẩm thành công là hệ thống có thể xử lý các truy vấn kiểm tra quyền chỉ bằng **một câu lệnh duy nhất** vào bảng Subscriptions (Single Row Lookup) thay vì phải JOIN qua 4-5 bảng Master Data1320.

\--------------------------------------------------------------------------------

**Sự ví von:** Việc cải tiến này giống như chuyển từ một **"Thực đơn cố định"** (chỉ chọn món có sẵn) sang một **"Hệ thống Buffet thông minh"**. Khách hàng có thể mua gói Combo (Sản phẩm), yêu cầu thêm bớt gia vị (Add-on/Overrides) và cuối cùng hệ thống sẽ tính tiền dựa trên cả món đã đặt lẫn lượng nước uống thực tế họ đã tiêu thụ (Metering)921.



tiếp tục cải tiến

Dựa trên lịch sử trao đổi và các nguồn tài liệu về kiến trúc hệ thống SaaS quy mô lớn, chúng ta đã xây dựng được một nền tảng rất vững chắc từ Identity, Billing, Infrastructure đến AI1.... Để đạt đến cấp độ **"Global Hyper-scale SaaS"** (tương tự Salesforce hay Stripe), tôi đề xuất **4 hướng cải tiến chuyên sâu** tiếp theo nhằm tối ưu hóa Tài chính, Bảo mật dữ liệu nhạy cảm và Khả năng mở rộng hệ sinh thái.

1\. Cải tiến FinOps: Thuế quốc tế và Ghi nhận doanh thu (Revenue Recognition)

Dựa trên hệ thống Ví (`wallets`) và Giao dịch (`transactions`) đã có4..., hệ thống cần xử lý bài toán kế toán phức tạp khi hoạt động toàn cầu.

• **Quản lý Thuế đa quốc gia (Tax Engine):** Khi Tenant ở Singapore mua gói dịch vụ, hệ thống phải tự động tính GST, trong khi ở Châu Âu phải tính VAT theo từng quốc gia7.

    ◦ **Bảng** **tax\_rules****:** Lưu trữ tỷ lệ thuế dựa trên `data_region` và loại sản phẩm8.

• **Ghi nhận doanh thu (Revenue Recognition - ASC 606):** Đối với SaaS, bạn nhận tiền trước (Prepaid) cho 1 năm, nhưng không được ghi nhận doanh thu ngay lập tức mà phải phân bổ theo từng tháng4.

    ◦ **Bảng** **revenue\_schedules****:** Tự động chia nhỏ số tiền từ `subscription_invoices`9 thành các khoản doanh thu được ghi nhận hàng tháng. Điều này giúp báo cáo tài chính của doanh nghiệp minh bạch và đúng chuẩn quốc tế.

2\. Cải tiến Bảo mật: Privacy Vault cho dữ liệu PII

Mặc dù chúng ta đã có cơ chế mã hóa mức cột (`Field-Level Encryption`)1011, nhưng đối với các hệ thống yêu cầu tuân thủ cực cao như Ngân hàng hoặc Y tế, cần một mô hình **PII Vault** (Két sắt dữ liệu định danh).

• **Tách biệt dữ liệu nhạy cảm:** Thay vì lưu Email, SĐT trực tiếp trong bảng `users`1213, các thông tin này sẽ được chuyển sang một Database hoặc Service riêng biệt (Vault).

• **Tokenization:** Trong bảng `users` chỉ lưu một `token_id` vô nghĩa. Khi cần gửi Email, hệ thống sẽ gọi sang Vault để lấy email thật1415.

• **Lợi ích:** Nếu database chính bị rò rỉ (dump), hacker chỉ thu được các ID vô nghĩa. Dữ liệu nhạy cảm thực sự nằm trong một "két sắt" được canh phòng cẩn mật hơn với các chính sách truy cập (Access Policies) khắt khe hơn1617.

3\. Cải tiến Vận hành: Tenant Health Score (Chỉ số sức khỏe khách hàng)

Dựa trên khối lượng dữ liệu khổng lồ tại **ClickHouse** (`audit_logs`, `usage_events`)18..., hệ thống có thể chủ động dự báo khách hàng sắp rời bỏ (Churn Prediction).

• **Bảng** **tenant\_health\_metrics** **(ClickHouse):** Tổng hợp dữ liệu từ `api_usage_logs`21 và `user_sessions`22 để tính toán:

    ◦ **Tần suất sử dụng:** Khách hàng có giảm lượt đăng nhập đột ngột không?18    ◦ **Tỷ lệ lỗi:** Webhook của khách hàng có liên tục thất bại không?23

• **Hành động tự động:** Nếu điểm sức khỏe thấp, hệ thống tự động tạo một `system_job`2425 để gửi thông báo cho đội ngũ Customer Success hoặc gửi một `system_announcement`26 tặng voucher khuyến mãi để giữ chân khách hàng.

4\. Cải tiến AI: LLM-ops và Quản lý chi phí AI (AI Metering)

Khi tích hợp `knowledge_vectors` (RAG)2728, chi phí sử dụng các mô hình ngôn ngữ lớn (như OpenAI, Claude) là rất đắt đỏ.

• **AI Token Metering:** Cần đo lường chính xác số lượng Token mà mỗi Tenant đã tiêu tốn cho từng yêu cầu AI.

• **Bảng** **ai\_usage\_logs** **(ClickHouse):** Lưu vết từng request AI, bao gồm `input_tokens`, `output_tokens`, và `model_name`18.

• **Gắn vào Billing:** Dữ liệu này sẽ được Job tổng hợp đưa vào bảng `tenant_usages`2930 để trừ tiền trực tiếp vào `tenant_wallets` theo thời gian thực4. Điều này đảm bảo bạn không bao giờ bị lỗ do khách hàng dùng AI quá mức31.

Tóm tắt các bảng bổ sung đề xuất:

| Tên bảng | CSDL | Mục đích |
| --- | --- | --- |
| **tax\_rules** | YugabyteDB | Tính thuế tự động theo vùng địa lý732. |
| **revenue\_schedules** | YugabyteDB | Phân bổ doanh thu theo chuẩn kế toán SaaS4. |
| **pii\_vault\_records** | Vault DB | Cô lập dữ liệu nhạy cảm (PII) khỏi bảng users1013. |
| **tenant\_health\_scores** | ClickHouse | Phân tích hành vi để dự báo khách hàng rời bỏ1821. |
| **ai\_usage\_logs** | ClickHouse | Kiểm soát chi phí Token AI cho từng Tenant2733. |

**Sự ví von:** Những cải tiến này giống như việc nâng cấp một **"Tòa nhà thông minh"** thành một **"Hệ sinh thái đô thị tự vận hành"**. Không chỉ có bảo vệ (Security) và điện nước (Infrastructure), hệ thống hiện nay còn có cả cơ quan thuế (Tax), kế toán trưởng (Revenue Recognition), và các cảm biến (Health Score) để biết khi nào cư dân gặp vấn đề nhằm hỗ trợ kịp thời.



tiếp tục cải tiến

Dựa trên các nguồn tài liệu và lịch sử trò chuyện về hệ thống SaaS B2B quy mô lớn, chúng ta đã hoàn thiện các tầng Core Identity, Billing, và Routing. Để đạt đến cảnh giới **"Hyper-scale Ecosystem"** (Hệ sinh thái siêu quy mô) và **"Next-Gen SaaS"** (SaaS thế hệ mới - AI & Data Driven), hệ thống cần được cải tiến thêm 4 mảng chiến lược cuối cùng: **FinOps nâng cao, AI-Native, Tự động hóa vận hành và Bảo mật dữ liệu nhạy cảm**1,2.

Dưới đây là thiết kế chi tiết cho các bảng bổ sung thuộc nhóm cải tiến này:

1\. Nâng cấp FinOps: Hệ thống Ví tín dụng & Kế toán kép (Double-Entry Ledger)

Để tối ưu dòng tiền và hỗ trợ mô hình trả trước (Prepaid), hệ thống cần một cơ chế ví để khách hàng nạp tiền và trừ dần theo mức sử dụng thực tế (như OpenAI hoặc AWS)3,4.

**Bảng:** **tenant\_wallets** **&** **wallet\_transactions** **(Lưu tại YugabyteDB)**3,5.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**6. |
| **tenant\_id** | UUID | NO  |     | `UNIQUE` | Một Tenant chỉ có một ví chính6. |
| **balance** | NUMERIC(19,4) | NO  | `0` | `CHECK (balance >= 0)` | Số dư khả dụng (Luôn đối soát từ giao dịch)6. |
| **currency\_code** | VARCHAR(3) | NO  | `'USD'` |     | Mã tiền tệ (ISO 4217)6. |
| **type** | VARCHAR(30) | NO  |     |     | Loại giao dịch: `DEPOSIT`, `USAGE_DEDUCT`, `REFUND`5. |
| **amount** | NUMERIC(19,4) | NO  |     |     | Số tiền biến động (Âm nếu trừ, Dương nếu nạp)5. |
| **balance\_after** | NUMERIC(19,4) | NO  |     |     | Số dư snapshot ngay sau giao dịch5. |

**Câu lệnh tạo Index tra cứu lịch sử ví:**

```
-- Tối ưu cho việc hiển thị lịch sử biến động số dư mới nhất
CREATE INDEX idx_wallet_history ON wallet_transactions (tenant_id, created_at DESC);
```

2\. Nâng cấp AI-Native: Bộ nhớ Vector (RAG Ready)

Để biến SaaS thành một nền tảng AI có khả năng "trò chuyện với dữ liệu khách hàng", hệ thống cần lưu trữ các Vector Embeddings một cách an toàn và riêng biệt cho từng Tenant4,7.

**Bảng:** **tenant\_knowledge\_vectors** **(Lưu tại YugabyteDB với pgvector)**8.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh đoạn tri thức8. |
| **tenant\_id** | UUID | NO  |     |     | Đảm bảo AI không học lầm dữ liệu khách hàng khác8. |
| **content\_chunk** | TEXT | NO  |     |     | Nội dung văn bản gốc8. |
| **embedding** | **VECTOR(1536)** | NO  |     |     | Vector 1536 chiều (chuẩn OpenAI)8. |
| **metadata** | JSONB | YES | `'{}'` |     | Lưu thông tin nguồn (VD: `doc_type`, `dept`)8. |

**Câu lệnh tạo Index tìm kiếm vector (Similarity Search):**

```
-- Sử dụng HNSW để tìm kiếm tương đồng cực nhanh
CREATE INDEX idx_vector_search ON tenant_knowledge_vectors 
USING hnsw (embedding vector_cosine_ops);
```

3\. Nâng cấp Vận hành: Tự động hóa & Phê duyệt (Workflow Automation)

Chuyển đổi phần mềm từ công cụ nhập liệu thành một "Hệ điều hành" có khả năng tự chạy quy trình và kiểm soát quyền hạn theo mô hình Maker-Checker9,10.

**Bảng:** **tenant\_automations** **&** **approval\_requests** **(Lưu tại YugabyteDB)**11,10.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **trigger\_event** | VARCHAR(50) | NO  |     |     | Sự kiện kích hoạt (VD: `USER_CREATED`)11. |
| **actions\_flow** | **JSONB** | NO  |     |     | Chuỗi hành động (VD: Gửi mail, Bắn webhook)11. |
| **requester\_id** | UUID | NO  |     |     | Người tạo yêu cầu phê duyệt10. |
| **action\_type** | VARCHAR(50) | NO  |     |     | Hành động cần duyệt (VD: `EXPORT_DATA`)10. |
| **payload\_data** | JSONB | NO  |     |     | Snapshot dữ liệu chờ được thực thi nếu duyệt10. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` |     | `PENDING`, `APPROVED`, `REJECTED`10. |

4\. Nâng cấp Bảo mật & Tuân thủ: Két sắt mã hóa & Lưu trữ lạnh

Đáp ứng các tiêu chuẩn bảo mật khắt khe nhất (HIPAA, GDPR) bằng cách mã hóa dữ liệu nhạy cảm mức độ trường và đẩy dữ liệu cũ ra vùng lưu trữ rẻ tiền12,13.

**Bảng:** **tenant\_encryption\_keys** **&** **archival\_policies** **(Lưu tại YugabyteDB)**12,14.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **encrypted\_dek** | BYTEA | NO  |     |     | Khóa mã hóa dữ liệu riêng cho từng Tenant15. |
| **is\_revoked** | BOOLEAN | NO  | `FALSE` |     | Nếu `TRUE`, dữ liệu Tenant sẽ bị "xóa vĩnh viễn"15. |
| **retention\_days** | INT | NO  | `90` |     | Số ngày giữ dữ liệu ở DB chính trước khi đẩy đi14. |
| **s3\_path** | TEXT | NO  |     |     | Đường dẫn file nén dữ liệu cũ trên S3/MinIO16. |

Tổng kết mô hình cải tiến

Toàn bộ các cải tiến này giúp hệ thống của bạn không chỉ giải quyết bài toán nghiệp vụ mà còn tối ưu hóa:

1\. **Dòng tiền (Cashflow):** Qua hệ thống Ví trả trước3.

2\. **Trí tuệ (Intelligence):** Qua bộ nhớ Vector Database17.

3\. **Chi phí hạ tầng:** Qua chính sách lưu trữ phân tầng (Tiered Storage), đẩy dữ liệu lạnh sang S3 để giảm tải cho SSD của DB chính13,16.

4\. **Tương tác (Engagement):** Qua hệ thống Comment và Tagging trực tiếp trên mọi đối tượng nghiệp vụ18,19.

**Sự ví von:** Nếu hệ thống SaaS ban đầu của bạn là một **"Tòa nhà văn phòng"**, thì các cải tiến này biến nó thành một **"Đô thị thông minh tự vận hành"**. Trong đó, Ví tín dụng là ngân hàng nội khu, AI Vector là thư viện trí tuệ, và Automation chính là các dây chuyền robot giúp cư dân (người dùng) làm việc hiệu quả hơn mà không cần can thiệp thủ công20,17,21.



cải tiến để có thể bán kèm các sản phẩm số như tên miền, dịch vụ ssl, ...

Để cải tiến hệ thống nhằm bán kèm các sản phẩm số như tên miền (domain) và dịch vụ SSL, chúng ta cần nâng cấp mô hình **Product Catalog** từ việc chỉ quản lý phần mềm (Apps) sang quản lý **Tài nguyên số (Digital Assets/Resources)**.

Dưới đây là các bước cải tiến chi tiết dựa trên nền tảng **YugabyteDB** và kiến trúc đã thiết kế trong các nguồn tài liệu:

1\. Phân loại lại Danh mục Sản phẩm (Product Catalog)

Hiện tại, bảng `products` và `packages` đang tập trung vào ứng dụng SaaS12. Để bán kèm tên miền và SSL, chúng ta cần mở rộng khái niệm sản phẩm:

• **SaaS Apps:** Phần mềm tự xây dựng (HRM, CRM)3.

• **External Resources (Sản phẩm số bán kèm):** Các dịch vụ từ bên thứ ba (Domain từ Registrar, SSL từ Certificate Authority)45.

**Cải tiến bảng** **products****:** Thêm cột `product_type` để phân biệt.

• `APP`: Phần mềm.

• `DOMAIN`: Tên miền.

• `SSL`: Chứng chỉ bảo mật.

2\. Thiết kế bảng quản lý tài nguyên số (`tenant_digital_assets`)

Khác với ứng dụng SaaS chỉ cần bật/tắt quyền, các sản phẩm số này có vòng đời riêng (đăng ký, xác thực, hết hạn)67. Bảng này sẽ được lưu tại **YugabyteDB** để đảm bảo tính toàn vẹn giao dịch8.

| Tên trường (Field) | Kiểu dữ liệu | Mô tả |
| --- | --- | --- |
| **\_id** | UUID | Định danh chuẩn UUID v79. |
| **tenant\_id** | UUID | Chủ sở hữu tài nguyên10. |
| **asset\_type** | VARCHAR | `DOMAIN`, `SSL_CERT`. |
| **asset\_name** | TEXT | Tên miền (VD: `example.com`). |
| **provider\_data** | JSONB | Lưu thông tin từ NCC (Registrar ID, Auth Code, Provider Name)11. |
| **status** | VARCHAR | `PENDING`, `ACTIVE`, `EXPIRED`, `TRANSFERRING`12. |
| **expiry\_at** | TIMESTAMPTZ | Ngày hết hạn để hệ thống tự động nhắc nhở13. |

3\. Tích hợp với hệ thống Định tuyến (Routing & SSL)

Bảng `tenant_app_routes` vốn đã có các trường `is_custom_domain` và `ssl_status`614. Khi khách hàng mua sản phẩm số, hệ thống sẽ tự động cập nhật bảng này:

• **Mua Tên miền:** Sau khi đăng ký thành công, hệ thống tự động thêm bản ghi vào `tenant_app_routes` với `is_custom_domain = TRUE`7.

• **Mua SSL:** Khi chứng chỉ được cấp phát, cập nhật `ssl_status = 'ACTIVE'` và lưu thông tin chứng chỉ vào bảng `tenant_app_routes` để API Gateway sử dụng615.

4\. Quy trình Tự động hóa (Automation Workflow)

Việc mua sản phẩm số yêu cầu gọi API đến bên thứ ba (ví dụ: Namecheap, Cloudflare, Let's Encrypt). Chúng ta sử dụng mô hình **Transactional Outbox** và **System Jobs** đã thiết kế1617.

1\. **Giao dịch mua:** User bấm mua -> Trừ tiền trong `tenant_wallets` và Insert vào bảng `system_jobs` trong cùng một Transaction1819.

2\. **Worker xử lý:** Một Background Worker đọc từ `system_jobs`, gọi API bên thứ ba để đăng ký tên miền/SSL20.

3\. **Cập nhật trạng thái:** Khi API bên thứ ba trả về kết quả thành công, Worker cập nhật trạng thái trong bảng `tenant_digital_assets` và kích hoạt luồng cấu hình SSL cho Domain đó617.

5\. Mô hình tính tiền (Billing & Wallets)

Sản phẩm số thường được bán theo mô hình **Trả trước (Prepaid)** hoặc **Gia hạn định kỳ (Subscription)**21.

• **Nạp tiền:** Khách hàng nạp tiền vào `tenant_wallets`19.

• **Thanh toán:** Khi mua tên miền, hệ thống thực hiện một `wallet_transactions` loại `USAGE_DEDUCT`22.

• **Gia hạn:** Sử dụng `subscription_end_at` hoặc `expiry_at` để tự động trừ tiền ví khi đến hạn gia hạn tên miền2223.

6\. Cải tiến giao diện cấu hình (Custom Domain Management)

Trong bảng `tenants`, chúng ta có cột `profile` dạng JSONB2425. Chúng ta có thể lưu thêm các cấu hình DNS mong muốn tại đây để hỗ trợ khách hàng tự trỏ Domain nếu họ đã có sẵn.

**Tổng kết các bảng cần tương tác:**

1\. **service\_packages****:** Thêm các gói dịch vụ số hoặc Add-on tên miền/SSL26.

2\. **tenant\_digital\_assets** **(Mới):** Lưu trữ và theo dõi vòng đời sản phẩm số.

3\. **tenant\_app\_routes****:** Cấu hình định tuyến thực tế sau khi mua thành công27.

4\. **tenant\_wallets** **&** **wallet\_transactions****:** Xử lý dòng tiền thanh toán1921.

**Sự ví von:** Việc cải tiến này giống như bạn không chỉ bán **"Căn hộ"** (SaaS App) mà còn bán thêm dịch vụ **"Cấp sổ đỏ"** (Tên miền) và **"Lắp khóa an ninh"** (SSL). Hệ thống Core của bạn đóng vai trò là văn phòng quản lý, kết nối với các cơ quan bên ngoài (Registrar/CA) để hoàn tất thủ tục cho cư dân (Tenant) một cách tự động thông qua các "phiếu yêu cầu" (Jobs)17....



cải tiến để bán kèm các dịch vụ như đào tạo, tư vấn, ...

Dựa trên kiến trúc hệ thống SaaS Enterprise và các nguyên tắc **Polyglot Persistence** từ các nguồn tài liệu, việc bán kèm các dịch vụ như **đào tạo (training)**, **tư vấn (consulting)**, hoặc **triển khai (implementation)** đòi hỏi một cách tiếp cận khác với phần mềm (SaaS seats) hay tài nguyên số (domains)1.

Dịch vụ chuyên nghiệp thường có đặc thù là **thu tiền một lần (One-time fee)**, **tính theo giờ (Time & Materials)** hoặc **theo cột mốc (Milestones)** thay vì thuê bao định kỳ2. Dưới đây là thiết kế chi tiết để cải tiến hệ thống nhằm đáp ứng nhu cầu này.

1\. Chiến lược Cải tiến Kiến trúc

1\. **Mở rộng Product Catalog:** Cập nhật bảng `products` để hỗ trợ loại hình `SERVICE`. Không giống như ứng dụng phần mềm có tính năng "bật/tắt", dịch vụ cần được theo dõi theo trạng thái thực hiện3.

2\. **Quản lý Ghi nhận doanh thu (Revenue Recognition):** Theo chuẩn kế toán **ASC 606**, doanh thu từ tư vấn/đào tạo chỉ được ghi nhận khi dịch vụ đã được cung cấp (delivered), không phải ngay khi thu tiền \[History\].

3\. **Tách biệt dữ liệu:** Các đầu mục dịch vụ sẽ được lưu tại **YugabyteDB** để đảm bảo tính chính xác về tài chính (ACID)4.

2\. Thiết kế chi tiết bảng `tenant_service_deliveries` (YugabyteDB)

Bảng này dùng để quản lý các gói dịch vụ chuyên nghiệp mà khách hàng đã mua và theo dõi tiến độ thực hiện.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**56. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu đến khách hàng (`tenants`)6. |
| **product\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu đến sản phẩm dịch vụ7. |
| **subscription\_id** | UUID | YES | `NULL` |     | Liên kết nếu dịch vụ này nằm trong một gói Combo8. |
| **unit\_type** | VARCHAR(20) | NO  |     | `HOUR`, `SESSION`, `PROJECT` | Đơn vị đo lường (giờ, buổi đào tạo, dự án)9. |
| **total\_units** | NUMERIC(15,2) | NO  | `0` | `> 0` | Tổng số lượng đã mua (ví dụ: 10 giờ tư vấn)10. |
| **delivered\_units** | NUMERIC(15,2) | NO  | `0` | `<= total_units` | Số lượng đã thực hiện thực tế. |
| **unit\_price** | NUMERIC(19,4) | NO  |     |     | Giá cho mỗi đơn vị tại thời điểm mua (Snapshot)1011. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` |     | Mã tiền tệ (ISO 4217)12. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `PENDING`, `IN_PROGRESS`, `COMPLETED` | Trạng thái thực hiện dịch vụ10. |
| **service\_metadata** | JSONB | YES | `'{}'` |     | Lưu thông tin bổ sung (người đào tạo, tài liệu đi kèm)10. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm mua dịch vụ10. |

\--------------------------------------------------------------------------------

3\. Câu lệnh YSQL để tạo bảng và Chỉ mục (Index)

Chúng ta sử dụng **YSQL** (tương thích PostgreSQL) để thực thi các ràng buộc tài chính chặt chẽ và hỗ trợ mở rộng quy mô1314.

```
-- 1. Tạo bảng quản lý dịch vụ đào tạo, tư vấn
CREATE TABLE tenant_service_deliveries (
    -- I. ĐỊNH DANH & TENANCY
    _id UUID PRIMARY KEY, -- Khuyến nghị dùng UUID v7 sinh từ App
    tenant_id UUID NOT NULL,
    product_id UUID NOT NULL,
    subscription_id UUID,

    -- II. CHI TIẾT SỐ LƯỢNG & GIÁ (Dùng NUMERIC cho tiền tệ)
    unit_type VARCHAR(20) NOT NULL,
    total_units NUMERIC(15,2) NOT NULL DEFAULT 0,
    delivered_units NUMERIC(15,2) NOT NULL DEFAULT 0,
    unit_price NUMERIC(19,4) NOT NULL,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',

    -- III. TRẠNG THÁI & THÔNG TIN ĐỘNG
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    service_metadata JSONB NOT NULL DEFAULT '{}',
    
    -- IV. AUDIT
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ràng buộc logic
    CONSTRAINT fk_service_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT chk_service_status CHECK (status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED')),
    CONSTRAINT chk_delivery_logic CHECK (delivered_units <= total_units)
);

-- 2. Tạo chỉ mục tối ưu cho tra cứu
-- Index giúp tìm nhanh các dịch vụ chưa hoàn thành của một khách hàng
CREATE INDEX idx_services_pending 
ON tenant_service_deliveries (tenant_id, status) 
WHERE status != 'COMPLETED';

-- Index hỗ trợ báo cáo doanh thu theo sản phẩm
CREATE INDEX idx_services_product_lookup 
ON tenant_service_deliveries (product_id, created_at DESC);
```

4\. Các điểm lưu ý kỹ thuật

• **Snapshot giá:** Khi khách hàng mua 20 giờ tư vấn, giá tại thời điểm đó (`unit_price`) phải được sao chép trực tiếp vào bảng này. Điều này giúp tránh việc hóa đơn cũ bị thay đổi khi bảng giá niêm yết được cập nhật1115.

• **Theo dõi tiến độ:** Mỗi khi một buổi đào tạo kết thúc, hệ thống sẽ thực hiện một giao dịch ACID để tăng `delivered_units`. Khi `delivered_units = total_units`, trạng thái tự động chuyển thành `COMPLETED`.

• **Giao tiếp đa hệ thống:** Khi trạng thái dịch vụ chuyển sang `COMPLETED`, một sự kiện sẽ được bắn qua **Kafka** thông qua mô hình **Transactional Outbox** để hệ thống kế toán thực hiện ghi nhận doanh thu thực tế1617.

**Sự ví von:** Việc bán dịch vụ tư vấn giống như bạn bán một **"Thẻ liệu trình Spa"**. Khách hàng trả tiền trước để mua 10 buổi (total\_units). Mỗi lần khách đến sử dụng (service delivery), nhân viên sẽ "đục lỗ" trên thẻ (delivered\_units). Khi thẻ hết lượt, dịch vụ kết thúc. YugabyteDB đóng vai trò là quyển sổ cái của tiệm Spa, đảm bảo không có việc "đục lỗ" nhầm hay quá số lượng đã mua413.



liệt kê đầy đủ các bảng thuộc nhóm Danh mục Sản phẩm & Gói dịch vụ

Dựa trên các nguồn tài liệu, nhóm **Danh mục Sản phẩm & Gói dịch vụ** (Product Catalog & Service Packages) được thiết kế theo mô hình phân cấp chuyên sâu (Advanced Product Catalog) để hỗ trợ các kịch bản bán hàng phức tạp như bán Combo (Bundle), bán theo tính năng hoặc giới hạn sử dụng12.

Dưới đây là danh sách đầy đủ các bảng thuộc nhóm này, phân loại theo tầng dữ liệu:

1\. Tầng Định nghĩa Sản phẩm & Kỹ thuật (Master Data)

Đây là nơi quy định các "nguyên liệu" đầu vào của hệ thống trước khi đóng gói thành các gói cước thương mại3.

• **products** **(Dòng sản phẩm):** Lưu trữ thông tin về các dòng sản phẩm lớn của doanh nghiệp (ví dụ: "Bộ giải pháp Nhân sự", "Hệ thống CRM")4. Bảng này bao gồm mã sản phẩm, tên, mô tả và các thuộc tính cơ bản56.

• **applications** **(Danh sách ứng dụng):** Định nghĩa các đơn vị phần mềm kỹ thuật cụ thể (ví dụ: "App Tuyển dụng", "App Chấm công", "App Quản lý kho")3.

• **app\_capabilities** **(Định nghĩa tính năng & giới hạn):** Lưu trữ danh mục các tính năng (kiểu Boolean - có/không) và giới hạn (kiểu Number - số lượng) mà từng ứng dụng hỗ trợ (ví dụ: `allow_sso`, `max_users`, `storage_gb`)7.

2\. Tầng Đóng gói Thương mại (Commercial Catalog)

Đây là nơi Admin hệ thống tạo ra các gói cước để bán cho khách hàng89.

• **service\_packages** **(hoặc** **packages** **- Gói dịch vụ):** Là đơn vị bán hàng chính, đóng vai trò là "Menu" để khách hàng lựa chọn810. Một gói cước có thể chứa nhiều ứng dụng (Combo) và được cấu hình quyền hạn chi tiết thông qua cột **JSONB** (`included_apps_config` hoặc `entitlements_config`)911.

• **product\_catalog** **(MongoDB):** Được sử dụng trong trường hợp danh mục sản phẩm có cấu hình động, không cấu trúc và thay đổi thường xuyên theo ngữ cảnh của từng khách hàng hoặc ngành nghề khác nhau1213.

3\. Tầng Ghi nhận Thuê bao (Subscription Instances)

Dữ liệu tại tầng này là kết quả của việc khách hàng chọn mua một gói cước từ danh mục1415.

• **tenant\_subscriptions** **(Thuê bao khách hàng):** Khi một khách hàng (Tenant) mua gói, hệ thống sẽ thực hiện **Snapshot** (sao chép toàn bộ giá và quyền hạn) từ bảng `service_packages` vào bảng này1516. Điều này đảm bảo quyền lợi của khách hàng không bị thay đổi nếu gói cước gốc được Admin cập nhật sau đó17. Nó lưu trữ chi tiết các ứng dụng và hạn mức mà khách hàng thực tế được cấp thông qua cột `granted_apps_details` hoặc `granted_entitlements`1718.

Tóm tắt vị trí lưu trữ và công nghệ:

| Tên Bảng | Cơ sở dữ liệu | Vai trò chính |
| --- | --- | --- |
| **products** | YugabyteDB | Định nghĩa dòng sản phẩm thương mại519. |
| **applications** | YugabyteDB | Định nghĩa đơn vị ứng dụng kỹ thuật3. |
| **app\_capabilities** | YugabyteDB | Danh mục "Menu" các tính năng và giới hạn kỹ thuật7. |
| **service\_packages** | YugabyteDB (JSONB) | Tạo các gói Combo và cấu hình quyền hạn mặc định911. |
| **product\_catalog** | MongoDB | Lưu cấu hình sản phẩm động hoặc thuộc tính tùy biến1213. |
| **tenant\_subscriptions** | YugabyteDB (JSONB) | Lưu Snapshot quyền lợi thực tế của khách hàng khi mua gói1617. |

**Lưu ý kỹ thuật:** Hệ thống sử dụng **YugabyteDB** cho các bảng này để đảm bảo tính nhất quán (ACID) trong giao dịch mua bán và sử dụng kiểu dữ liệu **JSONB** để cho phép mở rộng các tính năng hoặc giới hạn mới mà không cần thay đổi cấu trúc bảng (ALTER TABLE)20....



thiết kế chi tiết bảng products dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn kỹ thuật về hệ thống SaaS đa khách hàng (Multi-tenancy) và triết lý "Bắt đầu chặt chẽ, mở rộng linh hoạt" từ các nguồn tài liệu, dưới đây là thiết kế chi tiết cho bảng **products** sử dụng **YSQL (YugabyteDB)**.

Bảng này đóng vai trò là tầng **Commercial Master Data**, định nghĩa các dòng sản phẩm thương mại cốt lõi trước khi được đóng gói thành các gói cước (`service_packages`) cụ thể1,2.

1\. Thiết kế chi tiết bảng `products`

Dữ liệu được thiết kế theo chuẩn **snake\_case** để tương thích tốt nhất với YugabyteDB và hỗ trợ khả năng mở rộng quy mô lớn3.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp theo thời gian và tối ưu hiệu năng sharding4,5. |
| **tenant\_id** | UUID | NO  |     | `INDEXED` | Định danh khách hàng sở hữu dòng sản phẩm này (hoặc ID hệ thống cho sản phẩm dùng chung)6,7. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE (tenant_id, code)`, `CHECK (~ '^[a-z0-9-]+$')` | Mã sản phẩm (Slug). Ví dụ: `hrm-suite`, `pos-pro`. Chỉ chứa chữ thường, số, gạch ngang8,9. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (length(name) > 0)` | Tên sản phẩm hiển thị8,10. |
| **product\_type** | VARCHAR(20) | NO  | `'APP'` | `CHECK (product_type IN ('APP', 'DOMAIN', 'SSL', 'SERVICE'))` | Phân loại sản phẩm để xử lý logic: Ứng dụng, Tên miền, SSL hoặc Dịch vụ tư vấn \[products section\]. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết sản phẩm. Sử dụng TEXT để không giới hạn độ dài8,11. |
| **base\_price** | NUMERIC(19,4) | NO  | `0` | `CHECK (base_price >= 0)` | Giá niêm yết cơ bản. Sử dụng NUMERIC để đảm bảo độ chính xác tuyệt đối trong tài chính4,12. |
| **currency** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency) = 3)` | Mã tiền tệ theo chuẩn ISO 4217 (VND, USD,...)4,10. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái cho phép kinh doanh sản phẩm này8. |
| **metadata** | JSONB | YES | `'{}'` |     | Chứa các thông tin động, thuộc tính riêng biệt của từng loại sản phẩm8,13. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)14,7. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng14. |
| **deleted\_at** | TIMESTAMPTZ | YES | NULL |     | Hỗ trợ **Soft Delete** (Xóa mềm) để đảm bảo toàn vẹn dữ liệu lịch sử14,7. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho **Optimistic Locking**, ngăn chặn ghi đè dữ liệu khi nhiều người cùng sửa15,16. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Chỉ mục (Index)

Câu lệnh này được tối ưu hóa cho **YugabyteDB**, sử dụng các ràng buộc chặt chẽ để đảm bảo "sạch" dữ liệu ngay từ tầng database17,18.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE products (
    -- I. Định danh & Tenancy
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    
    -- II. Thông tin nghiệp vụ
    code VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    product_type VARCHAR(20) NOT NULL DEFAULT 'APP',
    description TEXT,
    
    -- III. Tài chính (Sử dụng NUMERIC cho độ chính xác cao)
    base_price NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- IV. Trạng thái & Dữ liệu động
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    metadata JSONB NOT NULL DEFAULT '{}',
    
    -- V. Audit Mixins & Versioning
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- VI. Các ràng buộc (Constraints)
    CONSTRAINT uq_products_tenant_code UNIQUE (tenant_id, code),
    CONSTRAINT chk_products_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_products_type CHECK (product_type IN ('APP', 'DOMAIN', 'SSL', 'SERVICE')),
    CONSTRAINT chk_products_price CHECK (base_price >= 0),
    CONSTRAINT chk_products_currency_len CHECK (LENGTH(currency) = 3),
    CONSTRAINT chk_products_name_len CHECK (LENGTH(name) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lọc sản phẩm theo Tenant (Bắt buộc cho SaaS)
CREATE INDEX idx_products_tenant ON products (tenant_id) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ tìm kiếm nhanh theo mã sản phẩm trong một Tenant
CREATE INDEX idx_products_lookup ON products (tenant_id, code) 
WHERE deleted_at IS NULL;

-- Index GIN để tìm kiếm trong các thuộc tính động của metadata
CREATE INDEX idx_products_metadata ON products USING GIN (metadata);

-- Index hỗ trợ thống kê theo loại sản phẩm và trạng thái
CREATE INDEX idx_products_analytics ON products (product_type, is_active) 
WHERE deleted_at IS NULL;
```

3\. Giải thích các cải tiến kỹ thuật

• **UUID v7:** Giúp các dòng sản phẩm được chèn vào database theo thứ tự thời gian, giảm thiểu hiện tượng "fragmentation" (phân mảnh) của index và giúp việc sắp xếp danh sách sản phẩm mới nhất cực nhanh5,19.

• **JSONB Metadata:** Cho phép bạn bán kèm các sản phẩm đặc thù (như SSL cần lưu trữ loại mã hóa, Domain cần lưu thông tin Registrar) mà không phải thay đổi cấu trúc bảng20,21.

• **Partial Index (WHERE deleted\_at IS NULL):** Giúp các câu lệnh truy vấn bỏ qua các sản phẩm đã bị xóa mềm, làm cho Index nhỏ hơn và tốc độ tìm kiếm nhanh hơn đáng kể22,23.

• **Optimistic Locking (****version****):** Đảm bảo tính nhất quán khi nhiều Admin cùng cập nhật giá hoặc cấu hình sản phẩm đồng thời15,19.

**Sự ví von:** Bảng `products` này giống như một **"Danh mục hàng trong kho"**. Bạn quy định sẵn từng món đồ có mã gì, giá gốc bao nhiêu. Khi đến tay khách hàng, bạn sẽ lấy các món này "đóng combo" thành các gói quà (Packages) và ghi hóa đơn (Subscriptions) dựa trên giá niêm yết tại thời điểm đó24,1.



thiết kế chi tiết bảng applications dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng và triết lý "Bắt đầu chặt chẽ, mở rộng linh hoạt" từ các nguồn tài liệu, bảng **applications** đóng vai trò định nghĩa các đơn vị phần mềm kỹ thuật cụ thể (ví dụ: App Tuyển dụng, App Chấm công) trước khi được đóng gói vào các gói cước thương mại1,2.

Dưới đây là thiết kế chi tiết sử dụng **YSQL (YugabyteDB)** với định danh **UUID v7** để tối ưu hóa hiệu năng sắp xếp và sharding3,4.

1\. Thiết kế chi tiết bảng `applications`

Bảng này được lưu trữ tại tầng **Distributed SQL (YugabyteDB)** để đảm bảo tính nhất quán ACID tuyệt đối cho các thực thể lõi của hệ thống5,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7** giúp sắp xếp theo thời gian3,7. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[A-Z0-9_]+$')` | Mã ứng dụng kỹ thuật (VD: `HRM_RECRUIT`). Chỉ chứa chữ hoa, số và gạch dưới2. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của ứng dụng2. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết chức năng của ứng dụng2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái bật/tắt ứng dụng trên toàn hệ thống8,2. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)8,9. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật dữ liệu gần nhất10. |
| **deleted\_at** | TIMESTAMPTZ | YES | NULL |     | Thời điểm xóa mềm (Soft Delete)10. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Dùng cho cơ chế **Optimistic Locking**, chống ghi đè dữ liệu đồng thời7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Câu lệnh này tuân thủ các quy tắc đặt tên **snake\_case** và tích hợp các trường tiêu chuẩn (Standard Mixins) để phục vụ quản trị và truy vết11,12.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE applications (
    -- I. Định danh & Mã kỹ thuật
    _id UUID PRIMARY KEY, -- UUID v7 nên được sinh từ tầng Application
    code VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,

    -- II. Trạng thái vận hành
    is_active BOOLEAN NOT NULL DEFAULT TRUE,

    -- III. Nhóm Audit & Versioning (Tiêu chuẩn hệ thống)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- IV. Các ràng buộc dữ liệu
    CONSTRAINT uq_applications_code UNIQUE (code),
    CONSTRAINT chk_app_code_format CHECK (code ~ '^[A-Z0-9_]+$'),
    CONSTRAINT chk_app_name_not_empty CHECK (LENGTH(name) > 0),
    CONSTRAINT chk_app_version_valid CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh theo mã ứng dụng (thường dùng khi Routing hoặc Check quyền)
CREATE UNIQUE INDEX idx_applications_code 
ON applications (code) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ liệt kê các ứng dụng đang hoạt động
CREATE INDEX idx_applications_active 
ON applications (is_active) 
WHERE deleted_at IS NULL;

-- Comment mô tả bảng (tùy chọn để hỗ trợ Documentation)
COMMENT ON TABLE applications IS 'Lưu trữ danh mục các ứng dụng kỹ thuật trong hệ thống SaaS';
COMMENT ON COLUMN applications._id IS 'Định danh UUID v7 giúp sắp xếp theo thời gian và tối ưu sharding';
```

3\. Các lưu ý quan trọng khi triển khai:

• **UUID v7:** Việc sử dụng UUID v7 thay vì Serial/Int giúp tránh lộ quy mô hệ thống và tối ưu hóa việc chèn dữ liệu vào YugabyteDB do tính chất sắp xếp được theo thời gian, tránh gây ra các điểm nóng (Hotspots) trên các Tablet Server3,4.

• **Soft Delete:** Dữ liệu ứng dụng không nên xóa cứng (`Hard Delete`) để đảm bảo các bảng liên kết như `service_packages` hay `tenant_subscriptions` không bị mồ côi dữ liệu (Orphaned Data)10,13.

• **Kiểu dữ liệu:** Sử dụng `BOOLEAN` cho trạng thái và `TIMESTAMPTZ` cho thời gian để đảm bảo tính nhất quán trên toàn hệ thống đa quốc gia8,9.



app\_capabilities có nên tách thành app\_features và app\_limits?

Dựa trên các quy chuẩn thiết kế hệ thống SaaS và kiến trúc dữ liệu đã thảo luận trong các nguồn tài liệu, câu trả lời là: **Không nên tách thành hai bảng vật lý riêng biệt, nhưng cần tách biệt về mặt cấu trúc (schema) bên trong dữ liệu.**

Việc quản lý các "khả năng" của ứng dụng nên tuân theo mô hình **"Gộp tại bảng Danh mục (Master Data) nhưng Tách tại bảng Thực thi (JSONB Configuration)"** để đảm bảo tính gọn nhẹ và linh hoạt1,2.

Dưới đây là phân tích chi tiết dựa trên các nguồn tài liệu:

1\. Tại bảng Danh mục: Giữ chung trong `app_capabilities`

Trong cơ sở dữ liệu **YugabyteDB**, bạn nên giữ một bảng duy nhất là `app_capabilities` để quản lý danh mục các tính năng và giới hạn mà một ứng dụng có thể có3.

• **Lý do:** Giúp việc quản lý "Menu" của ứng dụng trở nên tập trung. Một ứng dụng khi được phát triển sẽ khai báo tất cả những gì nó có thể cung cấp tại đây2.

• **Cách thiết kế:** Sử dụng cột `type` để phân loại giữa **BOOLEAN** (cho Features) và **NUMBER** (cho Limits)2.

    ◦ **Features:** Trả lời câu hỏi "Có được làm hay không?" (Ví dụ: `allow_sso`, `allow_export`)4.    ◦ **Limits:** Trả lời câu hỏi "Được làm bao nhiêu?" (Ví dụ: `max_users`, `storage_gb`)4.

2\. Tại bảng Gói cước và Thuê bao: Tách biệt cấu trúc JSONB

Khi đóng gói các khả năng này vào `packages` (Gói cước) hoặc `tenant_subscriptions` (Thuê bao khách hàng), bạn nên tách chúng thành hai khóa (key) riêng biệt bên trong cột **JSONB**5,6.

**Cấu trúc đề xuất trong JSONB:**

```
{
  "HRM_APP": {
    "features": {
      "ai_screening": true,
      "custom_email": false
    },
    "limits": {
      "max_users": 50,
      "storage_gb": 100
    }
  }
}
```

• **Lợi ích của việc tách trong JSON:** Khi hệ thống thực hiện kiểm tra quyền (Gatekeeper), câu lệnh truy vấn sẽ rất minh bạch và nhanh chóng. Bạn có thể truy xuất thẳng vào nhánh `features` để kiểm tra quyền truy cập hoặc nhánh `limits` để so sánh hạn mức mà không cần lọc qua toàn bộ danh sách7.

3\. Tại sao không nên tách thành 2 bảng vật lý?

• **Giảm thiểu JOIN:** Nếu tách thành `app_features` và `app_limits`, mỗi khi bạn muốn xem toàn bộ khả năng của một ứng dụng, bạn sẽ phải thực hiện lệnh `JOIN` giữa hai bảng này, làm tăng độ phức tạp và giảm hiệu năng8,7.

• **Đồng nhất quản lý:** Cả hai đều là "Entitlements" (Quyền lợi trong gói). Việc giữ chung một bảng giúp các tính năng như **Audit Log** (Ai đã sửa danh mục?) hay **Versioning** (Phiên bản danh mục) được thực hiện đồng nhất2,9.

Tóm tắt kiến trúc cải tiến

| Tầng dữ liệu | Trạng thái | Giải pháp kỹ thuật |
| --- | --- | --- |
| **Master Data (YugabyteDB)** | **Gộp** | Bảng `app_capabilities` có cột `type` (ENUM: BOOLEAN, NUMBER)2. |
| **Configuration (JSONB)** | **Tách** | Khóa `"features": {...}` và `"limits": {...}` bên trong cột `entitlements_config`5,10. |
| **Logic nghiệp vụ** | **Tách** | Features dùng để ẩn/hiện nút bấm; Limits dùng để chặn hành động vượt định mức4,7. |

**Sự ví von:** Hãy tưởng tượng bảng `app_capabilities` giống như **"Cuốn từ điển của ứng dụng"**. Bạn không cần tách riêng danh từ và động từ thành hai cuốn sách khác nhau để tra cứu, nhưng trong mỗi trang sách, bạn sẽ ghi chú rõ từ nào là danh từ (Limit) và từ nào là động từ (Feature) để người đọc (Hệ thống) sử dụng đúng ngữ pháp (Logic)1,2.



thiết kế chi tiết bảng app\_capabilities dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn kỹ thuật về hệ thống SaaS đa khách hàng và triết lý "Bắt đầu chặt chẽ, mở rộng linh hoạt", bảng **app\_capabilities** được thiết kế để quản lý tập trung cả hai loại quyền lợi: Tính năng (Features) và Hạn mức (Limits)12. Việc sử dụng **YSQL (YugabyteDB)** giúp đảm bảo tính nhất quán dữ liệu (ACID) và khả năng mở rộng quy mô lớn34.

Dưới đây là thiết kế chi tiết cho bảng `app_capabilities` sử dụng định danh **UUID v7** để tối ưu hóa hiệu năng sắp xếp theo thời gian và tránh các điểm nóng (hotspots) trong cơ sở dữ liệu phân tán5....

1\. Thiết kế chi tiết bảng `app_capabilities`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**56. |
| **app\_code** | VARCHAR(50) | NO  |     | `REFERENCES applications(code)` | Tham chiếu đến mã ứng dụng kỹ thuật28. |
| **code** | VARCHAR(50) | NO  |     | `CHECK (code ~ '^[a-z0-9_]+$')` | Mã định danh tính năng/hạn mức (VD: `allow_sso`, `max_users`)8. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của khả năng8. |
| **type** | VARCHAR(20) | NO  |     | `CHECK (type IN ('BOOLEAN', 'NUMBER'))` | Phân loại: **BOOLEAN** (Tính năng) hoặc **NUMBER** (Hạn mức)8. |
| **default\_value** | JSONB | NO  |     |     | Giá trị mặc định (VD: `true` hoặc `10`). Dùng JSONB để linh hoạt kiểu dữ liệu8. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết về tính năng hoặc hạn mức này2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái cho phép sử dụng khả năng này để đóng gói9. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)1011. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng12. |
| **deleted\_at** | TIMESTAMPTZ | YES | NULL |     | Hỗ trợ **Soft Delete** (Xóa mềm)12. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho **Optimistic Locking**6. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Chỉ mục (Index)

Câu lệnh này thiết lập cấu trúc dữ liệu chặt chẽ ngay từ tầng Database để đảm bảo tính toàn vẹn cho các ứng dụng SaaS113.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE app_capabilities (
    -- I. Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ tầng Application
    app_code VARCHAR(50) NOT NULL,
    
    -- II. Thông tin nghiệp vụ
    code VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    type VARCHAR(20) NOT NULL,
    default_value JSONB NOT NULL,
    description TEXT,
    
    -- III. Trạng thái & Vận hành
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- IV. Audit & Versioning (Standard Mixins)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- V. Các ràng buộc dữ liệu
    CONSTRAINT fk_cap_app FOREIGN KEY (app_code) REFERENCES applications(code),
    CONSTRAINT uq_app_cap_code UNIQUE (app_code, code), -- Một App không được trùng mã khả năng
    CONSTRAINT chk_cap_code_fmt CHECK (code ~ '^[a-z0-9_]+$'),
    CONSTRAINT chk_cap_type CHECK (type IN ('BOOLEAN', 'NUMBER')),
    CONSTRAINT chk_cap_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm tất cả khả năng của một ứng dụng
CREATE INDEX idx_app_capabilities_app ON app_capabilities (app_code) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ tra cứu nhanh khi cấu hình gói cước
CREATE UNIQUE INDEX idx_app_capabilities_lookup ON app_capabilities (app_code, code) 
WHERE deleted_at IS NULL;

-- Index cho phép lọc theo loại (Feature vs Limit)
CREATE INDEX idx_app_capabilities_type ON app_capabilities (type) 
WHERE is_active = TRUE AND deleted_at IS NULL;
```

3\. Giải thích các cải tiến kỹ thuật

• **Sử dụng JSONB cho** **default\_value****:** Điều này cực kỳ quan trọng vì nó cho phép lưu trữ cả giá trị `true/false` cho tính năng và giá trị số (ví dụ: `100`) cho hạn mức mà không cần thay đổi kiểu dữ liệu cột814.

• **Ràng buộc Duy nhất (****uq\_app\_cap\_code****):** Đảm bảo tính nhất quán, không cho phép một ứng dụng có hai khai báo trùng mã (ví dụ: không thể có hai mã `max_users` trong cùng app HRM)8.

• **Partial Index:** Các Index đều kèm điều kiện `WHERE deleted_at IS NULL` để tăng tốc độ truy vấn bằng cách loại bỏ các dữ liệu đã xóa mềm khỏi bộ lọc1215.

• **Tính kế thừa:** Thiết kế này sẵn sàng để "Snapshot" dữ liệu sang các bảng `packages` và `tenant_subscriptions` dưới dạng cấu hình JSON lồng nhau, giúp hệ thống kiểm tra quyền lợi (Entitlement Check) chỉ với một câu truy vấn duy nhất16....

**Sự ví von:** Bảng `app_capabilities` giống như một **"Cuốn từ điển năng lực"** của phần mềm. Mỗi từ vựng (code) có thể là một động từ (Tính năng - làm được gì) hoặc một định lượng (Hạn mức - làm được bao nhiêu). Khi bạn bán hàng, bạn chỉ cần chọn các "từ vựng" này để viết thành một bản hợp đồng (Subscription) cho khách hàng1920.



thiết kế chi tiết bảng service\_packages dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng và mô hình phân cấp sản phẩm (Product Hierarchy) đã thảo luận, bảng **service\_packages** đóng vai trò là "Menu" thương mại, nơi đóng gói các ứng dụng và tính năng thành các gói cước để bán cho khách hàng1....

Dưới đây là thiết kế chi tiết sử dụng **YSQL (YugabyteDB)** với định danh **UUID v7** để tối ưu hóa hiệu năng45.

1\. Thiết kế chi tiết bảng `service_packages`

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian56. |
| **product\_id** | UUID | NO  |     | `REFERENCES products(_id)` | Thuộc dòng sản phẩm chính nào (VD: Bộ giải pháp Nhân sự)78. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã gói cước (Slug). Chỉ chứa chữ thường, số, gạch ngang (VD: `hrm-pro-monthly`)910. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (length(name) > 0)` | Tên gói cước hiển thị trên báo giá/hóa đơn. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết các quyền lợi của gói cước. |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (price_amount >= 0)` | Giá niêm yết của gói. Dùng **NUMERIC** để đảm bảo chính xác tuyệt đối411. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ theo chuẩn ISO 421749. |
| **entitlements\_config** | **JSONB** | NO  | `'{}'` |     | Chứa cấu hình lồng nhau về Apps, Features và Limits (VD: Gói này có HRM và CRM)28. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED'))` | Trạng thái gói: Đang bán, Ngừng bán, hoặc Lưu trữ2. |
| **is\_public** | BOOLEAN | NO  | `TRUE` |     | Gói cước công khai hay gói thiết kế riêng (Custom) cho khách VIP. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo gói (UTC)1213. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng14. |
| **deleted\_at** | TIMESTAMPTZ | YES | NULL |     | Hỗ trợ **Soft Delete** để bảo toàn dữ liệu lịch sử14. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Dùng cho **Optimistic Locking**, ngăn chặn ghi đè khi nhiều Admin cùng sửa615. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Chỉ mục (Index)

Câu lệnh này tích hợp các quy tắc về kiểu dữ liệu chính xác và chiến lược đánh chỉ mục để phục vụ truy vấn tốc độ cao trên YugabyteDB1617.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE service_packages (
    -- I. Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ tầng Application
    product_id UUID NOT NULL,
    
    -- II. Thông tin thương mại
    code VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- III. Tài chính (Sử dụng NUMERIC theo chuẩn nguồn [4])
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- IV. Cấu hình quyền hạn (Sử dụng JSONB theo chuẩn nguồn [2])
    entitlements_config JSONB NOT NULL DEFAULT '{}',
    
    -- V. Trạng thái vận hành
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    is_public BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- VI. Audit & Versioning
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- VII. Ràng buộc (Constraints)
    CONSTRAINT fk_package_product FOREIGN KEY (product_id) REFERENCES products(_id),
    CONSTRAINT uq_package_code UNIQUE (code),
    CONSTRAINT chk_package_code_format CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_package_price CHECK (price_amount >= 0),
    CONSTRAINT chk_package_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm tất cả các gói thuộc một dòng sản phẩm (VD: Lấy các gói của 'HRM Suite')
CREATE INDEX idx_packages_product ON service_packages (product_id) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ tra cứu nhanh gói cước qua mã (Dùng khi checkout/mua hàng)
CREATE UNIQUE INDEX idx_packages_code_lookup ON service_packages (code) 
WHERE deleted_at IS NULL;

-- Index GIN hỗ trợ tìm kiếm bên trong JSONB (VD: Tìm tất cả gói có chứa App 'CRM') [18, 19]
CREATE INDEX idx_packages_entitlements ON service_packages USING GIN (entitlements_config);

-- Index hỗ trợ lọc các gói đang hoạt động và công khai cho trang chủ/giá cả
CREATE INDEX idx_packages_active_public ON service_packages (status, is_public) 
WHERE status = 'ACTIVE' AND is_public = TRUE AND deleted_at IS NULL;
```

3\. Giải thích các cải tiến kỹ thuật dựa trên các nguồn:

• **JSONB Entitlements:** Thay vì tách ra hàng chục bảng con như `package_apps`, `package_features`, việc sử dụng JSONB cho phép bạn định nghĩa các gói Combo (Bundle) phức tạp chỉ trong một dòng dữ liệu, giúp giảm thiểu lệnh JOIN và tăng tốc độ kiểm tra quyền (Entitlement Check)217.

• **Snapshot Readiness:** Thiết kế này sẵn sàng cho quy trình **Snapshot**. Khi khách hàng mua gói, toàn bộ nội dung của `entitlements_config` và `price_amount` sẽ được sao chép nguyên trạng vào bảng `tenant_subscriptions` để bảo vệ quyền lợi khách hàng khi giá gốc thay đổi1819.

• **Versioning:** Trường `version` đảm bảo rằng nếu hai quản trị viên cùng cập nhật giá của một gói cước cùng lúc, hệ thống sẽ phát hiện và ngăn chặn việc ghi đè dữ liệu cũ620.

• **UUID v7:** Đảm bảo các gói mới tạo luôn được sắp xếp ở cuối Index, tránh việc phân mảnh dữ liệu và tối ưu cho các truy vấn lấy danh sách sản phẩm mới nhất521.



product\_catalog quan hệ với các bảng khác như thế nào?

Dựa trên các nguồn tài liệu về kiến trúc hệ thống SaaS, bảng **product\_catalog** đóng vai trò là kho lưu trữ dữ liệu động và không cấu trúc (Unstructured) trong mô hình **Polyglot Persistence**1. Khác với các bảng quản lý chặt chẽ trong YugabyteDB, `product_catalog` thường được đặt tại **MongoDB** để xử lý các thuộc tính sản phẩm thay đổi tùy theo ngữ cảnh của từng khách hàng (Tenant)2.

Dưới đây là chi tiết mối quan hệ của `product_catalog` với các thành phần khác trong hệ thống:

1\. Quan hệ với tầng Định nghĩa Sản phẩm (Master Data)

• **Bảng** **products** **(YugabyteDB):** Đây là quan hệ "gốc - chi tiết". Bảng `products` lưu trữ các dòng sản phẩm chính (Master Data) với các thông tin cốt lõi như mã (`code`), tên (`name`), và giá cơ bản34.

• **Mối liên kết:** `product_catalog` trong MongoDB sẽ mở rộng cho bảng này bằng cách lưu trữ các **thuộc tính động (Dynamic Attributes)** mà không cần thay đổi cấu trúc bảng SQL (ví dụ: kích cỡ, màu sắc, hoặc các thông số kỹ thuật đặc thù cho từng loại hàng hóa)25.

2\. Quan hệ với tầng Đóng gói Thương mại (Commercial Catalog)

• **Bảng** **service\_packages** **(YugabyteDB):** Các gói cước thương mại (như gói Starter, Pro, Enterprise) sẽ kết hợp các ứng dụng và tính năng lại với nhau67.

• **Mối liên kết:** Khi một gói cước cần hiển thị thông tin chi tiết hoặc các tùy chọn sản phẩm đi kèm một cách linh hoạt, hệ thống sẽ truy vấn từ `product_catalog`1. Dữ liệu từ Catalog giúp cấu hình các thành phần lồng nhau bên trong cột `included_apps_config` của gói cước8.

3\. Quan hệ với tầng Khách hàng (Tenants)

• **Bảng** **tenants** **(YugabyteDB):** Dữ liệu trong `product_catalog` thường mang tính chất **phụ thuộc vào Tenant**2.

• **Mối liên kết:** Mỗi Tenant có thể có một danh mục sản phẩm riêng với các thuộc tính khác nhau (Tenant A muốn thêm trường "Số CMND", Tenant B thì không)5. `product_catalog` liên kết với `tenant_id` để đảm bảo khi truy vấn, hệ thống chỉ lấy ra đúng danh mục và cấu hình dành riêng cho khách hàng đó29.

4\. Quan hệ với tầng Thuê bao & Giao dịch (Subscription & Transactions)

• **Bảng** **tenant\_subscriptions** **(YugabyteDB):** Khi khách hàng thực hiện mua một sản phẩm từ Catalog, hệ thống sẽ thực hiện cơ chế **Snapshot**1011.

• **Mối liên kết:** Toàn bộ thông tin từ `product_catalog` (bao gồm giá cả và quyền lợi tại thời điểm đó) sẽ được copy vào bảng `tenant_subscriptions`10. Điều này đảm bảo rằng nếu Catalog gốc có thay đổi trong tương lai, quyền lợi và hóa đơn cũ của khách hàng vẫn được giữ nguyên tính chính xác1012.

Tóm tắt vị trí trong dòng chảy dữ liệu (Data Flow):

1\. **Thiết lập:** Admin tạo sản phẩm lõi trong `products` (YugabyteDB) và cấu hình thuộc tính động trong `product_catalog` (MongoDB)23.

2\. **Đóng gói:** `service_packages` tham chiếu thông tin từ cả hai bảng trên để tạo ra gói Combo bán cho người dùng613.

3\. **Thanh toán:** Khi Tenant mua hàng, dữ liệu từ Catalog được snapshot vào `tenant_subscriptions` để phục vụ Billing1011.

4\. **Phân tích:** Các sự kiện thay đổi hoặc sử dụng sản phẩm từ Catalog được đồng bộ qua **Kafka/Debezium** sang **ClickHouse** để làm báo cáo thống kê1415.

**Sự ví von:** Nếu hệ thống của bạn là một siêu thị, thì `products` là danh sách các mã vạch (SKU) cố định, còn `product_catalog` chính là **tờ menu hoặc nhãn dán chi tiết** trên từng kệ hàng. Menu này có thể thay đổi linh hoạt theo mùa hoặc theo chi nhánh (Tenant) mà không làm thay đổi hệ thống quản lý kho tổng của siêu thị.



bảng product\_catalog có thật sự cần thiết ko? lưu dạng metadata trong products được không?

Dựa trên các nguồn tài liệu và nguyên tắc thiết kế hệ thống SaaS quy mô lớn, câu trả lời cho vấn đề này cần được xem xét dựa trên **độ phức tạp của nghiệp vụ** và **tính linh hoạt** mà bạn muốn cung cấp cho khách hàng.

Về mặt kỹ thuật, bạn **hoàn toàn có thể lưu thông tin vào cột** **metadata** **(JSONB) trong bảng** **products** của YugabyteDB1. Tuy nhiên, việc duy trì một bảng `product_catalog` riêng biệt (thường ở MongoDB) vẫn mang lại những giá trị chiến lược quan trọng trong kiến trúc **Polyglot Persistence**2.

Dưới đây là phân tích chi tiết để bạn đưa ra quyết định:

1\. Khi nào nên gộp vào cột `metadata` trong bảng `products` (YugabyteDB)?

Bạn nên chọn phương án này nếu hệ thống của bạn ở giai đoạn **MVP hoặc quy mô vừa phải**, nơi mà:

• **Sự khác biệt không quá lớn:** Các thuộc tính bổ sung của sản phẩm giữa các Tenant (khách hàng) tương đối giống nhau (chiếm 80-90% cấu trúc chung)1.

• **Ưu tiên tính nhất quán (ACID):** Bạn muốn mọi thao tác cập nhật sản phẩm và thông tin thuộc tính phải nằm trong một giao dịch duy nhất để đảm bảo an toàn tuyệt đối3.

• **Giảm thiểu hạ tầng:** Tránh việc phải vận hành thêm cụm MongoDB và thiết lập luồng đồng bộ dữ liệu (CDC) phức tạp giữa SQL và NoSQL45.

2\. Khi nào bảng `product_catalog` (MongoDB) là "thật sự cần thiết"?

Trong các hệ thống "World-class SaaS", việc tách ra bảng này là để giải quyết bài toán **"Schema Flexibility" (Linh hoạt cấu trúc)**67. Bạn cần nó khi:

• **Tenant tự định nghĩa sản phẩm:** Mỗi Tenant có thể bán những loại hàng hóa hoàn toàn khác nhau (ví dụ: một bên bán Áo thun cần trường "Size, Màu", một bên bán Máy móc cần trường "Công suất, Điện áp"). MongoDB cho phép lưu các "Nested Object" sâu mà không cần lo lắng về việc khóa bảng (Lock table) như khi thực hiện `ALTER TABLE` trong SQL67.

• **Truy vấn theo tài liệu (Document Model):** Khi bạn muốn lấy toàn bộ cấu hình chi tiết của một sản phẩm cực kỳ phức tạp trong một lần đọc duy nhất (Single Read) thay vì phải thực hiện nhiều lệnh JOIN phức tạp trong SQL7.

• **Phân tách "Hot Data" và "Critical Data":** Dữ liệu cấu hình sản phẩm thường được truy cập rất thường xuyên nhưng ít thay đổi (Hot Data). Lưu tại MongoDB giúp giảm tải cho YugabyteDB để hệ thống này tập trung xử lý các giao dịch quan trọng hơn như Billing và Subscriptions36.

Bảng so sánh quyết định

| Tiêu chí | Lưu trong `metadata` (YugabyteDB) | Lưu tại `product_catalog` (MongoDB) |
| --- | --- | --- |
| **Tính linh hoạt** | Trung bình (Dựa trên JSONB) | **Rất cao** (Schema-less)7 |
| **Hiệu năng JOIN** | Tốt (Vì nằm cùng bảng) | Phức tạp (Cần ID tham chiếu)8 |
| **Độ phức tạp** | **Thấp** (Một DB duy nhất) | Cao (Cần quản lý 2 DB + CDC)4 |
| **Tính nhất quán** | Tuyệt đối (ACID)3 | Nhất quán cuối cùng (Eventual Consistency)4 |
| **Mở rộng (Scale)** | Tốt (YugabyteDB scale ngang)7 | Cực tốt cho dữ liệu phi cấu trúc6 |

Lời khuyên chiến lược

Dựa trên lịch sử trò chuyện và các nguồn tài liệu, bạn nên áp dụng quy tắc **"Bắt đầu chặt chẽ, mở rộng linh hoạt"**9:

1\. **Giai đoạn đầu:** Hãy tận dụng cột **metadata** **(JSONB)** trong bảng `products` để lưu trữ các thuộc tính động. YugabyteDB hỗ trợ Index GIN trên JSONB, cho phép bạn tìm kiếm bên trong các thuộc tính này rất nhanh10.

2\. **Khi quy mô lớn:** Nếu bạn thấy cột `metadata` trở nên quá cồng kềnh (ví dụ: hàng trăm trường khác nhau cho mỗi khách hàng) hoặc bạn cần cung cấp tính năng "Dynamic Form" cho khách hàng tự tạo trường dữ liệu sản phẩm, lúc đó hãy tách ra **MongoDB**26.

**Sự ví von:** Việc gộp vào `metadata` giống như bạn có một **ngăn kéo đa năng** trong tủ hồ sơ. Nó tiện lợi và nhanh chóng. Nhưng khi ngăn kéo đó chứa hàng nghìn loại giấy tờ lộn xộn, bạn sẽ cần một **kho lưu trữ riêng** (MongoDB) với hệ thống phân loại linh hoạt hơn để không làm hỏng cấu trúc của chiếc tủ chính (YugabyteDB)67.



có nên tách bảng products dùng cho saas với bảng products dùng cho các phần mềm như CRM, POS dùng cho khách hàng không?

Dựa trên kiến trúc hệ thống SaaS và các quy tắc thiết kế đã thảo luận, câu trả lời là **NÊN TÁCH BIỆT** bảng products dùng cho quản trị SaaS và bảng products dùng cho nghiệp vụ của khách hàng (CRM, POS, Ecommerce).

Việc gộp chung hai loại dữ liệu này sẽ dẫn đến xung đột về tên gọi (Naming Collision) và sai lệch về logic nghiệp vụ nghiêm trọng1. Dưới đây là phân tích chi tiết và giải pháp cải tiến dựa trên các nguồn tài liệu:

1\. Sự khác biệt giữa hai "Thế giới" dữ liệu

Hệ thống của bạn cần phân định rõ giữa **Dữ liệu Nền tảng (Platform Data)** và **Dữ liệu Nghiệp vụ của Tenant (Business Data)**2:

• **SaaS Core Products (Thế giới 1):** Đối tượng ở đây là các **gói phần mềm** hoặc **quyền sử dụng** (SaaS seats/licenses). Ví dụ: "Gói HRM Pro", "Gói POS Starter"34. Mục đích là để quản lý việc vận hành SaaS, tính tiền thuê bao và phân quyền ứng dụng56.

• **Business Products (Thế giới 2):** Đối tượng ở đây là các **hàng hóa hoặc dịch vụ** mà khách hàng (Tenant) bán cho người tiêu dùng cuối của họ. Ví dụ: Một cái áo, một ly cà phê, hoặc một linh kiện máy móc4. Mục đích là để quản lý kho, giá bán lẻ và doanh thu kinh doanh của Tenant2.

2\. Giải pháp tách biệt bằng Schema (Namespaces)

Thay vì cố gắng nhồi nhét vào một bảng duy nhất, bạn nên sử dụng tính năng **SCHEMA** của YugabyteDB/PostgreSQL để tạo ra các "khoang" dữ liệu riêng biệt7. Điều này giúp bạn giữ nguyên tên bảng là `products` ở cả hai nơi mà không bị xung đột8:

• **Schema** **platform\_billing****:** Chứa bảng `products` (hoặc đặt tên là `service_packages` để rõ nghĩa hơn). Bảng này lưu các gói cước phần mềm89.

• **Schema** **app\_pos** **hoặc** **app\_ecommerce****:** Chứa bảng `products` lưu hàng hóa bán lẻ (quần áo, đồ ăn)810.

**Ví dụ truy vấn minh bạch:**

• `SELECT * FROM platform_billing.products;` (Lấy thông tin gói cước SaaS)11.

• `SELECT * FROM app_pos.products;` (Lấy danh sách món ăn trong phần mềm POS)11.

3\. Đề xuất đặt tên để tránh rủi ro

Để đảm bảo an toàn tuyệt đối và dễ dàng cho đội ngũ phát triển (Dev Team), bạn có thể đổi tên các bảng thuộc nhóm Core để phân biệt rõ với nghiệp vụ4:

| Loại dữ liệu | Tên bảng đề xuất cho Core | Tên bảng trong App (CRM/POS) |
| --- | --- | --- |
| **Sản phẩm** | `service_packages` hoặc `saas_products` | `products` (Hàng hóa) |
| **Hóa đơn** | `subscription_invoices` | `invoices` (Hóa đơn bán lẻ) |
| **Đơn hàng** | `subscription_orders` | `orders` (Đơn hàng khách mua) |

4\. Lợi ích của việc tách biệt

1\. **Tính toàn vẹn dữ liệu:** Bạn có thể thiết lập các ràng buộc (Constraints) khác nhau. Ví dụ: Sản phẩm SaaS cần lưu cấu hình `entitlements_config` (JSONB) về quyền hạn ứng dụng, trong khi sản phẩm POS cần lưu `sku`, `weight`, `color`712.

2\. **Hiệu năng:** Các truy vấn báo cáo doanh số bán lẻ của POS (hàng triệu bản ghi hàng hóa) sẽ không làm chậm quá trình kiểm tra quyền hạn gói cước (Entitlement Check) của hệ thống Core1314.

3\. **Khả năng mở rộng:** Khi bạn phát triển thêm các App mới (như App Quản lý kho), bạn chỉ cần tạo Schema mới mà không sợ ảnh hưởng đến cấu trúc của bảng `products` đang phục vụ việc tính tiền SaaS15.

**Lời khuyên chiến lược:** Hệ thống SaaS thành công là hệ thống "Bắt đầu chặt chẽ, mở rộng linh hoạt"16. Việc tách biệt hai thế giới này ngay từ đầu sẽ cứu bạn khỏi hàng ngàn giờ sửa lỗi (fix bug) và cấu trúc lại dữ liệu (data migration) khi hệ thống đạt quy mô lớn16.

**Ví dụ minh họa:** Việc gộp chung hai bảng này giống như bạn dùng chung một cuốn sổ để ghi cả **"Danh sách các gói bảo hiểm"** mà nhân viên công ty đang bán và **"Danh sách các mặt hàng tạp hóa"** trong kho của khách hàng. Khi cần tính hoa hồng cho nhân viên hay kiểm kho cho khách, bạn sẽ phải sàng lọc rất vất vả và dễ nhầm lẫn "cái áo" với "quyền sử dụng phần mềm". Tách chúng ra hai cuốn sổ riêng (Schema) là cách quản lý chuyên nghiệp nhất.



vậy đổi tên để tách biệt đi, liệt kê lại các bảng của Nhóm Danh mục Sản phẩm & Gói dịch vụ dùng cho hệ thống saas

Việc tách biệt giữa **Dữ liệu Nền tảng (SaaS Platform)** và **Dữ liệu Nghiệp vụ của khách hàng (CRM, POS, Ecommerce)** là một bước đi chiến lược để tránh xung đột dữ liệu và đảm bảo tính nhất quán của hệ thống12. Theo các nguồn tài liệu, các bảng thuộc nhóm **Danh mục Sản phẩm & Gói dịch vụ** của hệ thống SaaS sẽ được đổi tên và quy hoạch lại để phân biệt rõ với hàng hóa của khách hàng3.

Dưới đây là danh sách và thiết kế chi tiết các bảng thuộc nhóm này, sử dụng **YSQL (YugabyteDB)** và **UUID v7**.

1\. Danh sách các bảng sau khi đổi tên (SaaS Core)

| Tên bảng cũ | Tên bảng mới (SaaS Core) | Vai trò |
| --- | --- | --- |
| `products` | **saas\_products** | Định nghĩa các dòng sản phẩm SaaS thương mại (VD: Bộ giải pháp HRM, CRM Suite)34. |
| (Mới) | **applications** | Định nghĩa các đơn vị phần mềm kỹ thuật cụ thể (VD: App Tuyển dụng, App Chấm công)5. |
| (Mới) | **app\_capabilities** | Danh mục các tính năng (Features) và giới hạn (Limits) của từng App6. |
| `packages` | **service\_packages** | Các gói cước thương mại (Bundle) được đóng gói để bán (VD: Gói Starter, Pro, Enterprise)78. |
| (Mới) | **tenant\_subscriptions** | Lưu thực thể gói cước mà khách hàng đã mua, bao gồm việc **Snapshot** (sao chép) quyền lợi và giá tại thời điểm mua910. |

\--------------------------------------------------------------------------------

2\. Thiết kế chi tiết các bảng

A. Bảng `saas_products` (Dòng sản phẩm SaaS)

Lưu trữ các dòng sản phẩm lớn của hệ thống để phân biệt với sản phẩm bán lẻ trong POS/CRM3.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh UUID v711. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (~ '^[a-z0-9-]+$')` | Mã dòng sản phẩm (VD: `hrm-suite`). |
| **name** | VARCHAR(255) | NO  |     |     | Tên dòng sản phẩm. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kinh doanh. |
| **metadata** | JSONB | NO  | `'{}'` |     | Chứa các thông tin mô tả động12. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ Optimistic Locking13. |

B. Bảng `applications` (Ứng dụng kỹ thuật)

Định nghĩa các đơn vị phần mềm độc lập có thể được gán vào gói cước5.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh UUID v7. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE` | Mã kỹ thuật (VD: `APP_HRM_RECRUIT`). |
| **name** | VARCHAR(255) | NO  |     |     | Tên hiển thị của ứng dụng. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái ứng dụng trên toàn sàn. |

C. Bảng `app_capabilities` (Tính năng & Hạn mức)

Định nghĩa các "khả năng" của ứng dụng trước khi được cấu hình vào gói cước6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh UUID v7. |
| **app\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu đến `applications._id`. |
| **code** | VARCHAR(50) | NO  |     |     | Mã tính năng (VD: `max_users`, `allow_sso`). |
| **type** | VARCHAR(20) | NO  |     | `BOOLEAN`, `NUMBER` | Phân loại là Tính năng hay Hạn mức14. |
| **default\_val** | JSONB | NO  |     |     | Giá trị mặc định của tính năng/hạn mức6. |

D. Bảng `service_packages` (Gói dịch vụ/Gói cước)

Đây là "thực đơn" để khách hàng chọn mua. Nó chứa cấu hình quyền hạn lồng nhau trong JSONB815.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh UUID v7. |
| **saas\_product\_id** | UUID | NO  |     | `FOREIGN KEY` | Thuộc dòng sản phẩm SaaS nào. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE` | Mã gói (VD: `enterprise-monthly`). |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` |     | Giá niêm yết của gói1216. |
| **currency** | VARCHAR(3) | NO  | `'VND'` |     | Mã tiền tệ ISO 421716. |
| **entitlements\_config** | **JSONB** | NO  | `'{}'` |     | **Quan trọng:** Chứa cấu hình tất cả App, Features và Limits của gói8. |

\--------------------------------------------------------------------------------

3\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. Tạo bảng Dòng sản phẩm SaaS
CREATE TABLE saas_products (
    _id UUID PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    metadata JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1
);

-- 2. Tạo bảng Ứng dụng kỹ thuật
CREATE TABLE applications (
    _id UUID PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 3. Tạo bảng Gói cước (Service Packages)
CREATE TABLE service_packages (
    _id UUID PRIMARY KEY,
    saas_product_id UUID NOT NULL REFERENCES saas_products(_id),
    code VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    entitlements_config JSONB NOT NULL DEFAULT '{}', -- Chứa cấu hình đa ứng dụng
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,
    CONSTRAINT chk_pkg_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED'))
);

-- CHIẾN LƯỢC ĐÁNH INDEX
-- Index hỗ trợ tìm kiếm gói cước theo dòng sản phẩm
CREATE INDEX idx_pkg_saas_product ON service_packages (saas_product_id);

-- Index GIN để tìm kiếm nhanh các gói có chứa một App cụ thể trong JSONB
CREATE INDEX idx_pkg_entitlements_gin ON service_packages USING GIN (entitlements_config);
```

4\. Các điểm cải tiến chính dựa trên yêu cầu

• **Tách biệt hoàn toàn:** Việc dùng tên `saas_products` và `service_packages` giúp hệ thống Core không bao giờ bị lẫn lộn với bảng `products` (hàng hóa) của các App POS/CRM sau này3.

• **Cấu trúc Phân cấp:** Một `saas_product` (Dòng SP) có thể có nhiều `service_packages` (Gói cước), và mỗi gói cước lại chứa nhiều `applications` thông qua JSONB1517.

• **Snapshot khi mua:** Khi khách hàng mua gói, toàn bộ nội dung `entitlements_config` từ `service_packages` sẽ được copy sang bảng `tenant_subscriptions` để bảo vệ quyền lợi khách hàng nếu giá hoặc gói gốc thay đổi sau này9.



thiết kế chi tiết bảng saas\_products dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS và kiến trúc dữ liệu đã thống nhất trong các nguồn tài liệu, bảng **saas\_products** được thiết kế để đóng vai trò là tầng định nghĩa dòng sản phẩm thương mại cốt lõi của nền tảng (Master Data)1,2.

Việc sử dụng tên bảng là `saas_products` giúp phân biệt hoàn toàn với hàng hóa kinh doanh của khách hàng (như POS, CRM) và tuân thủ quy tắc đặt tên số nhiều, dùng `snake_case`3,4.

1\. Thiết kế chi tiết bảng `saas_products`

Dữ liệu được lưu trữ tại tầng **YugabyteDB** để đảm bảo tính nhất quán ACID tuyệt đối cho các giao dịch và cấu hình quan trọng5,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian và tối ưu sharding7,8. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (~ '^[a-z0-9-]+$')` | Mã dòng sản phẩm (Slug). Ví dụ: `hrm-suite`, `crm-platform`. Chỉ chứa chữ thường, số và gạch ngang9,1. |
| **name** | TEXT | NO  |     | `CHECK (length(name) > 0)` | Tên sản phẩm hiển thị10. |
| **product\_type** | VARCHAR(20) | NO  | `'APP'` | `CHECK (product_type IN ('APP', 'DOMAIN', 'SSL', 'SERVICE'))` | Phân loại sản phẩm để xử lý logic: Ứng dụng, Tên miền, SSL hoặc Dịch vụ tư vấn1. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết sản phẩm. Dùng TEXT để không giới hạn độ dài8,10. |
| **base\_price** | NUMERIC(19,4) | NO  | `0` | `CHECK (base_price >= 0)` | Giá niêm yết cơ bản. Sử dụng **NUMERIC** để đảm bảo chính xác tuyệt đối trong tài chính7,11. |
| **currency** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency) = 3)` | Mã tiền tệ theo chuẩn ISO 4217 (VND, USD,...)7,10. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái cho phép kinh doanh sản phẩm này12,10. |
| **metadata** | JSONB | NO  | `'{}'` |     | Chứa các thông tin động, thuộc tính riêng biệt tùy theo loại sản phẩm11,10. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)13,14. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng15. |
| **deleted\_at** | TIMESTAMPTZ | YES | NULL |     | Hỗ trợ **Soft Delete** để bảo toàn dữ liệu lịch sử15. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho **Optimistic Locking**, ngăn chặn ghi đè dữ liệu đồng thời1. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Chỉ mục (Index)

Câu lệnh này tích hợp các quy tắc về kiểu dữ liệu chính xác (Decimal, Timestamptz) và các Standard Mixins để phục vụ quản trị và truy vết16,14.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE saas_products (
    -- I. Định danh (Identity)
    _id UUID PRIMARY KEY, -- Khuyến nghị sinh UUID v7 từ phía Application
    
    -- II. Thông tin nghiệp vụ (Business Data)
    code VARCHAR(50) NOT NULL,
    name TEXT NOT NULL,
    product_type VARCHAR(20) NOT NULL DEFAULT 'APP',
    description TEXT,
    
    -- III. Tài chính (Strict Money Rules)
    base_price NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- IV. Trạng thái & Dữ liệu động
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    metadata JSONB NOT NULL DEFAULT '{}',
    
    -- V. Audit & Versioning (Standard Mixins)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- VI. Các ràng buộc (Constraints)
    CONSTRAINT uq_saas_products_code UNIQUE (code),
    CONSTRAINT chk_saas_products_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_saas_products_type CHECK (product_type IN ('APP', 'DOMAIN', 'SSL', 'SERVICE')),
    CONSTRAINT chk_saas_products_price CHECK (base_price >= 0),
    CONSTRAINT chk_saas_products_currency_len CHECK (LENGTH(currency) = 3),
    CONSTRAINT chk_saas_products_name_len CHECK (LENGTH(name) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh theo mã sản phẩm (thường dùng cho Routing/Checkout)
CREATE UNIQUE INDEX idx_saas_products_code 
ON saas_products (code) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ lọc danh sách sản phẩm đang kinh doanh theo loại
CREATE INDEX idx_saas_products_active_type 
ON saas_products (product_type, is_active) 
WHERE deleted_at IS NULL;

-- Index GIN để hỗ trợ truy vấn sâu vào các thuộc tính động trong metadata
CREATE INDEX idx_saas_products_metadata 
ON saas_products USING GIN (metadata);

-- Comment mô tả bảng hỗ trợ tài liệu hóa (Documentation)
COMMENT ON TABLE saas_products IS 'Lưu trữ danh mục các dòng sản phẩm thương mại của nền tảng SaaS';
```

3\. Giải thích các điểm cốt lõi:

• **UUID v7:** Giúp dữ liệu được chèn vào YugabyteDB theo thứ tự thời gian, giảm hiện tượng "phân mảnh" index và tối ưu hóa việc dàn trải dữ liệu trên các nút (nodes)8,17.

• **JSONB Metadata:** Cho phép mở rộng các sản phẩm đặc thù (như Domain cần lưu thông tin Registrar, SSL cần lưu loại mã hóa) mà không phải thay đổi cấu trúc bảng vật lý5,10.

• **Partial Index:** Việc đánh index kèm điều kiện `WHERE deleted_at IS NULL` giúp tối ưu dung lượng và tăng tốc độ tìm kiếm cho các sản phẩm đang hoạt động18,19.

• **NUMERIC(19,4):** Đảm bảo không xảy ra sai số làm tròn trong các phép tính toán tiền tệ, một yêu cầu bắt buộc đối với hệ thống Billing7,11.



có thể thêm các sản phẩm dạng giải pháp, sẽ bao gồm nhiều saas\_products với các features và limits khác nhau không? (VD giải pháp trường học gồm cả LMS và HRM)

Hoàn toàn có thể và đây chính là mô hình **"Bundle/Combo"** tiêu chuẩn trong thiết kế SaaS Enterprise để giải quyết bài toán "Giải pháp tổng thể"12.

Trong kiến trúc chúng ta đã xây dựng, một **Giải pháp (Solution)** thực chất là một dòng sản phẩm (`saas_products`) đóng vai trò như một "ô dù" thương mại. Bên dưới nó, bạn sẽ tạo ra các **Gói dịch vụ (****service\_packages****)**3. Mỗi gói này sẽ chứa cấu hình đa ứng dụng (ví dụ: cả LMS và HRM) với các tính năng (`features`) và hạn mức (`limits`) được thiết lập riêng biệt cho từng ứng dụng đó thông qua cột **JSONB**45.

Dưới đây là thiết kế chi tiết bảng **service\_packages** được nâng cấp để đáp ứng mô hình "Giải pháp đa ứng dụng":

1\. Thiết kế chi tiết bảng `service_packages`

Bảng này đóng vai trò là thực thể chốt quyền lợi (Entitlements). Khi bạn bán một "Giải pháp trường học", gói này sẽ chứa cấu hình của cả LMS và HRM26.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, giúp sắp xếp theo thời gian và tối ưu sharding78. |
| **saas\_product\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu tới `saas_products(_id)` (Dòng giải pháp, VD: Giải pháp trường học)29. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (~ '^[a-z0-9-]+$')` | Mã gói (VD: `school-standard-monthly`). Chỉ chứa chữ thường, số và gạch ngang1011. |
| **name** | VARCHAR(255) | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của gói (VD: Gói trường học Tiêu chuẩn)11. |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (price_amount >= 0)` | Giá của toàn bộ giải pháp (Combo). Đảm bảo chính xác tuyệt đối1213. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ ISO 42171214. |
| **entitlements\_config** | **JSONB** | NO  | `'{}'` |     | **Trái tim của giải pháp:** Chứa cấu hình lồng nhau của nhiều App, Features và Limits4.... |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED'))` | Trạng thái kinh doanh của gói415. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho **Optimistic Locking** khi nhiều người cùng sửa cấu hình gói816. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)1216. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng16. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Cấu trúc này cho phép bạn định nghĩa một "Giải pháp" linh hoạt bằng cách nhồi cấu hình nhiều App vào một dòng dữ liệu duy nhất1718.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE service_packages (
    -- I. Định danh & Liên kết dòng giải pháp
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    saas_product_id UUID NOT NULL,
    
    -- II. Thông tin thương mại
    code VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    
    -- III. Tài chính
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- IV. Cấu hình Giải pháp (Đa ứng dụng + Đa tính năng/hạn mức)
    -- Ví dụ cấu trúc:
    -- {
    --   "LMS_APP": {"features": {"video_lesson": true}, "limits": {"max_courses": 100}},
    --   "HRM_APP": {"features": {"payroll": true}, "limits": {"max_employees": 50}}
    -- }
    entitlements_config JSONB NOT NULL DEFAULT '{}',
    
    -- V. Trạng thái & Versioning
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version BIGINT NOT NULL DEFAULT 1,

    -- VI. Các ràng buộc (Constraints)
    CONSTRAINT fk_pkg_saas_product FOREIGN KEY (saas_product_id) REFERENCES saas_products(_id),
    CONSTRAINT uq_service_packages_code UNIQUE (code),
    CONSTRAINT chk_pkg_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_pkg_price CHECK (price_amount >= 0),
    CONSTRAINT chk_pkg_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED')),
    CONSTRAINT chk_pkg_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lấy danh sách các gói thuộc một giải pháp (VD: Các gói của 'Giải pháp trường học')
CREATE INDEX idx_service_packages_saas_product ON service_packages (saas_product_id) 
WHERE deleted_at IS NULL;

-- Index GIN để tìm kiếm nhanh các giải pháp có chứa một ứng dụng cụ thể
-- Ví dụ: Tìm tất cả các giải pháp combo có chứa 'HRM_APP'
CREATE INDEX idx_service_packages_entitlements ON service_packages USING GIN (entitlements_config);

-- Index hỗ trợ tra cứu nhanh gói theo mã khi khách hàng đăng ký
CREATE UNIQUE INDEX idx_service_packages_lookup ON service_packages (code) 
WHERE status = 'ACTIVE' AND deleted_at IS NULL;
```

3\. Giải thích về khả năng tùy biến Giải pháp

• **JSONB Entitlements:** Đây là điểm mấu chốt. Thay vì tạo các bảng liên kết phức tạp, JSONB cho phép bạn lưu trữ cấu hình không giới hạn số lượng ứng dụng trong một giải pháp1920. Bạn có thể dễ dàng khai báo trong cùng một giải pháp: LMS được dùng tính năng A, HRM được dùng tính năng B, và CRM (nếu có) bị giới hạn 10 người dùng621.

• **Snapshot Readiness:** Khi khách hàng mua giải pháp này, toàn bộ cấu hình phức tạp trong `entitlements_config` sẽ được sao chép nguyên trạng vào bảng `tenant_subscriptions`2223. Điều này giúp hệ thống kiểm tra quyền lợi của khách hàng cực nhanh (chỉ cần 1 truy vấn JSONB) mà không bị ảnh hưởng khi bạn thay đổi cấu hình gốc của giải pháp trong tương lai1824.

• **Hiệu năng:** Việc sử dụng **GIN Index** trên cột JSONB cho phép hệ thống trả lời ngay lập tức câu hỏi: "Những giải pháp (Solution) nào đang chứa ứng dụng LMS?" mà không cần thực hiện các lệnh JOIN nặng nề giữa nhiều bảng2526.

**Sự ví von:** Thiết kế này giống như một **"Gói Combo truyền hình + Internet + Di động"**. Bạn không cần tạo 3 hợp đồng riêng lẻ. Thay vào đó, bạn có một hợp đồng duy nhất (Service Package) ghi rõ: Internet tốc độ 100Mbps (Limit), Truyền hình được xem kênh HBO (Feature), và Di động được 50GB data (Limit). Mọi thứ gói gọn trong một "Giải pháp kết nối" tiện lợi127.



quan hệ giữa saas\_products với applications?

Dựa trên các nguồn tài liệu về kiến trúc hệ thống SaaS, mối quan hệ giữa **saas\_products** và **applications** là mối quan hệ phân cấp từ tầng thương mại đến tầng kỹ thuật, được kết nối thông qua các gói dịch vụ,.

Mối quan hệ này có thể được phân tích qua các cấp độ sau:

1\. Phân tách vai trò: Thương mại vs Kỹ thuật

• **saas\_products** **(Dòng sản phẩm/Giải pháp):** Đóng vai trò là "ô dù" thương mại hoặc các dòng sản phẩm lớn của nền tảng (ví dụ: "Bộ giải pháp Nhân sự", "Hệ thống Quản lý Bán lẻ"),12. Đây là tầng định nghĩa danh mục sản phẩm thương mại cốt lõi để khách hàng nhận diện và lựa chọn,.

• **applications** **(Ứng dụng kỹ thuật):** Là các đơn vị phần mềm độc lập cụ thể (ví dụ: App Tuyển dụng, App Chấm công, App CRM)13. Đây là những thực thể kỹ thuật thực sự thực hiện chức năng phần mềm,.

2\. Quan hệ qua bảng trung gian `service_packages`

Mối quan hệ giữa hai bảng này không phải là quan hệ trực tiếp mà được thiết lập thông qua bảng **service\_packages** (Gói cước),4.

• Một dòng sản phẩm (`saas_products`) có thể bao gồm nhiều gói cước khác nhau (ví dụ: Gói Starter, Gói Pro, Gói Enterprise),4.

• Mỗi gói cước này sẽ **đóng gói (bundle)** một hoặc nhiều ứng dụng (`applications`) lại với nhau để bán cho khách hàng,5.

3\. Cấu hình quyền hạn (Entitlements)

Mối quan hệ này trở nên linh hoạt nhờ sử dụng cột **JSONB** trong bảng gói cước:

• Bên trong một `saas_product`, gói dịch vụ sẽ xác định ứng dụng nào được phép sử dụng thông qua trường `entitlements_config` hoặc `included_apps_config`46.

• Điều này cho phép cùng một `application` (ví dụ: App HRM) xuất hiện trong nhiều `saas_products` khác nhau (ví dụ: xuất hiện trong "Giải pháp Trường học" và cả "Giải pháp Doanh nghiệp") với các tính năng và hạn mức khác nhau tùy theo cấu hình của gói cước,5.

4\. Tóm tắt luồng dữ liệu

1\. **Định nghĩa:** Hệ thống định nghĩa ứng dụng tại bảng `applications`3 và dòng sản phẩm tại `saas_products`2.

2\. **Liên kết:** Admin tạo ra `service_packages` thuộc về một `saas_product_id`4.

3\. **Đóng gói:** Trong gói cước đó, Admin liệt kê các mã ứng dụng (`app_code`) vào cột JSONB, kèm theo các tùy chỉnh về tính năng (`features`) và hạn mức (`limits`) dành riêng cho ứng dụng đó trong gói này45.

**Ví dụ minh họa:** Dòng sản phẩm **"SaaS Suite"** (`saas_products`) có gói **"Doanh nghiệp"** (`service_packages`). Gói này chứa đồng thời ứng dụng **"LMS"** và **"HRM"** (`applications`)5. Trong đó, App LMS được cấp tính năng "Video lesson" và HRM bị giới hạn "50 nhân viên",.

Mối quan hệ này giống như **thực đơn của một nhà hàng**: `saas_products` là các "Combo" (Combo gia đình, Combo cá nhân), còn `applications` là các "Món ăn" lẻ. Nhà hàng (Hệ thống) sẽ lấy các món ăn lẻ này để tạo thành các Combo khác nhau với định lượng (hạn mức) khác nhau tùy theo giá tiền của gói cước đó,.



liệt kê đầy đủ các bảng thuộc Nhóm Danh mục Sản phẩm & Gói dịch vụ, bao gồm cả các bảng thống kê nếu có

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng và kiến trúc dữ liệu đã được thảo luận trong các nguồn tài liệu, nhóm bảng **Danh mục Sản phẩm & Gói dịch vụ** được phân chia theo mô hình **Polyglot Persistence** (đa lưu trữ) để tối ưu hóa giữa tính nhất quán giao dịch và khả năng phân tích dữ liệu lớn12.

Dưới đây là danh sách đầy đủ các bảng thuộc nhóm này, chia theo mục đích vận hành và thống kê:

1\. Nhóm Dữ liệu Danh mục & Cấu hình thương mại (Lưu tại YugabyteDB)

Nhóm này đóng vai trò là "nguồn sự thật" (Source of Truth) cho các giao dịch mua bán và thiết lập quyền hạn34.

• **saas\_products** **(Dòng sản phẩm):** Định nghĩa các dòng sản phẩm lớn của nền tảng như "Bộ giải pháp Nhân sự" hay "Hệ thống CRM"56.

• **applications** **(Ứng dụng kỹ thuật):** Quản lý danh sách các đơn vị phần mềm độc lập có thể được đóng gói vào các gói cước7.

• **app\_capabilities** **(Khả năng ứng dụng):** Định nghĩa chi tiết các tính năng (Features - dạng Boolean) và hạn mức (Limits - dạng Number) mà mỗi ứng dụng hỗ trợ8.

• **service\_packages** **(Gói dịch vụ):** Đóng vai trò là "Menu" bán hàng, nơi kết hợp nhiều ứng dụng và cấu hình quyền hạn (`entitlements_config`) trong cột JSONB910.

• **tenant\_subscriptions** **(Thuê bao khách hàng):** Lưu thông tin gói cước mà khách hàng đã mua, bao gồm bản sao (snapshot) của toàn bộ quyền hạn và giá cả tại thời điểm giao dịch để đảm bảo tính nhất quán11....

• **license\_allocations** **(Phân bổ giấy phép):** Quản lý số lượng "ghế" (seats) đã mua so với số lượng đã gán thực tế cho nhân viên của từng khách hàng14.

2\. Nhóm Dữ liệu Thuộc tính Động (Lưu tại MongoDB)

Dùng để quản lý các thông tin không cấu trúc hoặc thay đổi tùy theo đặc thù của từng khách hàng115.

• **product\_catalog****:** Lưu trữ danh mục sản phẩm với các thuộc tính động (ví dụ: kích cỡ, màu sắc, thông số kỹ thuật riêng) mà không cần thay đổi cấu trúc bảng SQL15.

3\. Nhóm Bảng Thống kê & Phân tích (Lưu tại ClickHouse & YugabyteDB)

Nhóm này phục vụ mục đích theo dõi lượng tiêu dùng (Metering) và báo cáo doanh thu1617.

• **usage\_events** **(ClickHouse):** Lưu trữ hàng tỷ bản ghi thô về mọi hành động tiêu dùng của người dùng (như gửi email, tải tệp) để phục vụ phân tích thời gian thực18....

• **api\_usage\_logs** **(ClickHouse):** Ghi nhận nhật ký sử dụng API và băng thông để làm cơ sở tính tiền hoặc giới hạn tốc độ (Rate Limit)2122.

• **tenant\_usages** **(YugabyteDB):** Lưu trữ dữ liệu sử dụng đã được tổng hợp theo chu kỳ (giờ/ngày) từ ClickHouse để phục vụ việc xuất hóa đơn chính xác23....

• **audit\_logs** **(ClickHouse):** Nhật ký hệ thống ghi lại ai đã thay đổi cấu hình sản phẩm hoặc gói dịch vụ vào lúc nào2627.

Tóm tắt kiến trúc phân lớp

| Tầng dữ liệu | Công nghệ | Các bảng tiêu biểu |
| --- | --- | --- |
| **Giao dịch (ACID)** | **YugabyteDB** | `saas_products`, `service_packages`, `tenant_subscriptions`, `tenant_usages`3.... |
| **Cấu hình Động** | **MongoDB** | `product_catalog`, `tenant_app_configs`1526. |
| **Phân tích (OLAP)** | **ClickHouse** | `usage_events`, `api_usage_logs`, `audit_logs`21.... |

**Sự ví von:** Hãy tưởng tượng hệ thống như một **nhà hàng lớn**. Bảng `saas_products` và `service_packages` là **cuốn thực đơn** niêm yết; `tenant_subscriptions` là **tờ hóa đơn** khách đã đặt; `usage_events` là **camera giám sát** ghi lại từng miếng ăn của khách; và `tenant_usages` là **bản tổng hợp cuối ngày** để nhà hàng tính toán lợi nhuận và nguyên liệu đã tiêu thụ.



nếu chỉ dùng cho saas thì có cần bảng product\_catalog ko?

Dựa trên các nguồn tài liệu và triết lý kiến trúc hệ thống SaaS đa khách hàng (Multi-tenant) mà chúng ta đã thảo luận, việc có cần bảng **product\_catalog** (thường lưu ở MongoDB) hay không khi "chỉ dùng cho SaaS" phụ thuộc vào việc bạn định nghĩa "SaaS" ở cấp độ nào: Quản lý gói cước của nền tảng hay Quản lý hàng hóa của khách hàng.

Dưới đây là phân tích chi tiết để bạn đưa ra quyết định:

1\. Nếu "SaaS" chỉ là quản lý các Gói cước và Thuê bao (Platform Level)

Nếu mục tiêu của bạn chỉ là quản lý các dòng sản phẩm phần mềm (ví dụ: HRM, CRM) và các gói cước (Starter, Pro, Enterprise) để tính tiền khách hàng, thì bảng `product_catalog` **không hoàn toàn bắt buộc** dưới dạng một database NoSQL riêng biệt.

• **Lý do:** Các thông tin này mang tính chất giao dịch (Transactional) và yêu cầu tính nhất quán (ACID) cao12.

• **Giải pháp:** Bạn nên sử dụng bảng **saas\_products** và **service\_packages** trong **YugabyteDB**34. Các thuộc tính bổ sung hoặc mô tả linh hoạt có thể được lưu trữ trong cột **metadata** **(JSONB)** của chính các bảng này56. Điều này giúp đảm bảo dữ liệu "chảy" mượt mà trong các giao dịch Billing và Subscription mà không cần quản lý thêm một hệ quản trị cơ sở dữ liệu (DBMS) khác78.

2\. Khi nào `product_catalog` là "Thật sự cần thiết"?

Dù chỉ dùng cho SaaS, bảng `product_catalog` (thường đặt ở MongoDB theo kiến trúc Polyglot Persistence) sẽ trở nên **cần thiết** nếu hệ thống của bạn cung cấp các tính năng sau cho khách hàng (Tenants):

• **Quản lý sản phẩm nghiệp vụ linh hoạt:** Nếu ứng dụng SaaS của bạn (ví dụ: một App POS hoặc Ecommerce tích hợp) cho phép mỗi khách hàng tự định nghĩa các loại hàng hóa với thuộc tính hoàn toàn khác nhau9. Tenant A bán quần áo cần trường "Size, Màu"; Tenant B bán máy móc cần trường "Công suất, Điện áp"10.

• **Schema Flexibility (Linh hoạt cấu trúc):** Khi các thuộc tính sản phẩm thay đổi thường xuyên theo ngữ cảnh của từng khách hàng, việc dùng MongoDB giúp tránh thao tác `ALTER TABLE` gây khóa bảng (lock table) trong SQL10.

• **Document Model:** Khi bạn cần lấy toàn bộ thông tin chi tiết, cấu hình phức tạp của một sản phẩm trong một lần đọc duy nhất (Single Read) thay vì phải JOIN nhiều bảng quan hệ10.

3\. Chiến lược "Bắt đầu chặt chẽ, mở rộng linh hoạt"

Theo lời khuyên từ các nguồn, bạn nên tuân thủ lộ trình sau để tối ưu hóa nguồn lực7:

1\. **Giai đoạn MVP (Khởi đầu):** Gộp toàn bộ thông tin sản phẩm vào bảng **saas\_products** trong YugabyteDB. Sử dụng cột **metadata** **kiểu JSONB** để lưu trữ các thông tin động56. Cách này giúp hệ thống đơn giản, chỉ cần quản lý một loại Database mà vẫn đảm bảo tính chính xác cho Billing8.

2\. **Giai đoạn Scale (Mở rộng):** Khi danh mục sản phẩm của các Tenant trở nên quá cồng kềnh, không đồng nhất và làm chậm các truy vấn SQL, lúc đó bạn mới nên tách phần "Catalog động" này sang **MongoDB**19. Khi đó, YugabyteDB chỉ giữ các thông tin lõi để tính tiền (ID, Code, Price), còn MongoDB giữ toàn bộ "linh hồn" chi tiết của sản phẩm211.

Tóm tắt quyết định

| Đặc điểm hệ thống SaaS | Có cần `product_catalog` (NoSQL) không? | Giải pháp khuyến nghị |
| --- | --- | --- |
| Chỉ quản lý gói cước (Starter/Pro), thuộc tính đơn giản. | **KHÔNG** | Dùng bảng SQL + cột JSONB26. |
| Cho phép Tenant tự tạo sản phẩm với hàng trăm thuộc tính khác nhau. | **CÓ** | Dùng MongoDB cho Catalog9. |
| Cần tính năng tìm kiếm sản phẩm cực nhanh với cấu trúc dữ liệu lồng nhau sâu. | **CÓ** | Tách sang Document Store10. |

**Sự ví von:** Việc gộp thông tin vào cột `metadata` giống như bạn dùng một **ngăn kéo đa năng** trong tủ hồ sơ để chứa mọi thứ lặt vặt. Nó rất tiện khi đồ đạc còn ít. Nhưng khi bạn có hàng nghìn loại hồ sơ khác nhau với hình thù kỳ dị, bạn sẽ cần một **kho lưu trữ riêng chuyên dụng** (MongoDB) để không làm hỏng cấu trúc ngăn nắp của chiếc tủ chính (YugabyteDB).



saas\_products chỉ là quản lý các Gói cước và Thuê bao

Dựa trên các nguồn tài liệu và lịch sử thiết kế hệ thống, nhận định của bạn về việc **saas\_products** dùng để quản lý các dòng sản phẩm và phục vụ việc bán gói cước/thuê bao là hoàn toàn chính xác. Trong mô hình SaaS đa khách hàng, bảng này đóng vai trò là **Dữ liệu Master (Master Data)** ở tầng nền tảng, tách biệt hoàn toàn với dữ liệu nghiệp vụ của khách hàng1,2.

Dưới đây là phân tích chi tiết về vai trò, cấu trúc và mối quan hệ của bảng này trong hệ thống:

1\. Vai trò chiến lược của `saas_products`

Bảng này không lưu trữ hàng hóa bán lẻ (như cái áo, ly cà phê) mà lưu trữ các **dòng giải pháp phần mềm** mà bạn cung cấp2.

• **Định nghĩa dòng sản phẩm:** Ví dụ như "Bộ giải pháp Nhân sự" (HRM Suite) hoặc "Nền tảng Quản trị Bán hàng" (CRM Platform)3,4.

• **Phân cấp thương mại:** Một `saas_products` sẽ là "ô dù" cho nhiều `service_packages` (Gói cước như Starter, Pro, Enterprise)5,3.

• **Tránh xung đột dữ liệu:** Việc sử dụng tên `saas_products` thay vì `products` giúp hệ thống không bị lẫn lộn khi tích hợp thêm các ứng dụng như POS hay Ecommerce, nơi khách hàng cũng có danh mục "sản phẩm" riêng của họ2,6.

2\. Thiết kế chi tiết bảng `saas_products` (YSQL)

Dữ liệu này yêu cầu tính nhất quán tuyệt đối (ACID), do đó được lưu trữ tại **YugabyteDB**7,1.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh **UUID v7**, giúp sắp xếp theo thời gian và tối ưu sharding8,9. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (~ '^[a-z0-9-]+$')` | Mã định danh sản phẩm (Slug). Ví dụ: `hrm-suite`10,5. |
| **name** | TEXT | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của dòng sản phẩm10,11. |
| **product\_type** | VARCHAR(20) | NO  | `'APP'` | `CHECK (IN ('APP', 'DOMAIN', 'SERVICE'))` | Phân loại: Ứng dụng, Tên miền hoặc Dịch vụ đi kèm. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kinh doanh của dòng sản phẩm này11,12. |
| **metadata** | JSONB | NO  | `'{}'` |     | Lưu thông tin mô tả động, ảnh minh họa hoặc cấu hình đặc thù10,13. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)14,15. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Dùng cho **Optimistic Locking** để chống ghi đè dữ liệu16,17. |

3\. Câu lệnh YSQL tạo bảng và Index

```
-- Tạo bảng saas_products trong Schema platform_core để quản lý tập trung [18]
CREATE TABLE saas_products (
    _id UUID PRIMARY KEY,
    code VARCHAR(50) NOT NULL,
    name TEXT NOT NULL,
    product_type VARCHAR(20) NOT NULL DEFAULT 'APP',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    metadata JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ, -- Hỗ trợ Soft Delete [15]
    version BIGINT NOT NULL DEFAULT 1,

    CONSTRAINT uq_saas_products_code UNIQUE (code),
    CONSTRAINT chk_saas_products_code_fmt CHECK (code ~ '^[a-z0-9-]+$')
);

-- Index hỗ trợ tra cứu nhanh theo mã dòng sản phẩm [9]
CREATE UNIQUE INDEX idx_saas_products_code 
ON saas_products (code) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ lọc danh sách sản phẩm theo trạng thái [9]
CREATE INDEX idx_saas_products_active 
ON saas_products (is_active) 
WHERE deleted_at IS NULL;
```

4\. Mối quan hệ trong dòng chảy Thuê bao (Subscription Flow)

Để hiện thực hóa việc quản lý gói cước và thuê bao, `saas_products` kết nối với các thực thể khác như sau:

1\. **Gói cước (****service\_packages****):** Mỗi gói cước (ví dụ: "HRM Pro Monthly") sẽ tham chiếu đến một `saas_product_id`12. Gói cước này chứa cấu hình quyền hạn (`entitlements_config`) quy định khách hàng được dùng những tính năng gì12,18.

2\. **Thuê bao (****tenant\_subscriptions****):** Khi một khách hàng (Tenant) mua gói, hệ thống sẽ thực hiện **Snapshot** (sao chép) toàn bộ thông tin từ gói cước vào bảng thuê bao19,20. Việc này đảm bảo nếu bạn thay đổi giá hoặc tính năng của `saas_products` trong tương lai, quyền lợi của khách hàng đã mua vẫn được bảo toàn19,21.

3\. **Hóa đơn (****subscription\_invoices****):** Các hóa đơn tiền thuê phần mềm sẽ được tạo dựa trên thông tin từ thuê bao và dòng sản phẩm này, sử dụng kiểu dữ liệu `NUMERIC(19,4)` để đảm bảo tính chính xác tuyệt đối về tiền tệ22,23.

**Tóm lại:** `saas_products` là "gốc" của danh mục kinh doanh. Nó xác định bạn đang bán cái gì, trong khi các bảng liên quan khác sẽ xác định bán như thế nào và cho ai3,24.



thống kê lượng truy cập vào saas\_products lưu ở đâu?

Dựa trên các quy chuẩn về kiến trúc **Polyglot Persistence** trong hệ thống SaaS mà chúng ta đã thảo luận, các dữ liệu liên quan đến thống kê và lượng truy cập (Access Logs) không được lưu trữ trong cơ sở dữ liệu giao dịch (như YugabyteDB) mà được lưu trữ tại **tầng dữ liệu phân tích (Analytical Database)**1,2.

Cụ thể, thống kê lượng truy cập vào các gói dịch vụ hay dòng sản phẩm (`saas_products`) được lưu trữ như sau:

1\. Nơi lưu trữ chính: ClickHouse

Toàn bộ dữ liệu về lịch sử truy cập, log sự kiện và thống kê sử dụng được lưu trữ tại **ClickHouse**1,3. Đây là lựa chọn tối ưu vì:

• **Khả năng nén dữ liệu:** ClickHouse là CSDL dạng cột (Columnar Store), có khả năng nén dữ liệu cực tốt (tỷ lệ lên đến 10:1), giúp tiết kiệm chi phí khi lưu trữ hàng tỷ bản ghi log4.

• **Tốc độ truy vấn:** Việc tính toán các số liệu thống kê (SUM, COUNT, AVG) trên tập dữ liệu khổng lồ chỉ mất vài mili-giây, trong khi các CSDL truyền thống có thể bị treo hoặc timeout4,5.

2\. Các bảng dữ liệu liên quan

Trong ClickHouse, lượng truy cập và sử dụng sản phẩm thường nằm trong các bảng sau:

• **api\_usage\_logs****:** Ghi nhận nhật ký sử dụng API, đếm số lượng request và băng thông khi người dùng truy cập hoặc tương tác với các sản phẩm/gói dịch vụ4,6.

• **usage\_events****:** Lưu trữ các bản ghi thô về mọi hành động tiêu dùng hoặc truy cập cụ thể của khách hàng7,8.

• **audit\_logs****:** Lưu vết chi tiết về việc "ai đã làm gì, vào lúc nào", giúp truy xuất lịch sử tương tác với các thiết lập sản phẩm4,9.

3\. Luồng dữ liệu thống kê (Data Flow)

Dữ liệu không được ghi trực tiếp từ ứng dụng vào ClickHouse để tránh làm chậm hệ thống. Quy trình diễn ra như sau:

1\. **Ghi nhận:** Khi có lượt truy cập, Backend bắn một sự kiện (Event) vào **Kafka**10,11.

2\. **Đồng bộ (CDC):** Sử dụng các công cụ như **Debezium** để lắng nghe thay đổi hoặc chuyển tiếp sự kiện từ Kafka vào ClickHouse5.

3\. **Hiển thị:** Khi bạn cần xem báo cáo Dashboard về lượng truy cập sản phẩm, Backend sẽ thực hiện truy vấn (Read) trực tiếp từ **ClickHouse** thay vì truy vấn vào YugabyteDB để đảm bảo không ảnh hưởng đến các giao dịch thanh toán đang diễn ra12.

4\. Bảng tổng hợp quy chiếu lưu trữ

| Loại dữ liệu | Database lưu trữ | Mục đích |
| --- | --- | --- |
| **Thống kê truy cập / Log** | **ClickHouse** | Phục vụ báo cáo, phân tích và theo dõi lượng tiêu dùng1,6. |
| **Cấu hình sản phẩm gốc** | **YugabyteDB** | Đảm bảo tính nhất quán khi mua bán và thanh toán1,13. |
| **Dữ liệu tạm / Cache** | **Redis** | Lưu trữ số lượng truy cập tạm thời (counters) để giới hạn tốc độ (Rate Limiting)10,14. |

**Sự ví von:** Nếu hệ thống SaaS của bạn là một tòa nhà văn phòng, thì `saas_products` là các **phòng dịch vụ** bạn cho thuê. YugabyteDB là **cuốn sổ đỏ và hợp đồng** (dữ liệu quan trọng, không được sai lệch), còn ClickHouse chính là **hệ thống camera giám sát và máy đếm lượt người ra vào** (lưu trữ khối lượng lớn dữ liệu lịch sử để bạn biết phòng nào đang "hot" và có nhiều người ghé thăm nhất).



liệt kê đầy đủ các bảng thuộc Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing), bao gồm cả các bảng thống kê nếu có

Dựa trên các quy tắc thiết kế hệ thống SaaS quy mô lớn và kiến trúc **Polyglot Persistence** đã thống nhất, nhóm bảng **Quản lý Thuê bao (Subscriptions - Fixed Billing)** đóng vai trò là "két sắt an toàn", yêu cầu tính nhất quán ACID tuyệt đối1,2.

Dưới đây là danh sách đầy đủ các bảng thuộc nhóm này, được phân loại theo vai trò vận hành và thống kê phân tích:

1\. Nhóm bảng Giao dịch & Cấu hình Thuê bao (Lưu tại YugabyteDB)

Nhóm này lưu trữ các thực thể cốt lõi phục vụ việc tính tiền và kiểm soát quyền hạn. Dữ liệu tại đây phải đảm bảo độ chính xác tài chính cao (sử dụng kiểu `NUMERIC(19, 4)`)3,4.

• **saas\_products** **(Dòng sản phẩm):** Định nghĩa các dòng sản phẩm thương mại lớn (ví dụ: HRM Suite, CRM Suite)5,6.

• **service\_packages** **(Danh mục gói cước):** Đóng vai trò là "thực đơn" bán hàng, định nghĩa các gói như Starter, Pro, Enterprise7,8. Bảng này chứa cột `included_apps_config` (JSONB) để quy định các ứng dụng và hạn mức mặc định đi kèm8,9.

• **tenant\_subscriptions** **(Thuê bao hiện hành):** Đây là bảng quan trọng nhất, lưu trữ thông tin gói cước mà khách hàng đang sử dụng7,10.

    ◦ **Quy tắc Snapshot:** Khi Tenant mua gói, hệ thống sẽ copy toàn bộ giá và quyền lợi vào cột `granted_entitlements` (JSONB) để bảo toàn quyền lợi khách hàng ngay cả khi gói cước gốc thay đổi11,10,12.

• **subscription\_invoices** **(Hóa đơn thuê bao):** Lưu trữ lịch sử hóa đơn, số tiền, trạng thái thanh toán và mã tiền tệ (ISO 4217)13,14,15.

• **tenant\_wallets** **(Ví tiền của Tenant):** Quản lý số dư tiền nạp trước (Prepaid) của khách hàng để trừ dần theo mô hình FinOps16,17.

• **wallet\_transactions** **(Giao dịch ví):** Nhật ký bất biến (Immutable) ghi lại mọi biến động nạp, trừ hoặc hoàn tiền trong ví17,18.

• **license\_allocations** **(Phân bổ giấy phép):** Quản lý số lượng "ghế" (seats) hoặc giấy phép đã mua so với số lượng đã gán thực tế cho nhân viên19,20.

• **price\_adjustments** **(Điều chỉnh giá):** Lưu trữ các thông tin chiết khấu hoặc giảm giá tùy chỉnh cho từng hóa đơn để đảm bảo tính minh bạch11.

2\. Nhóm bảng Thống kê & Phân tích (Lưu tại ClickHouse & YugabyteDB)

Nhóm này phục vụ mục đích theo dõi hành vi tiêu dùng và báo cáo doanh thu quy mô lớn.

• **usage\_events** **(Sự kiện tiêu dùng - ClickHouse):** Lưu trữ hàng tỷ bản ghi thô về mọi hành động của người dùng (ví dụ: số email đã gửi, số GB đã upload)21,22,23.

• **api\_usage\_logs** **(Nhật ký gọi API - ClickHouse):** Ghi nhận số lượng yêu cầu và băng thông sử dụng để phục vụ báo cáo hoặc giới hạn tốc độ (Rate Limit)21,24.

• **tenant\_usages** **(Tổng hợp tiêu dùng - YugabyteDB):** Dữ liệu được các Worker tổng hợp định kỳ từ ClickHouse và ghi vào YugabyteDB để làm cơ sở tính tiền cho các gói cước trả sau hoặc trả theo nhu cầu (Metering)25,26,27.

• **business\_reports** **(Báo cáo doanh thu - ClickHouse):** Các bảng tổng hợp phục vụ việc truy vấn báo cáo doanh thu theo năm hoặc xu hướng khách hàng với tốc độ mili-giây21,28.

Tóm tắt các trường dữ liệu tiêu chuẩn trong nhóm Subscriptions

Để đảm bảo hệ thống vận hành trơn tru, mọi bảng trong nhóm này đều tuân thủ các quy chuẩn sau:

1\. **Định danh:** Luôn sử dụng `_id` kiểu **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và sharding dữ liệu trên YugabyteDB29,30.

2\. **Tiền tệ:** Luôn sử dụng `NUMERIC(19, 4)` kèm theo cột mã tiền tệ (ví dụ: `currency_code`)3,14.

3\. **Audit Logs:** Mọi thay đổi về gói cước hay thuê bao đều phải có các trường `created_at`, `updated_at`, `version` (để dùng Optimistic Locking) và được đồng bộ sang bảng `audit_logs` tại ClickHouse để truy vết21,31,32.

\--------------------------------------------------------------------------------

**Sự ví von:** Hệ thống quản lý thuê bao này giống như một **khu vui chơi cao cấp**.

• `service_packages` là **bảng giá** niêm yết tại cổng.

• `tenant_subscriptions` là **chiếc vòng tay** (Snapshot) mà khách đeo, ghi rõ họ được chơi những trò gì và trong bao lâu.

• `usage_events` giống như **hệ thống camera** ghi lại từng trò chơi khách đã tham gia.

• `subscription_invoices` là **tờ biên lai** thanh toán tại quầy, đảm bảo mọi thứ đều minh bạch và không thể chối cãi.



cải tiến tiếp phần Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)

Để nâng cấp **Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)** từ một hệ thống tính tiền cơ bản lên mức độ **World-class SaaS** (như Salesforce hay Stripe), chúng ta cần tập trung vào việc tối ưu hóa dòng tiền, khả năng mở rộng linh hoạt cho khách hàng Enterprise và tính minh bạch tuyệt đối trong đối soát12.

Dưới đây là các cải tiến chiến lược dựa trên kiến trúc hệ thống và các nguồn tài liệu đã thảo luận:

1\. Cải tiến Dòng tiền: Hệ thống Ví (FinOps & Prepaid Wallet)

Thay vì chỉ dựa vào mô hình trả sau (Postpaid) dễ gặp rủi ro nợ xấu, hệ thống cần bổ sung mô hình **Prepaid Wallet**. Khách hàng nạp tiền trước và hệ thống trừ dần theo thời gian hoặc lượng tiêu dùng34.

• **Bảng** **tenant\_wallets****:** Quản lý số dư khả dụng và tiền tệ (ISO 4217)5.

• **Bảng** **wallet\_transactions** **(Sổ cái kế toán kép):** Đây là nhật ký **bất biến (Immutable)**, chỉ cho phép `INSERT`, tuyệt đối không `UPDATE` hay `DELETE`56. Mọi biến động nạp tiền (`DEPOSIT`), trừ phí (`USAGE_DEDUCT`) hay hoàn tiền (`REFUND`) đều phải được ghi lại kèm theo số dư sau giao dịch (`balance_after`) để đối soát6.

2\. Cải tiến mô hình tính tiền: Hybrid Billing (Fixed + Metering)

Hệ thống hiện đại không chỉ thu phí cố định (Fixed Fee) mà còn thu phí theo lượng sử dụng thực tế (Usage-based Pricing)2....

• **Cơ chế Metering:** Dữ liệu thô từ **ClickHouse** (`usage_events`) sẽ được một Worker tổng hợp định kỳ và "bơm" về bảng **tenant\_usages** trong **YugabyteDB**910.

• **Tách biệt trách nhiệm:** Việc tách biệt này giúp hệ thống xuất hóa đơn không bao giờ phải truy vấn trực tiếp vào kho dữ liệu log khổng lồ, đảm bảo hiệu năng và độ chính xác tài chính1112.

3\. Cải tiến Quản lý "Ghế" sử dụng (License/Seat Management)

Đối với các gói Enterprise, việc kiểm soát số lượng người dùng (Seats) là cực kỳ quan trọng để tránh thất thoát doanh thu1314.

• **Bảng** **license\_allocations****:** Theo dõi số lượng ghế đã mua (`purchased_quantity`) so với số lượng đã gán thực tế (`assigned_quantity`)1415.

• **Phân loại License:** Core cần phân biệt giữa người dùng tính phí (`BILLABLE`) và khách dự thính/miễn phí (`GUEST/READ_ONLY`) để tự động chặn khi Admin mời quá số lượng gói cho phép15.

4\. Chiến lược Snapshot & Ghi đè quyền hạn (Entitlement Overrides)

Một quy tắc vàng trong SaaS là: **Khi khách hàng mua gói, phải Snapshot toàn bộ quyền lợi vào thuê bao**1617.

• **granted\_entitlements** **(JSONB):** Lưu bản sao cấu hình tính năng (`features`) và hạn mức (`limits`) từ gói gốc tại thời điểm mua1718. Điều này bảo vệ quyền lợi khách hàng nếu bạn thay đổi giá hoặc tính năng của gói gốc sau này16.

• **Khả năng Override:** Thiết kế này cho phép bạn bán thêm các gói bổ sung (**Add-on**). Ví dụ: Một Tenant mua gói "Standard" (100GB dung lượng) nhưng mua thêm 50GB lẻ, hệ thống chỉ cần cập nhật giá trị trong JSONB của bản ghi thuê bao đó lên 150GB mà không ảnh hưởng đến cấu trúc gói chung1719.

5\. Quy chuẩn dữ liệu an toàn cho Thuê bao

Để đảm bảo tính toàn vẹn và khả năng phân tán toàn cầu của YugabyteDB, các bảng trong nhóm này phải tuân thủ nghiêm ngặt các tiêu chuẩn2021:

• **Định danh:** Sử dụng **UUID v7** cho `_id` để tối ưu hóa việc sắp xếp theo thời gian và dàn trải dữ liệu trên các node (sharding)2022.

• **Tiền tệ:** Tuyệt đối không dùng kiểu Float/Double. Sử dụng **NUMERIC(19, 4)** để đảm bảo chính xác tuyệt đối 4 số lẻ sau dấu phẩy, tránh sai số làm tròn trong tài chính2023.

• **Thời gian:** Luôn lưu trữ theo chuẩn **UTC (TIMESTAMPTZ)** để hỗ trợ khách hàng đa quốc gia2324.

• **Minh bạch hóa đơn:** Sử dụng bảng **price\_adjustments** để lưu riêng giá gốc và các khoản chiết khấu/giảm giá tùy chỉnh, giúp hóa đơn luôn minh bạch16.

Tóm tắt các bảng trong Nhóm Quản lý Thuê bao cải tiến

| Tên bảng | Loại dữ liệu | Vai trò chiến lược |
| --- | --- | --- |
| **saas\_products** | SQL | Định nghĩa dòng sản phẩm thương mại2526. |
| **service\_packages** | SQL + JSONB | Danh mục các gói Combo (Menu bán hàng)2527. |
| **tenant\_subscriptions** | SQL + JSONB | Snapshot quyền lợi thực tế của từng khách hàng1828. |
| **tenant\_wallets** | SQL | Quản lý tiền nạp trước và dòng tiền FinOps4. |
| **wallet\_transactions** | SQL | Sổ cái bất biến ghi lại mọi biến động tài chính5. |
| **tenant\_usages** | SQL + JSONB | Lưu dữ liệu tiêu dùng đã tổng hợp từ ClickHouse để tính tiền912. |
| **license\_allocations** | SQL | Kiểm soát số lượng ghế/giấy phép sử dụng15. |

**Sự ví von:** Hệ thống thuê bao cải tiến giống như một **thẻ thành viên đa năng** tại một câu lạc bộ cao cấp. Thẻ này không chỉ ghi nhận gói hội viên bạn đã mua (Fixed Subscription), mà còn tích hợp một ví điện tử để bạn trả tiền cho mỗi ly cafe uống thêm (Wallet & Metering), đồng thời giới hạn số người bạn có thể dẫn theo (License Management). Mọi giao dịch đều được in biên lai rõ ràng và không bao giờ bị thay đổi dù câu lạc bộ có tăng giá thẻ cho người mới (Snapshot Strategy).



cải tiến tiếp phần Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)

Để nâng cấp **Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)** lên tiêu chuẩn của các hệ thống SaaS quy mô lớn (World-class), chúng ta cần tích hợp các cơ chế quản lý tài chính chuyên sâu, đo lường mức độ sử dụng và đảm bảo tính minh bạch tuyệt đối12.

Dưới đây là thiết kế cải tiến chi tiết cho nhóm này, tập trung vào mô hình **Hybrid Billing** (kết hợp phí cố định và phí theo lượng sử dụng), quản lý ví điện tử và tối ưu hóa hạ tầng phân tán34.

1\. Hệ thống Ví và Dòng tiền (FinOps)

Thay vì chỉ thu phí cố định hàng tháng, hệ thống cần hỗ trợ mô hình nạp tiền trước (Prepaid) và trừ dần để tối ưu hóa dòng tiền (Cashflow)45.

• **tenant\_wallets** **(Ví tiền Tenant):** Quản lý số dư khả dụng của từng khách hàng56. Dữ liệu này phải được lưu trữ tại YugabyteDB để đảm bảo tính nhất quán ACID tuyệt đối78.

• **wallet\_transactions** **(Sổ cái giao dịch):** Đây là bảng **bất biến (Immutable)**, chỉ cho phép chèn mới (`INSERT`) để ghi lại mọi biến động như nạp tiền (`DEPOSIT`), trừ phí sử dụng (`USAGE_DEDUCT`) hoặc hoàn tiền (`REFUND`)69. Bảng này lưu trữ số dư sau giao dịch (`balance_after`) để phục vụ đối soát9.

2\. Mô hình Metering (Đo lường & Tính tiền theo nhu cầu)

Để hỗ trợ việc tính phí theo lượng sử dụng thực tế (như số email gửi đi, dung lượng lưu trữ), hệ thống cần sự phối hợp giữa ClickHouse và YugabyteDB310.

• **Ghi nhận sự kiện (ClickHouse):** Bảng `usage_events` lưu trữ hàng tỷ bản ghi thô về hành vi tiêu dùng của người dùng311.

• **Tổng hợp tiêu dùng (****tenant\_usages** **- YugabyteDB):** Một tiến trình chạy nền (Worker) sẽ tổng hợp dữ liệu từ ClickHouse theo chu kỳ (giờ/ngày) và "bơm" vào bảng này1213. Việc tách biệt giúp hệ thống xuất hóa đơn không bị chậm do truy vấn lượng dữ liệu quá lớn từ log13.

3\. Quản lý "Ghế" sử dụng (License/Seat Management)

Đối với các gói Enterprise, việc kiểm soát số lượng người dùng thực tế so với số lượng đã mua là cực kỳ quan trọng14.

• **license\_allocations****:** Theo dõi số lượng "ghế" đã mua (`purchased_quantity`) và số lượng đã gán thực tế (`assigned_quantity`)1516.

• **Phân loại License:** Hệ thống phân biệt giữa người dùng tính phí (`BILLABLE`) và người dùng miễn phí (`GUEST/READ_ONLY`) để tự động chặn khi vượt quá hạn mức gói15.

4\. Thiết kế chi tiết các bảng cải tiến (YugabyteDB)

Tất cả các bảng trong nhóm này đều sử dụng **UUID v7** làm khóa chính để tối ưu hóa việc sắp xếp theo thời gian và sharding17.... Kiểu dữ liệu tiền tệ bắt buộc là **NUMERIC(19, 4)** để đảm bảo độ chính xác tài chính1720.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (UUID v7) | Định danh duy nhất cho thực thể thuê bao/ví1721. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu đến bảng `tenants`22. |
| **granted\_entitlements** | **JSONB** | NO  | `'{}'` |     | **Snapshot:** Sao chép toàn bộ quyền hạn từ gói gốc tại thời điểm mua2324. |
| **balance** | NUMERIC(19,4) | NO  | `0` | `CHECK (balance >= 0)` | Số dư trong ví tiền của Tenant620. |
| **price\_adjustments** | JSONB | YES |     |     | Lưu vết giảm giá hoặc chiết khấu để minh bạch hóa đơn2325. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` |     | Trạng thái: `ACTIVE`, `EXPIRED`, `SUSPENDED`2627. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** cho các cập nhật tài chính1928. |

5\. Độ tin cậy và Tính minh bạch

• **Snapshot Quyền hạn:** Khi khách hàng đăng ký, hệ thống bắt buộc phải **Copy (Snapshot)** toàn bộ giá và cấu hình quyền hạn vào bảng `tenant_subscriptions`2329. Điều này đảm bảo nếu gói cước gốc thay đổi giá hoặc tính năng sau đó, quyền lợi của khách hàng hiện tại không bị ảnh hưởng2324.

• **Transactional Outbox:** Khi một thuê bao được tạo hoặc gia hạn, một sự kiện sẽ được ghi vào bảng `outbox_events` trong cùng một giao dịch (Transaction)3031. Điều này đảm bảo các hệ thống khác (như Email, Provisioning) luôn nhận được thông tin chính xác, không bị mất dữ liệu do lỗi mạng3132.

• **Minh bạch hóa đơn:** Bảng `subscription_invoices` lưu trữ lịch sử thanh toán kèm theo các `price_adjustments` để khách hàng biết rõ số tiền gốc và số tiền đã giảm2333.

6\. Khả năng mở rộng hạ tầng (Data Residency)

Đối với khách hàng toàn cầu, nhóm quản lý thuê bao hỗ trợ cột **data\_region**3435. Dựa vào cột này, YugabyteDB có thể thực hiện **Geo-Partitioning**, giúp dữ liệu thuê bao của khách hàng tại Châu Âu được lưu trữ vật lý tại server Châu Âu để tuân thủ pháp lý (GDPR) và giảm độ trễ3637.

**Tóm lại:** Nhóm Quản lý Thuê bao cải tiến không chỉ dừng lại ở việc lưu trữ thông tin mua hàng, mà đã trở thành một **hệ thống tài chính (Ledger)** và **đo lường tiêu dùng (Metering)** tích hợp, đảm bảo hệ thống SaaS có thể mở rộng từ khách hàng cá nhân đến các tập đoàn đa quốc gia438.



cải tiến tiếp phần Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)

Để nâng cấp **Nhóm Quản lý Thuê bao (Subscriptions - Fixed Billing)** lên tầm cỡ "World-class SaaS" (như Salesforce hay Stripe), hệ thống cần tích hợp các cơ chế quản lý tài chính chuyên sâu, mô hình nạp tiền trước (Prepaid), và đo lường tiêu dùng (Metering)1....

Dưới đây là thiết kế chi tiết cải tiến nhóm này bằng **YSQL (YugabyteDB)**, đảm bảo tính nhất quán ACID tuyệt đối cho dữ liệu giao dịch4....

I. Thiết kế chi tiết các bảng nâng cao

1\. Bảng `service_packages` (Danh mục gói cước - Master Data)

Định nghĩa các gói Combo bán hàng, chứa các ứng dụng và hạn mức mặc định7....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (v7) | Định danh duy nhất, hỗ trợ sắp xếp theo thời gian10.... |
| **saas\_product\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu tới dòng sản phẩm `saas_products`7. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE` | Mã gói cước (Ví dụ: `enterprise-combo`)7. |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (>= 0)` | Giá niêm yết cố định (chính xác tuyệt đối)1314. |
| **currency** | VARCHAR(3) | NO  | `'VND'` | `LENGTH = 3` | Mã tiền tệ ISO 42171314. |
| **included\_apps\_config** | JSONB | NO  | `'[]'` |     | Danh sách App và cấu hình Feature/Limit mặc định815. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` |     | Trạng thái: `ACTIVE`, `ARCHIVED`15. |
| **version** | BIGINT | NO  | `1` |     | **Optimistic Locking** cho cập nhật gói1617. |

2\. Bảng `tenant_subscriptions` (Thuê bao hiện hành - Transaction Data)

Lưu trữ quyền lợi thực tế của khách hàng thông qua chiến lược **Snapshot**18....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (v7) | Định danh thuê bao19. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu tới `tenants`21. |
| **package\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu tới gói gốc để đối soát1920. |
| **granted\_entitlements** | **JSONB** | NO  | `'{}'` |     | **Snapshot:** Sao chép quyền lợi từ gói tại lúc mua18.... |
| **granted\_app\_codes** | TEXT\[\] | YES |     | `GENERATED` | Cache danh sách mã App để kiểm tra quyền nhanh2123. |
| **start\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm bắt đầu thuê bao (UTC)23. |
| **end\_at** | TIMESTAMPTZ | YES |     |     | Thời điểm hết hạn gói23. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` |     | `ACTIVE`, `EXPIRED`, `CANCELLED`21. |

3\. Bảng `tenant_wallets` (Ví tiền Tenant - FinOps)

Quản lý dòng tiền nạp trước (Prepaid) để trừ dần phí sử dụng2425.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (v7) | Định danh ví. |
| **tenant\_id** | UUID | NO  |     | `UNIQUE`, `FOREIGN KEY` | Mỗi Tenant chỉ có 1 ví chính25. |
| **balance** | NUMERIC(19,4) | NO  | `0` | `CHECK (>= 0)` | Số dư khả dụng25. |
| **currency** | VARCHAR(3) | NO  | `'VND'` |     | Đơn vị tiền tệ của ví25. |
| **is\_frozen** | BOOLEAN | NO  | `FALSE` |     | Đóng băng ví nếu có gian lận25. |

4\. Bảng `wallet_transactions` (Sổ cái giao dịch - Immutable Ledger)

Ghi lại mọi biến động ví, tuyệt đối không được sửa/xóa bản ghi2526.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (v7) | Định danh giao dịch. |
| **wallet\_id** | UUID | NO  |     | `FOREIGN KEY` | Tham chiếu ví thực hiện giao dịch26. |
| **type** | VARCHAR(30) | NO  |     |     | `DEPOSIT`, `USAGE_DEDUCT`, `REFUND`26. |
| **amount** | NUMERIC(19,4) | NO  |     |     | Số tiền biến động (+/-)26. |
| **balance\_after** | NUMERIC(19,4) | NO  |     |     | Số dư sau giao dịch để đối soát26. |
| **reference\_id** | UUID | YES |     |     | Link tới `subscription_invoices`26. |

5\. Bảng `tenant_usages` (Tổng hợp tiêu dùng - Metering)

Lưu dữ liệu tiêu dùng tổng hợp từ ClickHouse để làm căn cứ tính tiền trả sau27....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` (v7) | Định danh bản ghi tiêu dùng30. |
| **subscription\_id** | UUID | NO  |     | `FOREIGN KEY` | Tính tiền dựa trên thuê bao nào3031. |
| **usage\_period\_start** | TIMESTAMPTZ | NO  |     |     | Bắt đầu chu kỳ tính (Giờ/Ngày)30. |
| **metrics\_data** | **JSONB** | NO  | `'{}'` |     | Chứa chỉ số dùng thực tế (VD: 150 email)30. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` |     | `PENDING_BILLING`, `BILLED`30. |

\--------------------------------------------------------------------------------

II. Câu lệnh YSQL tạo bảng và Index

```
-- 1. BẢNG GÓI DỊCH VỤ (MASTER DATA)
CREATE TABLE service_packages (
    _id UUID PRIMARY KEY,
    saas_product_id UUID NOT NULL,
    code VARCHAR(50) NOT NULL,
    name TEXT NOT NULL,
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency VARCHAR(3) NOT NULL DEFAULT 'VND',
    included_apps_config JSONB NOT NULL DEFAULT '[]',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,
    CONSTRAINT uq_service_packages_code UNIQUE (code),
    CONSTRAINT chk_pkg_price CHECK (price_amount >= 0)
);

-- 2. BẢNG THUÊ BAO KHÁCH HÀNG (SNAPSHOT STRATEGY)
CREATE TABLE tenant_subscriptions (
    _id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    package_id UUID NOT NULL,
    granted_entitlements JSONB NOT NULL DEFAULT '{}',
    -- Cột cache tự động để kiểm tra quyền nhanh
    granted_app_codes TEXT[] GENERATED ALWAYS AS (
        ARRAY(SELECT jsonb_object_keys(granted_entitlements))
    ) STORED,
    start_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_at TIMESTAMPTZ,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    version BIGINT NOT NULL DEFAULT 1,
    CONSTRAINT chk_subs_dates CHECK (end_at IS NULL OR end_at > start_at)
);

-- 3. BẢNG VÍ TIỀN (FINOPS)
CREATE TABLE tenant_wallets (
    _id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    balance NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency VARCHAR(3) NOT NULL DEFAULT 'VND',
    is_frozen BOOLEAN NOT NULL DEFAULT FALSE,
    version BIGINT NOT NULL DEFAULT 1,
    CONSTRAINT uq_tenant_wallet UNIQUE (tenant_id),
    CONSTRAINT chk_wallet_balance CHECK (balance >= 0)
);

-- 4. BẢNG GIAO DỊCH VÍ (IMMUTABLE LEDGER)
CREATE TABLE wallet_transactions (
    _id UUID PRIMARY KEY,
    wallet_id UUID NOT NULL REFERENCES tenant_wallets(_id),
    tenant_id UUID NOT NULL,
    type VARCHAR(30) NOT NULL, -- DEPOSIT, USAGE_DEDUCT, REFUND
    amount NUMERIC(19, 4) NOT NULL,
    balance_after NUMERIC(19, 4) NOT NULL,
    reference_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 5. BẢNG TIÊU DÙNG (METERING)
CREATE TABLE tenant_usages (
    _id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    subscription_id UUID NOT NULL REFERENCES tenant_subscriptions(_id),
    usage_period_start TIMESTAMPTZ NOT NULL,
    usage_period_end TIMESTAMPTZ NOT NULL,
    metrics_data JSONB NOT NULL DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING_BILLING'
);

-- CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index kiểm tra quyền truy cập App cực nhanh (Sử dụng GIN Index cho mảng cache)
CREATE INDEX idx_subs_granted_apps ON tenant_subscriptions USING GIN (granted_app_codes);

-- Index tra cứu ví và lịch sử giao dịch (Sắp xếp thời gian giảm dần)
CREATE INDEX idx_wallet_tx_history ON wallet_transactions (wallet_id, created_at DESC);

-- Index hỗ trợ Worker tính tiền Metering theo chu kỳ
CREATE INDEX idx_usage_billing_scan ON tenant_usages (status, usage_period_end) 
WHERE status = 'PENDING_BILLING';
```

III. Các cải tiến chiến lược quan trọng:

1\. **Snapshot Entitlements:** Khi khách hàng mua gói, toàn bộ cấu hình (Limit, Feature) được copy thẳng vào `tenant_subscriptions`1820. Điều này giúp hệ thống không bao giờ bị sai lệch quyền lợi khi Admin thay đổi gói gốc trong tương lai18.

2\. **Hybrid Billing:** Kết hợp giữa trả trước (Wallets) và trả sau theo thực tế (Usages)324. Dữ liệu tiêu dùng được tổng hợp từ ClickHouse bơm về `tenant_usages` để đảm bảo hệ thống giao dịch luôn nhẹ và nhanh2830.

3\. **Optimistic Locking:** Cột `version` đảm bảo rằng nếu hai tiến trình (ví dụ: trừ tiền ví và hoàn tiền) xảy ra đồng thời, dữ liệu sẽ không bị ghi đè sai lệch1617.

4\. **UUID v7 & Sharding:** Việc dùng UUID v7 giúp các bản ghi thuê bao và giao dịch mới luôn nằm gần nhau trong các node dữ liệu của YugabyteDB, tối ưu hóa hiệu năng ghi1232.

**Sự ví von:** Thiết kế này giống như một **thẻ hội viên trả trước tích hợp đồng hồ đo**. Bạn mua gói cơ bản (Subscription), nạp tiền vào thẻ (Wallet), và mỗi khi bạn dùng dịch vụ bổ sung (Metering), hệ thống sẽ tự động đo lường và trừ tiền vào ví của bạn một cách minh bạch và không thể chối cãi (Ledger)33.



thiết kế chi tiết bảng service\_packages dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên kiến trúc hệ thống SaaS đa khách hàng (Multi-tenant) và các tiêu chuẩn về dữ liệu đã thảo luận, dưới đây là thiết kế chi tiết bảng **service\_packages** (Gói dịch vụ).

Thiết kế này đáp ứng mô hình **"Giải pháp tổng thể"** (Solution Bundle), cho phép một gói cước bao gồm nhiều ứng dụng (như LMS và HRM) với các tính năng và hạn mức riêng biệt thông qua cấu trúc JSONB1....

1\. Thiết kế chi tiết bảng `service_packages` (YSQL)

Bảng này được lưu trữ tại **YugabyteDB** để đảm bảo tính nhất quán giao dịch (ACID) và khả năng mở rộng quy mô lớn45.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian67. |
| **saas\_product\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `saas_products(_id)` | Liên kết gói này vào một dòng Giải pháp (VD: Giải pháp trường học)89. |
| **code** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (code ~ '^[a-z0-9-]+$')` | Mã gói cước (Slug). Chỉ chứa chữ thường, số và gạch ngang1011. |
| **name** | TEXT | NO  |     | `CHECK (length(name) > 0)` | Tên hiển thị của gói (VD: Gói trường học Cao cấp)1213. |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (price_amount >= 0)` | Giá của gói. Đảm bảo chính xác tuyệt đối, không sai số làm tròn6.... |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ ISO 4217 (VND, USD...)6.... |
| **entitlements\_config** | **JSONB** | NO  | `'{}'` |     | **Trái tim của giải pháp:** Chứa cấu hình lồng nhau của nhiều App, Features và Limits (VD: LMS và HRM)15.... |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED'))` | Trạng thái kinh doanh của gói cước1819. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Sử dụng cho **Optimistic Locking** khi cập nhật cấu hình2021. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (chuẩn UTC)1822. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng23. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE service_packages (
    -- I. Định danh & Liên kết giải pháp
    _id UUID PRIMARY KEY, -- Sử dụng UUID v7 sinh từ Application
    saas_product_id UUID NOT NULL,
    
    -- II. Thông tin thương mại
    code VARCHAR(50) NOT NULL,
    name TEXT NOT NULL,
    
    -- III. Tài chính (Đảm bảo chính xác tuyệt đối)
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- IV. Cấu hình quyền hạn đa ứng dụng (Entitlements)
    -- Ví dụ cấu trúc JSONB:
    -- {
    --   "LMS_APP": {"features": {"video_streaming": true}, "limits": {"max_courses": 100}},
    --   "HRM_APP": {"features": {"payroll": true}, "limits": {"max_employees": 50}}
    -- }
    entitlements_config JSONB NOT NULL DEFAULT '{}',
    
    -- V. Trạng thái & Quản trị
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ, -- Hỗ trợ Soft Delete

    -- VI. Các ràng buộc (Constraints)
    CONSTRAINT fk_pkg_saas_product FOREIGN KEY (saas_product_id) REFERENCES saas_products(_id),
    CONSTRAINT uq_service_packages_code UNIQUE (code),
    CONSTRAINT chk_pkg_code_fmt CHECK (code ~ '^[a-z0-9-]+$'),
    CONSTRAINT chk_pkg_price CHECK (price_amount >= 0),
    CONSTRAINT chk_pkg_currency CHECK (LENGTH(currency_code) = 3),
    CONSTRAINT chk_pkg_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'ARCHIVED')),
    CONSTRAINT chk_pkg_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm gói cước theo dòng sản phẩm (Giải pháp)
CREATE INDEX idx_service_packages_saas_product ON service_packages (saas_product_id) 
WHERE deleted_at IS NULL;

-- Index GIN để tìm kiếm cực nhanh các gói có chứa một ứng dụng cụ thể trong cấu hình JSONB
-- Ví dụ: Tìm tất cả giải pháp có chứa 'LMS_APP'
CREATE INDEX idx_service_packages_entitlements ON service_packages USING GIN (entitlements_config);

-- Index hỗ trợ tra cứu nhanh gói theo mã khi khách hàng đăng ký hoặc xem chi tiết
CREATE UNIQUE INDEX idx_service_packages_lookup ON service_packages (code) 
WHERE status = 'ACTIVE' AND deleted_at IS NULL;
```

3\. Giải thích tính đáp ứng của thiết kế

• **Mô hình đa phần mềm:** Trường `entitlements_config` kiểu JSONB cho phép bạn nhồi không giới hạn số lượng mã ứng dụng (`app_code`) vào cùng một gói cước. Mỗi ứng dụng sẽ có một "không gian" riêng để định nghĩa các tính năng (`features`) và hạn mức (`limits`)1516.

• **Snapshot Readiness:** Thiết kế này tuân thủ nguyên tắc **Snapshot**: Khi khách hàng mua giải pháp, toàn bộ nội dung trong `entitlements_config` sẽ được sao chép nguyên trạng vào bảng `tenant_subscriptions`2425. Điều này đảm bảo quyền lợi của khách hàng không bị thay đổi nếu bạn cập nhật gói gốc trong tương lai24.

• **Hiệu năng:** Việc sử dụng **GIN Index** trên JSONB giúp hệ thống kiểm tra quyền truy cập ứng dụng cực nhanh mà không cần thực hiện các phép `JOIN` phức tạp giữa nhiều bảng, phù hợp với yêu cầu của một hệ thống SaaS triệu người dùng17....

**Sự ví von:** Bảng `service_packages` này giống như một **Thực đơn Combo** trong nhà hàng. Thay vì bán lẻ từng món (từng App), bạn tạo ra một Combo (Giải pháp trường học) gồm: 1 món chính (LMS), 1 món kèm (HRM) và quy định rõ lượng thức ăn của từng món (Limits). Khách hàng chỉ cần gọi tên Combo (`code`) là hệ thống tự động biết họ được hưởng những gì1.



chi tiết thuộc tính của entitlements\_config

Dựa trên các nguồn tài liệu về thiết kế hệ thống SaaS đa khách hàng, thuộc tính **entitlements\_config** (cấu hình quyền hạn) là thành phần cốt lõi nằm trong bảng `service_packages` (gói dịch vụ) và sau đó được snapshot vào bảng `tenant_subscriptions` (thuê bao khách hàng)1,2.

Dưới đây là chi tiết các thuộc tính và cấu trúc của **entitlements\_config**:

1\. Định dạng và Cấu trúc tổng quát

• **Kiểu dữ liệu:** Được lưu trữ dưới dạng **JSONB** để đảm bảo tính linh hoạt, cho phép lưu trữ các cấu trúc lồng nhau phức tạp mà không cần thay đổi sơ đồ (schema) database23.

• **Nguyên tắc phân cấp:** Cấu trúc được tổ chức theo mã ứng dụng (**App Code**). Một gói dịch vụ (Package) có thể bao gồm nhiều ứng dụng khác nhau (Bundle/Combo), và mỗi ứng dụng sẽ có bộ quyền hạn riêng24.

2\. Các thành phần bên trong một App Code

Bên trong mỗi mã ứng dụng (ví dụ: `HRM_RECRUIT`, `CRM_APP`), `entitlements_config` thường chia làm hai nhóm thuộc tính chính1,2:

• **features** **(Tính năng - "Được làm gì?"):**

    ◦ Sử dụng kiểu dữ liệu **Boolean** (`true`/`false`)1.    ◦ Quy định việc bật/tắt các chức năng cụ thể trong phần mềm2.    ◦ _Ví dụ:_ `allow_sso: true`, `allow_export_excel: false`, `ai_screening: true`1....

• **limits** **(Hạn mức - "Được bao nhiêu?"):**

    ◦ Sử dụng kiểu dữ liệu **Number** (Số)1.    ◦ Quy định hạn ngạch hoặc số lượng tối đa mà khách hàng được phép sử dụng2.    ◦ _Ví dụ:_ `max_users: 10`, `storage_gb: 100`, `job_posts: -1` (với -1 thường được hiểu là không giới hạn)1....

3\. Ví dụ cấu trúc dữ liệu thực tế

Một bản ghi `entitlements_config` điển hình cho một gói "Combo Enterprise" có thể trông như sau5:

```
{
  "HRM_RECRUIT": {
    "features": {
      "ai_screening": true,
      "custom_email": true
    },
    "limits": {
      "job_posts": 100,
      "cv_storage": 50
    }
  },
  "HRM_TIMEKEEPING": {
    "features": {
      "face_id": true
    },
    "limits": {
      "max_locations": 5
    }
  }
}
```

4\. Vai trò và Khả năng mở rộng

• **Snapshot và Ghi đè (Override):** Khi khách hàng mua gói, toàn bộ JSON này được sao chép sang bảng `tenant_subscriptions`6,7. Nếu khách hàng mua thêm gói bổ sung (Add-on), hệ thống có thể ghi đè trực tiếp vào giá trị trong JSON của thuê bao đó (ví dụ nâng `cv_storage` từ 50 lên 150) mà không ảnh hưởng đến gói cước gốc của hệ thống89.

• **Trạng thái ứng dụng:** Trong cấu hình nâng cao, JSON này có thể bổ sung thêm trường `status` cho từng App (ví dụ: `active`, `suspended`) để cho phép khóa tạm thời một ứng dụng trong gói mà không cần khóa toàn bộ các ứng dụng khác10....

• **Kiểm tra quyền nhanh:** Hệ thống có thể sử dụng các cột tính toán (Generated Columns) dựa trên các Key của JSONB này (ví dụ: `granted_app_codes`) kết hợp với **GIN Index** để kiểm tra cực nhanh xem một khách hàng có quyền truy cập vào một App cụ thể nào đó hay không5....

**Tóm lại:** `entitlements_config` giống như một **thực đơn chi tiết của một gói Combo**, trong đó ghi rõ bạn được ăn những món nào (Features) và định lượng của mỗi món là bao nhiêu (Limits)14. Cấu trúc JSONB cho phép thực đơn này thay đổi linh hoạt tùy theo từng dòng sản phẩm hoặc nhu cầu đặc thù của khách hàng VIP1516.



thiết kế chi tiết bảng tenant\_subscriptions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng (Multi-tenant) và kiến trúc **Polyglot Persistence**, bảng **tenant\_subscriptions** đóng vai trò là "bản hợp đồng điện tử", lưu trữ snapshot toàn bộ quyền lợi của khách hàng tại thời điểm mua để đảm bảo tính nhất quán tài chính và vận hành1,2.

Dưới đây là thiết kế chi tiết bảng này sử dụng **YSQL (YugabyteDB)**:

1\. Thiết kế chi tiết bảng `tenant_subscriptions`

Bảng này được đặt tại tầng **Distributed SQL** để đảm bảo tính đúng đắn tuyệt đối (ACID) cho các giao dịch thanh toán và quyền hạn3,4.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian và tối ưu Sharding5,6. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định thuê bao này thuộc về khách hàng nào7. |
| **package\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `service_packages(_id)` | Tham chiếu gói cước gốc để đối soát và báo cáo doanh thu2. |
| **price\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (price_amount >= 0)` | **Snapshot giá:** Lưu giá thực tế tại thời điểm mua để tránh biến động khi gói gốc đổi giá5,1. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (LENGTH = 3)` | Mã tiền tệ theo chuẩn ISO 42175,8. |
| **granted\_entitlements** | **JSONB** | NO  | `'{}'` |     | **Snapshot quyền lợi:** Chứa cấu hình chi tiết Features/Limits của từng App. Cho phép ghi đè (Override) khi mua thêm Add-on9,10. |
| **granted\_app\_codes** | **TEXT\[\]** | YES |     | `GENERATED ALWAYS AS (...) STORED` | **Cache mảng:** Trích xuất các Key từ JSONB để kiểm tra quyền truy cập App cực nhanh bằng GIN Index9,11. |
| **start\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm bắt đầu có hiệu lực (UTC)12,8. |
| **end\_at** | TIMESTAMPTZ | YES |     | `CHECK (end_at > start_at)` | Thời điểm hết hạn. NULL nếu là gói vĩnh viễn13,14. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (IN ('ACTIVE', 'EXPIRED', 'CANCELLED', 'PAST_DUE'))` | Trạng thái của thuê bao12,8. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** để ngăn chặn ghi đè dữ liệu đồng thời khi có nhiều giao dịch15. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (Audit)7. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng16. |
| **deleted\_at** | TIMESTAMPTZ | YES |     |     | Hỗ trợ **Soft Delete** để khôi phục dữ liệu khi cần16,17. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_subscriptions (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- UUID v7 sinh từ Application
    tenant_id UUID NOT NULL,
    package_id UUID NOT NULL,
    
    -- Tài chính (Snapshot)
    price_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- Quyền hạn & Cache (Snapshot & Computed)
    granted_entitlements JSONB NOT NULL DEFAULT '{}',
    -- Tự động trích xuất mã các App từ JSONB để index
    granted_app_codes TEXT[] GENERATED ALWAYS AS (
        ARRAY(SELECT jsonb_object_keys(granted_entitlements))
    ) STORED,
    
    -- Thời gian & Trạng thái
    start_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_at TIMESTAMPTZ,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,

    -- Ràng buộc (Constraints)
    CONSTRAINT fk_subs_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_subs_package FOREIGN KEY (package_id) REFERENCES service_packages(_id),
    CONSTRAINT chk_subs_price CHECK (price_amount >= 0),
    CONSTRAINT chk_subs_status CHECK (status IN ('ACTIVE', 'EXPIRED', 'CANCELLED', 'PAST_DUE')),
    CONSTRAINT chk_subs_dates CHECK (end_at IS NULL OR end_at > start_at)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index kiểm tra quyền truy cập App (Sử dụng GIN Index cho mảng cache)
-- Giúp query: WHERE 'HRM_APP' = ANY(granted_app_codes) chạy cực nhanh [11]
CREATE INDEX idx_subs_granted_apps 
ON tenant_subscriptions USING GIN (granted_app_codes);

-- Index tra cứu các thuê bao đang hoạt động của 1 Tenant
CREATE INDEX idx_subs_tenant_active 
ON tenant_subscriptions (tenant_id) 
WHERE status = 'ACTIVE' AND deleted_at IS NULL;

-- Index hỗ trợ Worker tính tiền Metering hoặc quét thuê bao hết hạn
CREATE INDEX idx_subs_expiry_scan 
ON tenant_subscriptions (status, end_at) 
WHERE end_at IS NOT NULL;
```

3\. Các đặc điểm cải tiến vượt trội:

• **Snapshot Strategy:** Khi khách hàng mua gói, hệ thống sao chép nguyên trạng `price_amount` và `granted_entitlements` từ bảng gốc vào đây. Điều này đảm bảo nếu gói cước gốc thay đổi chính sách trong tương lai, quyền lợi của khách hàng hiện tại không bị ảnh hưởng1,10.

• **Performance Optimization:** Cột `granted_app_codes` kết hợp với **GIN Index** giúp API Gateway kiểm tra quyền truy cập của một Tenant vào một phần mềm cụ thể (ví dụ: HRM hay CRM) với tốc độ micro-seconds mà không cần thực hiện phép JOIN phức tạp hay bóc tách JSON lúc chạy9,11.

• **Hybrid Billing Ready:** Thiết kế này sẵn sàng cho việc tính tiền theo lượng sử dụng (Metering). Dữ liệu tiêu dùng từ ClickHouse có thể được đối soát định kỳ với các hạn mức (Limits) lưu trong `granted_entitlements` để xuất hóa đơn chính xác18,19.



thiết kế chi tiết bảng subscription\_invoices dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên kiến trúc hệ thống SaaS đa khách hàng và các quy chuẩn về dữ liệu tài chính (ACID) đã thống nhất trong các nguồn tài liệu, bảng **subscription\_invoices** được thiết kế để lưu trữ lịch sử hóa đơn, đảm bảo tính chính xác tuyệt đối về tiền tệ và minh bạch trong đối soát12.

Dưới đây là thiết kế chi tiết sử dụng **YSQL (YugabyteDB)**:

1\. Thiết kế chi tiết bảng `subscription_invoices`

Bảng này tuân thủ các quy tắc về kiểu dữ liệu tiền tệ `NUMERIC(19, 4)` và sử dụng định danh **UUID v7** để tối ưu hóa hiệu năng ghi trong môi trường phân tán3....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh hóa đơn chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian34. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định hóa đơn thuộc về khách hàng nào. Cần thiết để sharding/filtering6. |
| **subscription\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenant_subscriptions(_id)` | Liên kết hóa đơn với gói thuê bao cụ thể của khách hàng2. |
| **invoice\_number** | VARCHAR(50) | NO  |     | `UNIQUE` | Mã hóa đơn nghiệp vụ (VD: INV-2024-0001) để đối soát với kế toán. |
| **amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (amount >= 0)` | Tổng số tiền cần thanh toán. Độ chính xác 4 số lẻ35. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ ISO 4217 (VND, USD,...)3. |
| **status** | VARCHAR(20) | NO  | `'OPEN'` | `CHECK (IN ('DRAFT', 'OPEN', 'PAID', 'VOID', 'UNCOLLECTIBLE'))` | Trạng thái hóa đơn: Nháp, Đang mở, Đã trả, Hủy, Nợ xấu7. |
| **billing\_period\_start** | TIMESTAMPTZ | NO  |     |     | Ngày bắt đầu chu kỳ tính tiền (UTC)57. |
| **billing\_period\_end** | TIMESTAMPTZ | NO  |     | `CHECK (end > start)` | Ngày kết thúc chu kỳ tính tiền (UTC)57. |
| **due\_date** | TIMESTAMPTZ | NO  |     |     | Hạn chót thanh toán. |
| **paid\_at** | TIMESTAMPTZ | YES |     |     | Thời điểm thực tế khách hàng thanh toán thành công7. |
| **price\_adjustments** | JSONB | NO  | `'[]'` |     | Lưu chi tiết giảm giá, chiết khấu để minh bạch hóa đơn89. |
| **metadata** | JSONB | NO  | `'{}'` |     | Lưu thông tin bổ sung tùy linh hoạt (VD: ghi chú, thông tin Gateway)5. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Dùng cho **Optimistic Locking** chống ghi đè dữ liệu10. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo hóa đơn11. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng11. |
| **deleted\_at** | TIMESTAMPTZ | YES |     |     | Hỗ trợ **Soft Delete** để xóa mềm11. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Việc đánh Index tập trung vào khả năng tra cứu nhanh theo Tenant và trạng thái hóa đơn để phục vụ Dashboard và nhắc nợ tự động1213.

```
-- Tạo bảng subscription_invoices
CREATE TABLE subscription_invoices (
    _id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    subscription_id UUID NOT NULL,
    invoice_number VARCHAR(50) NOT NULL,
    amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    status VARCHAR(20) NOT NULL DEFAULT 'OPEN',
    billing_period_start TIMESTAMPTZ NOT NULL,
    billing_period_end TIMESTAMPTZ NOT NULL,
    due_date TIMESTAMPTZ NOT NULL,
    paid_at TIMESTAMPTZ,
    price_adjustments JSONB NOT NULL DEFAULT '[]',
    metadata JSONB NOT NULL DEFAULT '{}',
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,

    -- Các ràng buộc dữ liệu
    CONSTRAINT uq_invoice_number UNIQUE (invoice_number),
    CONSTRAINT chk_invoice_amount CHECK (amount >= 0),
    CONSTRAINT chk_invoice_currency CHECK (LENGTH(currency_code) = 3),
    CONSTRAINT chk_invoice_status CHECK (status IN ('DRAFT', 'OPEN', 'PAID', 'VOID', 'UNCOLLECTIBLE')),
    CONSTRAINT chk_billing_dates CHECK (billing_period_end > billing_period_start),
    CONSTRAINT fk_invoice_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_invoice_subscription FOREIGN KEY (subscription_id) REFERENCES tenant_subscriptions(_id)
);

-- CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- 1. Index quan trọng nhất cho SaaS: Tra cứu hóa đơn của một Tenant
CREATE INDEX idx_invoices_tenant_lookup 
ON subscription_invoices (tenant_id, created_at DESC) 
WHERE deleted_at IS NULL;

-- 2. Index hỗ trợ nhắc nợ: Tìm các hóa đơn chưa thanh toán đã quá hạn
CREATE INDEX idx_invoices_overdue_tracker 
ON subscription_invoices (status, due_date) 
WHERE status = 'OPEN' AND deleted_at IS NULL;

-- 3. Index hỗ trợ tìm kiếm theo mã hóa đơn nghiệp vụ
CREATE UNIQUE INDEX idx_invoices_number_search 
ON subscription_invoices (invoice_number) 
WHERE deleted_at IS NULL;
```

3\. Phân tích bổ sung về tính năng

• **Chính xác tài chính:** Sử dụng `NUMERIC(19, 4)` ngăn chặn hoàn toàn sai số làm tròn của kiểu `FLOAT/DOUBLE`, điều tối kỵ trong Billing3.

• **Minh bạch hóa đơn:** Cột `price_adjustments` lưu trữ các thay đổi về giá so với gói gốc (như giảm giá 10% cho khách hàng thân thiết), giúp giải thích rõ ràng tại sao số tiền hóa đơn lại khác với giá gói niêm yết8.

• **Snapshot Logic:** Dữ liệu hóa đơn là **bất biến (Immutable)** sau khi đã thanh toán. Mọi thông tin về chu kỳ sử dụng được snapshot tại thời điểm tạo hóa đơn để đảm bảo dữ liệu lịch sử không bị thay đổi nếu gói cước gốc có điều chỉnh giá8.

**Sự ví von:** Hóa đơn này giống như một **tờ biên lai chi tiết** sau khi bạn đi siêu thị. Nó ghi rõ bạn mua gì, vào lúc nào, có được giảm giá không và hiện trạng đã trả tiền hay chưa. Việc lưu trữ nó trong "két sắt" YugabyteDB đảm bảo tờ biên lai này không bao giờ bị rách, bị sửa đổi trái phép và luôn sẵn sàng để đối soát bất cứ lúc nào1.



thiết kế chi tiết bảng subscription\_orders dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các tiêu chuẩn thiết kế hệ thống SaaS đa khách hàng (Multi-tenant) và quy tắc về dữ liệu tài chính (ACID) đã thống nhất trong các nguồn tài liệu, bảng **subscription\_orders** đóng vai trò ghi lại các giao dịch mua gói cước của khách hàng1.

Đây là thực thể trung gian quan trọng: Khi một "Order" được thanh toán thành công, hệ thống sẽ kích hoạt hoặc gia hạn "Subscription" và tạo ra "Invoice" tương ứng2.

1\. Thiết kế chi tiết bảng `subscription_orders`

Bảng này sử dụng **UUID v7** làm khóa chính để tối ưu hóa hiệu năng ghi phân tán và sắp xếp theo thời gian3. Kiểu dữ liệu tiền tệ bắt buộc là **NUMERIC(19, 4)** để đảm bảo độ chính xác tuyệt đối45.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh đơn hàng chuẩn **UUID v7**3. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định đơn hàng thuộc về khách hàng nào6. |
| **package\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `service_packages(_id)` | Gói cước mà khách hàng đang đặt mua7. |
| **order\_number** | VARCHAR(50) | NO  |     | `UNIQUE` | Mã đơn hàng nghiệp vụ (VD: ORD-2024-1029) để đối soát8. |
| **total\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (total_amount >= 0)` | Tổng số tiền đơn hàng. Chính xác 4 số lẻ45. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length = 3)` | Mã tiền tệ ISO 4217 (VND, USD...)4. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (IN ('PENDING', 'PAID', 'CANCELLED', 'FAILED'))` | Trạng thái đơn hàng9. |
| **payment\_method** | VARCHAR(30) | YES |     |     | Phương thức: `CREDIT_CARD`, `BANK_TRANSFER`, `WALLET`10. |
| **package\_snapshot** | **JSONB** | NO  | `'{}'` |     | **Snapshot:** Lưu cấu hình gói (giá, quyền hạn) tại thời điểm đặt hàng11. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Hỗ trợ **Optimistic Locking** chống ghi đè dữ liệu12. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo đơn hàng (UTC)69. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng13. |
| **deleted\_at** | TIMESTAMPTZ | YES |     |     | Hỗ trợ **Soft Delete**13. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Dưới đây là mã nguồn SQL để triển khai bảng trong môi trường **YugabyteDB**.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE subscription_orders (
    -- Định danh & Tenancy
    _id UUID PRIMARY KEY, -- UUID v7 sinh từ ứng dụng
    tenant_id UUID NOT NULL,
    package_id UUID NOT NULL,
    
    -- Thông tin đơn hàng
    order_number VARCHAR(50) NOT NULL,
    total_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    payment_method VARCHAR(30),
    
    -- Dữ liệu Snapshot (Quan trọng để bảo toàn giá/quyền lợi khi mua)
    package_snapshot JSONB NOT NULL DEFAULT '{}',
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,

    -- Các ràng buộc toàn vẹn
    CONSTRAINT fk_order_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_order_package FOREIGN KEY (package_id) REFERENCES service_packages(_id),
    CONSTRAINT uq_order_number UNIQUE (order_number),
    CONSTRAINT chk_order_amount CHECK (total_amount >= 0),
    CONSTRAINT chk_order_currency CHECK (LENGTH(currency_code) = 3),
    CONSTRAINT chk_order_status CHECK (status IN ('PENDING', 'PAID', 'CANCELLED', 'FAILED'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ Tenant xem lịch sử đơn hàng (Sắp xếp mới nhất lên đầu)
CREATE INDEX idx_orders_tenant_lookup 
ON subscription_orders (tenant_id, created_at DESC) 
WHERE deleted_at IS NULL;

-- Index hỗ trợ Admin/Worker quét các đơn hàng chưa thanh toán
CREATE INDEX idx_orders_pending_status 
ON subscription_orders (status, created_at) 
WHERE status = 'PENDING' AND deleted_at IS NULL;

-- Index tìm kiếm nhanh theo mã đơn hàng nghiệp vụ
CREATE UNIQUE INDEX idx_orders_number_search 
ON subscription_orders (order_number) 
WHERE deleted_at IS NULL;
```

3\. Các điểm cải tiến quan trọng đáp ứng phân tích

• **Chiến lược Snapshot:** Bảng này lưu trữ `package_snapshot` (JSONB). Điều này cực kỳ quan trọng vì nếu sau khi khách hàng đặt hàng mà quản trị viên thay đổi giá hoặc nội dung gói trong `service_packages`, đơn hàng này vẫn giữ nguyên giá trị đã thỏa thuận lúc khách bấm mua11.

• **Tính nhất quán tài chính:** Việc sử dụng `NUMERIC(19, 4)` cho `total_amount` đảm bảo không có sai số trong các phép tính tổng tiền, chiết khấu hoặc thuế, đáp ứng yêu cầu "Két sắt an toàn" của YugabyteDB514.

• **Sẵn sàng cho Sharding:** Sử dụng `_id` UUID v7 giúp dữ liệu đơn hàng mới được dàn đều trên các node dữ liệu của YugabyteDB nhưng vẫn giữ được thứ tự thời gian, tránh hiện tượng "Hotspot" khi có lượng lớn giao dịch cùng lúc15.

• **Audit & Recovery:** Các trường `version`, `updated_at` và `deleted_at` cho phép hệ thống truy vết mọi thay đổi và khôi phục đơn hàng nếu lỡ tay xóa nhầm (Soft Delete)1213.



thiết kế chi tiết bảng usage\_events dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên kiến trúc **Polyglot Persistence** và các quy chuẩn thiết kế hệ thống SaaS triệu người dùng đã thảo luận, bảng **usage\_events** đóng vai trò là kho lưu trữ dữ liệu thô khổng lồ phục vụ cho mô hình **Hybrid Billing (Fixed + Metering)**12. Dữ liệu tại đây được ghi theo dạng **Append-only** (chỉ ghi thêm, không sửa xóa) để đảm bảo tốc độ ghi cực cao và khả năng nén dữ liệu tối ưu của ClickHouse13.

Dưới đây là thiết kế chi tiết cho bảng **usage\_events**:

1\. Thiết kế chi tiết bảng `usage_events` (ClickHouse)

ClickHouse không sử dụng các ràng buộc (Constraints) như khóa ngoại (Foreign Key) để đảm bảo tốc độ, thay vào đó tập trung vào **Sorting Key** và **Partitioning** để tối ưu truy vấn45.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Logic Kiểm tra & Ràng buộc | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | Khóa chính logic (UUID v7)6. | Định danh duy nhất cho sự kiện, sinh từ ứng dụng6. |
| **tenant\_id** | UUID | NO  |     | Thành phần của **Sorting Key**4. | Xác định sự kiện thuộc về khách hàng nào7. |
| **subscription\_id** | UUID | NO  |     | Dùng để đối soát với YugabyteDB8. | Liên kết trực tiếp với gói thuê bao hiện hành của khách8. |
| **app\_code** | String | NO  |     | Thành phần của **Sorting Key**4. | Mã ứng dụng phát sinh tiêu dùng (VD: 'LMS', 'CRM')9. |
| **event\_type** | Enum8 / String | NO  |     | VD: 'EMAIL\_SENT', 'FILE\_UPLOAD'10. | Loại hành động tiêu dùng để áp giá2. |
| **quantity** | Decimal128(4) | NO  | `0` | Chính xác 4 số lẻ11. | Số lượng tiêu dùng thực tế (VD: 1.5 GB, 100 tin nhắn)611. |
| **unit** | String | NO  |     | VD: 'GB', 'UNIT', 'REQ' | Đơn vị tính của lượng tiêu dùng. |
| **metadata** | String | NO  | `'{}'` | Lưu dưới dạng chuỗi JSON11. | Chứa thông tin bổ sung tùy biến (IP, UserID, Device)11. |
| **data\_region** | String | NO  | `'DEFAULT'` | Phục vụ luật Data Residency12. | Vùng dữ liệu vật lý phát sinh sự kiện1213. |
| **timestamp** | DateTime64(3) | NO  | `now()` | Độ chính xác mili-giây (UTC)11. | Thời điểm chính xác sự kiện xảy ra1114. |

\--------------------------------------------------------------------------------

2\. Câu lệnh tạo bảng và Index (ClickHouse DDL)

Trong ClickHouse, "Index" thực chất được định nghĩa qua cấu trúc của bảng `MergeTree`. Chúng ta sẽ sử dụng **Partitioning** theo tháng để dễ dàng quản lý vòng đời dữ liệu (Archiving)415.

```
-- Tạo bảng usage_events trên ClickHouse
CREATE TABLE usage_events (
    -- 1. Định danh & Liên kết
    _id UUID,
    tenant_id UUID,
    subscription_id UUID,
    
    -- 2. Thông tin nghiệp vụ
    app_code String,
    event_type String, -- Hoặc Enum8('EMAIL_SENT' = 1, 'FILE_UPLOAD' = 2) để tối ưu dung lượng [11]
    quantity Decimal128(4),
    unit String,
    
    -- 3. Thông tin kỹ thuật & Metadata
    metadata String, -- Lưu JSON String, dùng hàm JSONExtract để truy vấn [11]
    data_region String,
    timestamp DateTime64(3, 'UTC')
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để tối ưu việc xóa/nén dữ liệu cũ [4, 16]
PARTITION BY toYYYYMM(timestamp)
-- Sắp xếp dữ liệu (Sorting Key) để truy vấn báo cáo theo Tenant và App cực nhanh [4]
ORDER BY (tenant_id, app_code, event_type, timestamp)
-- Cấu hình nén dữ liệu (Mặc định ClickHouse nén rất tốt, tỷ lệ ~10:1) [3]
SETTINGS index_granularity = 8192;

-- Lưu ý: ClickHouse không dùng Index truyền thống như SQL. 
-- Sorting Key (ORDER BY) đóng vai trò là Primary Index giúp lọc dữ liệu trong mili-giây [3, 4].
```

3\. Giải thích tính đáp ứng phân tích

1\. **Tách biệt ghi và tính tiền:** Bảng này lưu dữ liệu thô với tốc độ cao. Một Worker sẽ định kỳ tổng hợp dữ liệu từ bảng này (ví dụ: `SUM(quantity)`) và cập nhật vào bảng `tenant_usages` trong YugabyteDB để xuất hóa đơn1617.

2\. **Tối ưu chi phí lưu trữ:** Nhờ cơ chế **Columnar Storage**, ClickHouse sẽ nén các cột có dữ liệu lặp lại nhiều như `tenant_id` hoặc `app_code`, giúp tiết kiệm tới 90% dung lượng ổ cứng so với lưu tại MongoDB hay Postgres3.

3\. **Khả năng mở rộng:** Việc dùng **UUID v7** giúp dữ liệu có tính thứ tự thời gian ngay từ đầu, hỗ trợ tốt cho việc đồng bộ qua Kafka/Debezium từ các tầng ứng dụng khác mà không gây xung đột định danh618.

4\. **Bảo mật & Tuân thủ:** Trường `data_region` và `metadata` cho phép hệ thống thực hiện các báo cáo tuân thủ (Audit) và định vị dữ liệu theo yêu cầu của các khách hàng Enterprise lớn1219.

**Sự ví von:** Nếu hệ thống SaaS của bạn là một mạng lưới điện lực, thì `usage_events` chính là **từng nhịp quay của đồng hồ điện** tại mỗi hộ gia đình (Tenant). Nó ghi nhận liên tục từng watt điện tiêu thụ. ClickHouse đóng vai trò là **trạm thu thập dữ liệu tập trung**, nơi nén hàng tỷ nhịp quay đó lại thành các con số tổng hợp để cuối tháng bạn chỉ việc in hóa đơn mà không làm quá tải hệ thống điện đang chạy316.



thiết kế chi tiết bảng tenant\_usages dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên kiến trúc **Polyglot Persistence** và mô hình **Hybrid Billing** đã thống nhất, bảng **tenant\_usages** đóng vai trò là kho lưu trữ dữ liệu tiêu dùng đã được tổng hợp (Aggregated Data) từ ClickHouse để phục vụ tính tiền chính xác (Metering) trong YugabyteDB1,2,3.

Dưới đây là thiết kế chi tiết bảng đáp ứng các yêu cầu về tính nhất quán tài chính và hiệu năng phân tán.

1\. Thiết kế chi tiết bảng `tenant_usages` (YugabyteDB)

Bảng này được thiết kế để lưu trữ các chỉ số sử dụng theo chu kỳ, giúp hệ thống Billing không phải truy vấn trực tiếp vào kho dữ liệu thô khổng lồ4,5.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian và sharding6,5. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định dữ liệu tiêu dùng thuộc về khách hàng nào7,5. |
| **subscription\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenant_subscriptions(_id)` | Liên kết với gói thuê bao cụ thể để áp giá Metering8,9. |
| **usage\_period\_start** | TIMESTAMPTZ | NO  |     |     | Bắt đầu chu kỳ tổng hợp dữ liệu (UTC)10,5. |
| **usage\_period\_end** | TIMESTAMPTZ | NO  |     | `CHECK (usage_period_end > usage_period_start)` | Kết thúc chu kỳ tổng hợp dữ liệu (UTC)5. |
| **metrics\_data** | **JSONB** | NO  | `'{}'` |     | Chứa các chỉ số tiêu dùng (VD: `{"emails_sent": 150, "storage_gb": 10}`)4,5. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK (status IN ('PENDING', 'BILLED', 'VOID'))` | Trạng thái tính tiền: Chờ xử lý, Đã xuất hóa đơn, Hủy bỏ4,9. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm hệ thống ghi nhận bản ghi tổng hợp11. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng11. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế sử dụng các Index tối ưu cho việc quét dữ liệu theo chu kỳ và đối soát nhanh cho từng khách hàng8,9.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_usages (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    subscription_id UUID NOT NULL,
    
    -- Dữ liệu tiêu dùng
    usage_period_start TIMESTAMPTZ NOT NULL,
    usage_period_end TIMESTAMPTZ NOT NULL,
    metrics_data JSONB NOT NULL DEFAULT '{}',
    
    -- Trạng thái & Audit
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Các ràng buộc
    CONSTRAINT fk_usage_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_usage_subscription FOREIGN KEY (subscription_id) REFERENCES tenant_subscriptions(_id),
    CONSTRAINT chk_usage_dates CHECK (usage_period_end > usage_period_start),
    CONSTRAINT chk_usage_status CHECK (status IN ('PENDING', 'BILLED', 'VOID'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ Job Billing quét nhanh các bản ghi chưa tính tiền theo kỳ
-- Giúp tăng tốc độ xuất hóa đơn hàng tháng
CREATE INDEX idx_usage_billing_scan 
ON tenant_usages (status, usage_period_end) 
WHERE status = 'PENDING';

-- Index hỗ trợ Tenant xem lịch sử tiêu dùng theo thời gian
CREATE INDEX idx_usage_tenant_history 
ON tenant_usages (tenant_id, usage_period_start DESC);

-- Index GIN để truy vấn sâu vào các chỉ số cụ thể trong JSONB nếu cần
-- Ví dụ: Tìm các tenant có lượng emails_sent vượt ngưỡng
CREATE INDEX idx_usage_metrics_data ON tenant_usages USING GIN (metrics_data);
```

3\. Giải thích tính đáp ứng nghiệp vụ

• **Tách biệt trách nhiệm:** ClickHouse xử lý hàng tỷ sự kiện thô (`usage_events`), trong khi bảng này chỉ lưu kết quả đã tính toán xong, giúp YugabyteDB duy trì được tính nhất quán ACID mà không bị quá tải bởi dữ liệu lớn12,4.

• **Chính xác tài chính:** Việc sử dụng `TIMESTAMPTZ` đảm bảo không có sai sót về múi giờ khi tính toán tiêu dùng cho khách hàng toàn cầu10,13.

• **Snapshot Metrics:** `metrics_data` dưới dạng JSONB cho phép hệ thống linh hoạt bổ sung các chỉ số mới (như AI Tokens, API Calls) mà không cần thay đổi cấu trúc bảng14,4.

• **Billing Readiness:** Trạng thái `PENDING` và `usage_period_end` giúp Worker biết chính xác cần gom những bản ghi nào để tạo hóa đơn (`subscription_invoices`) cho kỳ thanh toán tiếp theo4,5.



thiết kế chi tiết bảng tenant\_wallets dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng và nguyên tắc **"Két sắt an toàn"** (Critical Data) trong kiến trúc Polyglot Persistence, bảng **tenant\_wallets** được đặt tại YugabyteDB để đảm bảo tính nhất quán ACID tuyệt đối cho các giao dịch tài chính1....

Dưới đây là thiết kế chi tiết đáp ứng mô hình **FinOps & Prepaid Wallet** giúp tối ưu hóa dòng tiền và quản lý nợ xấu3.

1\. Thiết kế chi tiết bảng `tenant_wallets` (YSQL)

Bảng này tuân thủ nghiêm ngặt quy tắc về kiểu dữ liệu tiền tệ để tránh sai số làm tròn và sử dụng **UUID v7** để tối ưu hóa hiệu năng ghi phân tán4....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh ví duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian45. |
| **tenant\_id** | UUID | NO  |     | `UNIQUE`, `FOREIGN KEY` tham chiếu `tenants(_id)` | Mỗi khách hàng (Tenant) chỉ sở hữu duy nhất một ví chính67. |
| **balance** | NUMERIC(19, 4) | NO  | `0` | `CHECK (balance >= 0)` | Số dư khả dụng. Sử dụng **NUMERIC(19, 4)** để chính xác tuyệt đối 4 số lẻ4.... |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ theo chuẩn **ISO 4217** (VND, USD,...)46. |
| **is\_frozen** | BOOLEAN | NO  | `FALSE` |     | Nếu `TRUE`, ví bị đóng băng (không cho phép thanh toán) do nghi ngờ gian lận6. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Hỗ trợ **Optimistic Locking** để ngăn chặn ghi đè dữ liệu tài chính đồng thời910. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm khởi tạo ví (chuẩn UTC)711. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật số dư gần nhất612. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_wallets (
    -- Định danh & Tenancy
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    
    -- Tài chính & Tiền tệ
    balance NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- Trạng thái & Quản trị
    is_frozen BOOLEAN NOT NULL DEFAULT FALSE,
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Các ràng buộc dữ liệu (Constraints)
    CONSTRAINT uq_tenant_wallet UNIQUE (tenant_id),
    CONSTRAINT fk_wallet_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT chk_wallet_balance CHECK (balance >= 0),
    CONSTRAINT chk_currency_code_len CHECK (LENGTH(currency_code) = 3),
    CONSTRAINT chk_wallet_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tra cứu ví nhanh theo ID khách hàng (Bắt buộc cho SaaS)
CREATE INDEX idx_wallets_tenant_lookup ON tenant_wallets (tenant_id);

-- Index hỗ trợ bộ phận kế toán lọc các ví có số dư thấp để gửi cảnh báo nạp tiền
CREATE INDEX idx_wallets_low_balance ON tenant_wallets (balance) 
WHERE balance < 100000 AND is_frozen = FALSE;

-- Index hỗ trợ kiểm tra các ví bị đóng băng để xử lý nghiệp vụ
CREATE INDEX idx_wallets_frozen_status ON tenant_wallets (is_frozen) 
WHERE is_frozen = TRUE;
```

3\. Các lưu ý kỹ thuật quan trọng

• **Chống Ghi đè (Concurrency):** Trường `version` là bắt buộc. Khi thực hiện trừ tiền, ứng dụng phải kiểm tra `WHERE _id = ... AND version = current_version`. Nếu số bản ghi ảnh hưởng bằng 0, nghĩa là đã có giao dịch khác can thiệp, hệ thống phải yêu cầu thực hiện lại9.

• **Bất biến (Immutability):** Mọi thay đổi trong bảng `tenant_wallets` phải luôn đi kèm với một bản ghi tương ứng trong bảng `wallet_transactions` (Sổ cái). Ví chỉ lưu **số dư cuối**, còn bảng giao dịch lưu **lịch sử biến động** để đối soát313.

• **Chính xác tiền tệ:** Tuyệt đối không sử dụng kiểu dữ liệu `FLOAT` hay `DOUBLE` vì sẽ gây ra sai số lũy tiến khi thực hiện hàng triệu giao dịch trừ phí nhỏ (Micro-billing)4.

**Sự ví von:** Bảng `tenant_wallets` giống như một **thẻ ATM** của khách hàng trong hệ thống của bạn. Nó cho biết hiện tại họ có bao nhiêu tiền và thẻ có đang bị khóa hay không. Tuy nhiên, để biết tại sao tiền bị trừ, bạn phải xem "Sao kê" (bảng `wallet_transactions`), và nhờ vào "Két sắt" YugabyteDB, số dư trong thẻ luôn đảm bảo chính xác ngay cả khi có nhiều giao dịch xảy ra cùng lúc.



thiết kế chi tiết bảng wallet\_transactions dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng và nguyên tắc **Sổ cái bất biến (Immutable Ledger)** trong kiến trúc Polyglot Persistence, bảng **wallet\_transactions** được thiết kế để lưu trữ mọi biến động tài chính của khách hàng với độ chính xác tuyệt đối1,2.

Dưới đây là thiết kế chi tiết sử dụng **YSQL (YugabyteDB)**:

1\. Thiết kế chi tiết bảng `wallet_transactions`

Bảng này đóng vai trò là "nhật ký giao dịch", chỉ cho phép ghi mới (`INSERT`), không cho phép sửa hoặc xóa để đảm bảo tính minh bạch trong đối soát tài chính2,3.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh giao dịch duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian4,5. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định giao dịch thuộc về khách hàng nào để Sharding/Filtering6,7. |
| **wallet\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenant_wallets(_id)` | Liên kết trực tiếp với ví thực hiện biến động3. |
| **type** | VARCHAR(30) | NO  |     | `CHECK (type IN ('DEPOSIT', 'USAGE_DEDUCT', 'REFUND', 'BONUS'))` | Loại giao dịch: Nạp tiền, Trừ phí sử dụng, Hoàn tiền, Tặng thưởng8,3. |
| **amount** | NUMERIC(19, 4) | NO  |     | `CHECK (amount <> 0)` | Số tiền biến động. Dùng **NUMERIC(19, 4)** để chính xác tuyệt đối4,9. |
| **balance\_after** | NUMERIC(19, 4) | NO  |     | `CHECK (balance_after >= 0)` | **Snapshot số dư:** Số dư ví ngay sau khi thực hiện giao dịch này để đối soát3. |
| **reference\_id** | UUID | YES |     |     | Liên kết tới hóa đơn (`invoices`) hoặc đơn hàng (`orders`) phát sinh giao dịch3. |
| **description** | TEXT | YES |     |     | Mô tả chi tiết nội dung giao dịch (VD: "Trừ phí gửi 5000 email")3. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm phát sinh giao dịch chuẩn **UTC**8,10. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE wallet_transactions (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    wallet_id UUID NOT NULL,
    
    -- Chi tiết giao dịch
    type VARCHAR(30) NOT NULL,
    amount NUMERIC(19, 4) NOT NULL,
    balance_after NUMERIC(19, 4) NOT NULL,
    
    -- Tham chiếu & Mô tả
    reference_id UUID,
    description TEXT,
    
    -- Thời gian
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Các ràng buộc dữ liệu (Constraints)
    CONSTRAINT fk_tx_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_tx_wallet FOREIGN KEY (wallet_id) REFERENCES tenant_wallets(_id),
    CONSTRAINT chk_tx_type CHECK (type IN ('DEPOSIT', 'USAGE_DEDUCT', 'REFUND', 'BONUS')),
    CONSTRAINT chk_tx_amount_not_zero CHECK (amount <> 0),
    CONSTRAINT chk_tx_balance_after CHECK (balance_after >= 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index quan trọng nhất: Tra cứu lịch sử biến động của 1 ví theo thời gian giảm dần
-- Phục vụ tính năng "Sao kê tài khoản" cho khách hàng
CREATE INDEX idx_wallet_history 
ON wallet_transactions (wallet_id, created_at DESC);

-- Index hỗ trợ bộ phận kế toán đối soát theo loại giao dịch (VD: Tìm tất cả REFUND)
CREATE INDEX idx_wallet_tx_type 
ON wallet_transactions (tenant_id, type) 
WHERE type IN ('REFUND', 'BONUS');

-- Index hỗ trợ tra cứu nhanh từ hóa đơn/đơn hàng sang giao dịch ví
CREATE INDEX idx_wallet_tx_reference 
ON wallet_transactions (reference_id) 
WHERE reference_id IS NOT NULL;
```

3\. Phân tích các đặc điểm cải tiến

• **Tính bất biến (Immutability):** Bảng này được thiết kế theo mô hình **Sổ cái (Ledger)**. Mọi sai sót tài chính không được sửa trực tiếp mà phải thông qua một giao dịch đảo (ví dụ: giao dịch `REFUND` để đảo ngược một giao dịch `USAGE_DEDUCT` sai)2.

• **Snapshot Balance:** Việc lưu `balance_after` tại mỗi dòng giúp hệ thống có thể tính toán lại số dư tại bất kỳ thời điểm nào trong quá khứ mà không cần tính tổng (SUM) hàng triệu bản ghi, giúp tăng tốc độ đối soát3.

• **UUID v7 & Hiệu năng:** Sử dụng UUID v7 giúp các bản ghi giao dịch mới luôn được chèn vào cuối các cấu trúc index, giảm thiểu việc phân mảnh dữ liệu và giúp YugabyteDB phân tán dữ liệu đồng đều mà vẫn giữ được tính thứ tự theo thời gian4,5,11.

• **Chính xác tài chính:** Kiểu dữ liệu `NUMERIC(19, 4)` đảm bảo không phát sinh sai số lũy tiến (rounding errors) như kiểu `FLOAT` hay `DOUBLE`, đáp ứng yêu cầu khắt khe của các hệ thống Billing và Banking4,9.

**Sự ví von:** Bảng `wallet_transactions` giống như một **quyển sổ sao kê ngân hàng**. Mỗi dòng là một dấu mộc không thể tẩy xóa. Dù bạn nạp tiền hay tiêu tiền, cuốn sổ này sẽ ghi lại chính xác số tiền đó và số dư còn lại trong túi bạn ngay lúc đó, đảm bảo mọi thứ luôn minh bạch và có thể truy vết bất cứ lúc nào2.



thiết kế chi tiết bảng license\_allocations dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các phân tích về mô hình quản lý "Ghế" sử dụng (Seat Management) và tiêu chuẩn thiết kế SaaS World-class trong các nguồn tài liệu, bảng **license\_allocations** đóng vai trò là "chốt chặn" kiểm soát hạn ngạch sử dụng thực tế so với gói cước đã mua12. Bảng này ngăn chặn việc lạm dụng tài nguyên và đảm bảo tính chính xác trong việc tính tiền dựa trên người dùng (Seat-based billing)23.

Dưới đây là thiết kế chi tiết bảng sử dụng **YSQL (YugabyteDB)** với chuẩn **UUID v7** để tối ưu hóa hiệu năng phân tán và sắp xếp thời gian45.

1\. Thiết kế chi tiết bảng `license_allocations`

Bảng này được đặt tại tầng **Distributed SQL (YugabyteDB)** để đảm bảo tính nhất quán ACID tuyệt đối, tránh tình trạng một khách hàng có thể mời vượt quá số lượng người dùng đã trả tiền do độ trễ dữ liệu67.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**45. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định hạn ngạch thuộc về khách hàng nào89. |
| **subscription\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenant_subscriptions(_id)` | Liên kết trực tiếp với gói thuê bao hoặc hóa đơn đã mua1011. |
| **license\_type** | VARCHAR(30) | NO  | `'BILLABLE'` | `CHECK (IN ('BILLABLE', 'GUEST', 'READ_ONLY'))` | Loại giấy phép: Tính phí, Khách, hoặc Chỉ đọc2. |
| **purchased\_quantity** | INTEGER | NO  | `0` | `CHECK (>= 0)` | Tổng số lượng "ghế" khách hàng đã thanh toán2. |
| **assigned\_quantity** | INTEGER | NO  | `0` | `CHECK (assigned_quantity <= purchased_quantity)` | Số lượng thực tế đã gán cho người dùng. Không được vượt quá số mua2. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (IN ('ACTIVE', 'EXPIRED', 'SUSPENDED'))` | Trạng thái của hạn ngạch giấy phép. |
| **expires\_at** | TIMESTAMPTZ | YES |     |     | Thời điểm hết hạn của giấy phép này (thường khớp với gói cước)3. |
| **version** | BIGINT | NO  | `1` |     | **Optimistic Locking** để ngăn chặn gán quyền đồng thời gây vượt hạn ngạch1213. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)814. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng15. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE license_allocations (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    tenant_id UUID NOT NULL,
    subscription_id UUID NOT NULL,

    -- Thông tin hạn ngạch
    license_type VARCHAR(30) NOT NULL DEFAULT 'BILLABLE',
    purchased_quantity INTEGER NOT NULL DEFAULT 0,
    assigned_quantity INTEGER NOT NULL DEFAULT 0,
    
    -- Trạng thái & Thời gian
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    expires_at TIMESTAMPTZ,
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ràng buộc toàn vẹn (Constraints)
    CONSTRAINT fk_license_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_license_subscription FOREIGN KEY (subscription_id) REFERENCES tenant_subscriptions(_id),
    CONSTRAINT chk_license_limit CHECK (assigned_quantity <= purchased_quantity),
    CONSTRAINT chk_license_positive CHECK (purchased_quantity >= 0 AND assigned_quantity >= 0),
    CONSTRAINT chk_license_status CHECK (status IN ('ACTIVE', 'EXPIRED', 'SUSPENDED'))
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ kiểm tra hạn ngạch cực nhanh khi Admin mời thêm người dùng mới
-- Giúp query: WHERE tenant_id = ? AND license_type = 'BILLABLE' AND status = 'ACTIVE'
CREATE INDEX idx_license_check_limit 
ON license_allocations (tenant_id, license_type, status) 
WHERE status = 'ACTIVE';

-- Index hỗ trợ hệ thống Billing quét các giấy phép sắp hết hạn để gửi thông báo
CREATE INDEX idx_license_expiry_scan 
ON license_allocations (expires_at, status) 
WHERE expires_at IS NOT NULL;

-- Index hỗ trợ truy vấn lịch sử giấy phép của một Tenant cụ thể
CREATE INDEX idx_license_tenant_history 
ON license_allocations (tenant_id, created_at DESC);
```

3\. Phân tích các đặc điểm cải tiến đáp ứng yêu cầu SaaS

• **Kiểm soát Seat-based Billing:** Ràng buộc `assigned_quantity <= purchased_quantity` đảm bảo logic kinh doanh được thực thi ngay tại tầng cơ sở dữ liệu2. Khi một `tenant_member` mới được tạo, hệ thống sẽ thực hiện một transaction để tăng `assigned_quantity` và sẽ thất bại nếu vượt ngưỡng23.

• **Optimistic Locking (****version****):** Trong môi trường SaaS triệu người dùng, nhiều Admin của cùng một Tenant có thể mời người dùng đồng thời. Cột `version` đảm bảo rằng việc cập nhật số lượng ghế được kiểm soát chặt chẽ, tránh lỗi race condition1213.

• **Hỗ trợ Hybrid Billing:** Bảng này quản lý phần "tĩnh" (số ghế cố định). Đối với các phần "động" (như dung lượng lưu trữ vượt mức hoặc số email gửi thêm), hệ thống sẽ kết hợp với bảng `tenant_usages` từ ClickHouse để tính tiền16....

• **Tối ưu Sharding với UUID v7:** Việc sử dụng UUID v7 giúp các bản ghi mới của các Tenant khác nhau được dàn đều trên các cụm (clusters) của YugabyteDB, tránh hiện tượng "Hotspot" ghi dữ liệu, đồng thời vẫn giữ được tính thứ tự thời gian để truy vấn báo cáo nhanh chóng4....

**Sự ví von:** Bảng `license_allocations` giống như một **người soát vé tại rạp phim**. Khách hàng có thể mua một combo 10 vé (purchased\_quantity). Mỗi khi có một người bạn của khách vào rạp, người soát vé sẽ bấm một lỗ trên thẻ (assigned\_quantity). Khi đã bấm đủ 10 lỗ, người soát vé sẽ chặn người thứ 11 lại và yêu cầu khách hàng ra quầy mua thêm vé mới (Upgrade Plan)3.



thiết kế chi tiết bảng price\_adjustments dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn thiết kế hệ thống SaaS đa khách hàng (Multi-tenant) và các tiêu chuẩn về dữ liệu tài chính (ACID) đã thống nhất trong các nguồn tài liệu, bảng **price\_adjustments** đóng vai trò quan trọng trong việc minh bạch hóa hóa đơn1.

Thay vì chỉ lưu giá cuối cùng, việc tách riêng các khoản điều chỉnh giúp khách hàng biết rõ họ được giảm giá (Discount) hay phải chịu phụ phí (Surcharge) gì, đảm bảo nguyên tắc "Sự chính xác và minh bạch ưu tiên hơn dung lượng lưu trữ"2.

1\. Thiết kế chi tiết bảng `price_adjustments` (YSQL)

Dữ liệu tiền tệ trong bảng này bắt buộc sử dụng `NUMERIC(19, 4)` để đảm bảo độ chính xác tuyệt đối, không sai số làm tròn23.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian24. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)`56 | Xác định khoản điều chỉnh này thuộc về khách hàng nào. |
| **subscription\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenant_subscriptions(_id)` | Liên kết với một thuê bao cụ thể của khách hàng. |
| **invoice\_id** | UUID | YES |     | `FOREIGN KEY` tham chiếu `subscription_invoices(_id)` | Liên kết với hóa đơn cụ thể (nếu điều chỉnh theo từng kỳ thanh toán). |
| **type** | VARCHAR(20) | NO  |     | `CHECK (type IN ('DISCOUNT', 'SURCHARGE', 'TAX', 'REBATE'))` | Loại điều chỉnh: Giảm giá, phụ phí, thuế, hoặc hoàn tiền37. |
| **amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (amount >= 0)` | Giá trị tuyệt đối của khoản điều chỉnh23. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length(currency_code) = 3)` | Mã tiền tệ ISO 421728. |
| **reason** | TEXT | NO  |     | `CHECK (length(reason) > 0)` | Lý do điều chỉnh (VD: "Giảm giá khách hàng thân thiết", "Phí quá hạn"). |
| **source** | VARCHAR(30) | NO  | `'MANUAL'` |     | Nguồn gốc: `MANUAL` (Admin nhập), `COUPON`, `AUTOMATIC_POLICY`. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Hỗ trợ **Optimistic Locking**910. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)711. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng11. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE price_adjustments (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application [2]
    tenant_id UUID NOT NULL,
    subscription_id UUID NOT NULL,
    invoice_id UUID, 
    
    -- Chi tiết tài chính
    type VARCHAR(20) NOT NULL,
    amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    
    -- Nghiệp vụ & Giải trình
    reason TEXT NOT NULL,
    source VARCHAR(30) NOT NULL DEFAULT 'MANUAL',
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Các ràng buộc (Constraints) [6, 8]
    CONSTRAINT fk_adj_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id),
    CONSTRAINT fk_adj_subscription FOREIGN KEY (subscription_id) REFERENCES tenant_subscriptions(_id),
    CONSTRAINT fk_adj_invoice FOREIGN KEY (invoice_id) REFERENCES subscription_invoices(_id),
    CONSTRAINT chk_adj_type CHECK (type IN ('DISCOUNT', 'SURCHARGE', 'TAX', 'REBATE')),
    CONSTRAINT chk_adj_amount CHECK (amount >= 0),
    CONSTRAINT chk_adj_currency CHECK (LENGTH(currency_code) = 3),
    CONSTRAINT chk_adj_version CHECK (version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY) [10]

-- Index hỗ trợ lấy tất cả các khoản điều chỉnh cho một Tenant cụ thể
CREATE INDEX idx_price_adj_tenant ON price_adjustments (tenant_id, created_at DESC);

-- Index hỗ trợ liệt kê các khoản giảm giá/phụ phí của một thuê bao (Subscription)
CREATE INDEX idx_price_adj_subscription ON price_adjustments (subscription_id);

-- Index hỗ trợ đối soát hóa đơn: Tìm các điều chỉnh thuộc về một hóa đơn nhất định
CREATE INDEX idx_price_adj_invoice ON price_adjustments (invoice_id) 
WHERE invoice_id IS NOT NULL;
```

3\. Phân tích bổ sung dựa trên nguồn tài liệu

• **Tính Minh bạch (Transparency):** Bảng này hiện thực hóa yêu cầu lưu "giá gốc riêng, giá đã giảm riêng" để làm rõ hóa đơn1. Khi xuất hóa đơn, hệ thống sẽ cộng dồn các dòng trong bảng này để giải thích cho khách hàng về con số tổng cuối cùng.

• **Optimistic Locking:** Sử dụng trường `version` đảm bảo rằng nếu hai Admin cùng điều chỉnh giá của một đơn hàng cùng lúc, hệ thống sẽ ngăn chặn việc ghi đè dữ liệu sai lệch9.

• **Sẵn sàng cho Sharding:** Việc sử dụng `_id` là UUID v7 giúp YugabyteDB phân tán dữ liệu đồng đều trên các node (Tablet Server) mà vẫn giữ được tính thứ tự theo thời gian, giúp các truy vấn báo cáo tài chính theo kỳ đạt hiệu năng cao nhất412.

**Sự ví von:** Bảng `price_adjustments` giống như **phần chú thích dưới cùng của một tờ hóa đơn siêu thị**. Thay vì chỉ ghi "Tổng: 90k", nó liệt kê chi tiết: "Giá gốc: 100k", "Giảm giá thành viên: -15k", "Túi nilon: +5k". Nhờ vậy, khách hàng luôn tin tưởng vào hệ thống vì mọi con số đều có nguồn gốc rõ ràng.



thiết kế chi tiết bảng business\_reports dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên kiến trúc **Polyglot Persistence** và các quy chuẩn thiết kế hệ thống SaaS triệu người dùng, bảng **business\_reports** được đặt tại **ClickHouse** để tận dụng khả năng lưu trữ dạng cột (Columnar Storage), giúp nén dữ liệu cực tốt và tính toán tổng hợp trên hàng tỷ bản ghi chỉ trong vài mili giây12.

Bảng này không lưu dữ liệu thô (raw events) mà lưu các kết quả đã được tổng hợp (Aggregated Metrics) theo ngày/tháng để phục vụ các biểu đồ Dashboard và báo cáo kinh doanh cho chủ sở hữu Tenant và quản trị viên hệ thống23.

1\. Thiết kế chi tiết bảng `business_reports` (ClickHouse)

Dưới đây là cấu trúc bảng được tối ưu hóa cho truy vấn phân tích (OLAP). Theo quy tắc của ClickHouse, chúng ta ưu tiên sử dụng các kiểu dữ liệu nén tốt và tránh các cột Nullable để tăng hiệu năng45.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | Khóa chính logic (UUID v7) | Định danh duy nhất cho bản ghi báo cáo67. |
| **tenant\_id** | UUID | NO  |     | Thành phần của **Sorting Key** | Xác định báo cáo thuộc về khách hàng nào89. |
| **app\_code** | String | NO  | `'ALL'` | Thành phần của **Sorting Key** | Mã ứng dụng phát sinh báo cáo (VD: 'HRM', 'CRM') hoặc 'ALL' cho báo cáo tổng10. |
| **report\_type** | Enum8 | NO  |     | `'FINANCE'=1, 'USAGE'=2, 'ACTIVITY'=3` | Phân loại báo cáo để tối ưu nén và lọc dữ liệu45. |
| **metric\_name** | String | NO  |     | VD: `revenue`, `active_users`, `emails_sent` | Tên chỉ số đo lường. |
| **metric\_value** | Decimal128(4) | NO  | `0` | Chính xác 4 số lẻ | Giá trị định lượng của chỉ số (số tiền hoặc số lượng)511. |
| **currency\_code** | String | NO  | `'VND'` | `Length = 3` | Mã tiền tệ ISO 4217 (nếu là báo cáo tài chính)511. |
| **report\_date** | Date32 | NO  |     | Thành phần của **Sorting Key** | Ngày tham chiếu của báo cáo (YYYY-MM-DD)45. |
| **metadata** | String | NO  | `'{}'` | Lưu dưới dạng JSON String | Các thông tin bổ sung tùy biến (Vùng miền, nhóm khách hàng)5. |
| **created\_at** | DateTime64(3) | NO  | `now()` | Độ chính xác mili-giây | Thời điểm hệ thống sinh báo cáo (UTC)45. |

\--------------------------------------------------------------------------------

2\. Câu lệnh ClickHouse tạo bảng và Index

Trong ClickHouse, "Index" thực tế được quyết định bởi cấu trúc `ORDER BY` (Sparse Index). Chúng ta sẽ sử dụng `MergeTree` engine để đảm bảo khả năng mở rộng212.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE business_reports (
    _id UUID,
    tenant_id UUID,
    app_code String,
    report_type Enum8('FINANCE' = 1, 'USAGE' = 2, 'ACTIVITY' = 3),
    metric_name String,
    metric_value Decimal128(4),
    currency_code String DEFAULT 'VND',
    report_date Date32,
    metadata String DEFAULT '{}',
    created_at DateTime64(3, 'UTC') DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để dễ dàng quản lý vòng đời (Archiving/Purge)
PARTITION BY toYYYYMM(report_date)
-- Sắp xếp dữ liệu tối ưu cho truy vấn Dashboard của từng Tenant
ORDER BY (tenant_id, report_type, app_code, report_date, _id)
SETTINGS index_granularity = 8192;

-- 2. TẠO DATA SKIPPING INDEX (Tối ưu hóa tìm kiếm sâu)
-- Giúp tăng tốc khi tìm kiếm các chỉ số cụ thể trong tập dữ liệu khổng lồ
ALTER TABLE business_reports 
ADD INDEX idx_metric_name metric_name TYPE set(1000) GRANULARITY 2;

-- Giúp tăng tốc lọc theo giá trị lớn (Ví dụ: Tìm các báo cáo có doanh thu đột biến)
ALTER TABLE business_reports 
ADD INDEX idx_value_minmax metric_value TYPE minmax GRANULARITY 2;
```

3\. Phân tích tính đáp ứng và lợi ích kỹ thuật

• **Hiệu năng tổng hợp:** Nhờ lưu trữ dạng cột, khi bạn cần tính "Tổng doanh thu của Tenant A trong năm 2024", ClickHouse chỉ đọc đúng cột `metric_value` và `tenant_id`, bỏ qua toàn bộ các cột khác, giúp tốc độ nhanh hơn gấp hàng trăm lần so với SQL truyền thống2.

• **Tính linh hoạt:** Cột `metadata` dạng JSON String cho phép bạn lưu trữ các chiều phân tích (dimensions) mới mà không cần thay đổi cấu trúc bảng5. Bạn có thể dùng hàm `JSONExtract` của ClickHouse để truy vấn trực tiếp vào các trường này.

• **Tối ưu chi phí:** ClickHouse có khả năng nén dữ liệu lên tới tỷ lệ 10:1. Một hệ thống có hàng trăm triệu bản ghi báo cáo chỉ tốn vài GB ổ cứng thay vì hàng trăm GB như trên MongoDB hay PostgreSQL2.

• **Chiến lược Sharding:** Việc đưa `tenant_id` lên đầu `ORDER BY` đảm bảo rằng dữ liệu của cùng một khách hàng sẽ nằm gần nhau trên đĩa vật lý, giúp việc load Dashboard cá nhân hóa của khách hàng đạt tốc độ micro-seconds313.

**Sự ví von:** Bảng `business_reports` giống như một **cuốn sổ cái tổng kết cuối ngày** của một siêu thị. Thay vì đếm từng tờ hóa đơn lẻ (Usage Events), người quản lý chỉ cần nhìn vào dòng "Tổng kết doanh thu ngày 20/10". ClickHouse chính là người thủ thư siêu cấp có thể lật tìm và cộng tổng hàng ngàn cuốn sổ cái như vậy trong chớp mắt để đưa ra bức tranh toàn cảnh về "Sức khỏe" của toàn bộ doanh nghiệp.



đổi tên business\_reports thành saas\_business\_reports chuyên báo cáo doanh thu của hệ thống saas (không liên quan gì các phần mềm cho khách hàng thuê)

Theo yêu cầu của bạn, tôi đã thiết kế lại bảng **saas\_business\_reports** trên **YSQL (YugabyteDB)**. Bảng này được tinh chỉnh để tập trung hoàn toàn vào việc theo dõi doanh thu tổng thể của hệ thống SaaS (MRR, ARR, doanh thu theo gói cước) thay vì báo cáo vận hành của từng khách hàng riêng lẻ12.

Dưới đây là thiết kế chi tiết đáp ứng các tiêu chuẩn về dữ liệu tài chính (ACID) và hiệu năng phân tán13.

1\. Thiết kế chi tiết bảng `saas_business_reports`

Bảng này đóng vai trò là "Sổ cái báo cáo tài chính" của chủ hệ thống SaaS, lưu trữ các chỉ số doanh thu đã được tổng hợp để phục vụ Dashboard quản trị cấp cao24.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh báo cáo chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian56. |
| **report\_date** | DATE | NO  |     | `UNIQUE` với `revenue_category` | Ngày tổng hợp dữ liệu (YYYY-MM-DD)78. |
| **revenue\_category** | VARCHAR(50) | NO  |     | `CHECK` danh sách phân loại | Loại doanh thu hệ thống: `NEW_SUBSCRIPTION`, `RENEWAL`, `UPGRADE`, `ADD_ON`78. |
| **total\_amount** | NUMERIC(19,4) | NO  | `0` | `CHECK (total_amount >= 0)` | **Doanh thu tổng:** Chính xác tuyệt đối 4 số lẻ theo tiêu chuẩn tài chính58. |
| **currency\_code** | VARCHAR(3) | NO  | `'VND'` | `CHECK (length = 3)` | Mã tiền tệ hệ thống (VND, USD...) theo ISO 421758. |
| **tenant\_count** | INTEGER | NO  | `0` | `CHECK (tenant_count >= 0)` | Số lượng khách hàng (Tenant) đóng góp vào con số doanh thu này. |
| **details\_breakdown** | **JSONB** | NO  | `'{}'` |     | Chứa chi tiết doanh thu theo từng gói cước (Ví dụ: `{"pro_plan": 5000, "ent_plan": 15000}`)89. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** khi có nhiều Job tổng hợp chạy song song1011. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm hệ thống sinh báo cáo (UTC)78. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng12. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL để tạo bảng và Index

Thiết kế này sử dụng các Index tối ưu cho việc truy vấn báo cáo theo chu kỳ thời gian và phân tích xu hướng doanh thu1314.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE saas_business_reports (
    -- Định danh & Thời gian
    _id UUID PRIMARY KEY, -- UUID v7
    report_date DATE NOT NULL,
    
    -- Phân loại & Giá trị
    revenue_category VARCHAR(50) NOT NULL,
    total_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,
    currency_code VARCHAR(3) NOT NULL DEFAULT 'VND',
    tenant_count INTEGER NOT NULL DEFAULT 0,
    
    -- Dữ liệu chi tiết (Phân tách theo gói cước)
    details_breakdown JSONB NOT NULL DEFAULT '{}',
    
    -- Quản trị
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ràng buộc dữ liệu
    CONSTRAINT uq_report_date_category UNIQUE (report_date, revenue_category),
    CONSTRAINT chk_revenue_amount CHECK (total_amount >= 0),
    CONSTRAINT chk_revenue_category CHECK (revenue_category IN ('NEW_SUBSCRIPTION', 'RENEWAL', 'UPGRADE', 'ADD_ON', 'TAX_COLLECTED')),
    CONSTRAINT chk_currency_len CHECK (LENGTH(currency_code) = 3)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ vẽ biểu đồ xu hướng doanh thu theo thời gian
-- Giúp query: WHERE report_date BETWEEN '2024-01-01' AND '2024-12-31'
CREATE INDEX idx_saas_report_timeline 
ON saas_business_reports (report_date DESC, revenue_category);

-- Index hỗ trợ phân tích hiệu quả của từng loại doanh thu
CREATE INDEX idx_saas_revenue_type 
ON saas_business_reports (revenue_category, total_amount DESC);

-- Index GIN để truy vấn sâu vào doanh thu của từng mã gói cước trong JSONB
CREATE INDEX idx_saas_report_details 
ON saas_business_reports USING GIN (details_breakdown);
```

3\. Phân tích tính đáp ứng chuyên sâu

• **Chuyên biệt hóa Doanh thu:** Khác với các bảng báo cáo trước đây dành cho khách hàng, bảng này tập trung vào các chỉ số như `RENEWAL` (Doanh thu gia hạn) và `UPGRADE` (Doanh thu nâng cấp gói), giúp chủ hệ thống SaaS đánh giá được tốc độ tăng trưởng và tỷ lệ rời bỏ (Churn rate) của toàn sàn215.

• **Độ chính xác tài chính tuyệt đối:** Việc sử dụng `NUMERIC(19, 4)` trong YSQL đảm bảo tính toàn vẹn khi cộng dồn hàng triệu hóa đơn từ bảng `subscription_invoices` thành các con số báo cáo tổng, đáp ứng yêu cầu "Két sắt an toàn" của hệ thống35.

• **Tối ưu hóa báo cáo (Snapshot):** Thay vì mỗi lần xem Dashboard hệ thống phải `SUM` hàng tỷ dòng hóa đơn, bảng này lưu trữ kết quả đã tính toán xong. Dữ liệu này thường được tổng hợp định kỳ từ ClickHouse hoặc qua tiến trình Worker quét từ YugabyteDB24.

• **Linh hoạt với JSONB:** Cột `details_breakdown` cho phép bạn bổ sung thêm các chiều phân tích mới (ví dụ: doanh thu theo khu vực địa lý hoặc theo phương thức thanh toán) mà không cần thay đổi cấu trúc bảng1617.

**Sự ví von:** Bảng `saas_business_reports` giống như một **quyển sổ tổng kết tài chính** của ông chủ trung tâm thương mại. Trong khi các khách thuê có sổ riêng của họ, thì quyển sổ này chỉ ghi nhận: "Hôm nay thu được bao nhiêu tiền mặt bằng, bao nhiêu tiền điện, và bao nhiêu phí quản lý từ tất cả các gian hàng cộng lại", giúp ông chủ biết được trung tâm đang lãi hay lỗ một cách nhanh chóng nhất.



lưu trên YSQL hay ClickHouse?

Dựa trên triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) được đề cập trong các nguồn tài liệu, việc lựa chọn giữa **YugabyteDB (YSQL)** và **ClickHouse** phụ thuộc hoàn toàn vào tính chất của dữ liệu và mục đích sử dụng1,2.

Dưới đây là sự phân loại chi tiết để bạn quyết định lưu trữ dữ liệu ở đâu cho tối ưu:

1\. Lưu trữ trên YugabyteDB (YSQL) - "Két sắt an toàn"

Bạn nên sử dụng YugabyteDB cho các loại **dữ liệu lõi (Critical Data)**, yêu cầu tính **nhất quán tuyệt đối (ACID)** và quan hệ chặt chẽ3,4.

• **Các bảng nên lưu ở đây:**

    ◦ **Định danh & Tổ chức:** `tenants`, `users`, `tenant_members`, `user_groups`, `tenant_app_routes`4,5.    ◦ **Gói cước & Quyền hạn:** `service_packages`, `tenant_subscriptions`, `license_allocations`4,6.    ◦ **Tài chính & Giao dịch:** `subscription_orders`, `subscription_invoices`, `tenant_wallets`, `wallet_transactions`, `price_adjustments`4,7.    ◦ **Dữ liệu tiêu dùng đã tổng hợp:** `tenant_usages` (Dữ liệu này đã được tinh gọn từ ClickHouse để phục vụ tính tiền chính xác)8,9,10.    ◦ **Báo cáo tài chính snapshot:** `saas_business_reports` (Nếu chỉ lưu các con số tổng kết theo ngày/tháng để xem nhanh)11.

• **Lý do:** YugabyteDB đảm bảo khi một giao dịch (như trừ tiền ví hoặc gia hạn gói) thành công, dữ liệu phải chính xác ở tất cả các node, tránh thất thoát tài chính4,12.

2\. Lưu trữ trên ClickHouse - "Bộ nhớ vĩnh cửu"

Bạn nên sử dụng ClickHouse cho các loại **dữ liệu lớn (Big Data)**, dữ liệu lịch sử, chỉ ghi thêm (**Append-only**) và phục vụ **phân tích chuyên sâu (OLAP)**12,13.

• **Các bảng nên lưu ở đây:**

    ◦ **Dữ liệu tiêu dùng thô (Metering):** `usage_events` (Ghi lại hàng tỷ hành động như gửi email, upload file, gọi API)13,14,15.    ◦ **Nhật ký hệ thống:** `audit_logs` (Ai làm gì, lúc nào), `api_usage_logs`, `webhook_delivery_logs`13,16,17.    ◦ **Báo cáo xu hướng:** Các bảng phân tích hành vi người dùng, dự báo tăng trưởng hoặc biểu đồ dashboard phức tạp quét trên tập dữ liệu khổng lồ13,7.

• **Lý do:** ClickHouse có khả năng nén dữ liệu cực tốt (tỷ lệ 10:1) và tốc độ tính toán tổng hợp (SUM, AVG, COUNT) trên hàng tỷ dòng chỉ mất vài mili giây, điều mà YugabyteDB sẽ gặp khó khăn nếu quy mô dữ liệu quá lớn13.

3\. Mô hình phối hợp (Data Flow)

Trong hệ thống SaaS hiện đại, hai cơ sở dữ liệu này thường hoạt động song song theo luồng18,19:

1\. **Ghi nhận:** Mọi sự kiện tiêu dùng thô được đẩy vào **ClickHouse** (`usage_events`) để tận dụng tốc độ ghi và nén14,10.

2\. **Tổng hợp:** Một tiến trình Worker sẽ định kỳ quét ClickHouse, tính tổng lượng dùng và "bơm" kết quả đã tinh gọn sang **YugabyteDB** (`tenant_usages`)8,10.

3\. **Thanh toán:** Hệ thống Billing tại **YugabyteDB** dựa trên số liệu tổng hợp đó để xuất hóa đơn và trừ tiền ví, đảm bảo tính chính xác tài chính7,20.

**Tóm lại:**

• Cái gì liên quan đến **Tiền, Quyền và Cấu hình khách hàng** -> Chọn **YSQL**4.

• Cái gì liên quan đến **Log, Sự kiện thô và Báo cáo xu hướng lớn** -> Chọn **ClickHouse**1213.

**Sự ví von:** YugabyteDB giống như một **quyển sổ cái ngân hàng**, ghi chép từng đồng lẻ không sai một ly; còn ClickHouse giống như một **trạm quan sát khí tượng**, thu thập hàng triệu hạt mưa mỗi giây để đưa ra dự báo về cơn bão doanh thu của bạn713.



trong trường hợp bảng saas\_business\_reports nên lưu trên YSQL hay ClickHouse?

Việc lựa chọn lưu trữ bảng **saas\_business\_reports** ở đâu phụ thuộc vào mục đích sử dụng cụ thể của báo cáo này: là để đối soát tài chính chính xác tuyệt đối hay để phục vụ các biểu đồ phân tích tốc độ cao. Dựa trên triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) từ các nguồn tài liệu, dưới đây là phân tích chi tiết cho hai trường hợp1,2:

1\. Trường hợp chọn YugabyteDB (YSQL) - Ưu tiên tính "Chính xác tài chính"

Nếu bảng này đóng vai trò là một **Sổ cái doanh thu (Financial Ledger)**, lưu trữ các con số tổng kết cuối cùng của hệ thống (như MRR - Doanh thu định kỳ hàng tháng, ARR) để báo cáo thuế hoặc quyết toán tài chính, bạn nên chọn **YugabyteDB**1,3.

• **Lý do chọn YSQL:**

    ◦ **Tính nhất quán ACID:** Đảm bảo dữ liệu báo cáo doanh thu không bao giờ bị sai lệch hoặc mất mát do lỗi mạng hay sự cố hệ thống3.    ◦ **Dữ liệu lõi (Critical Data):** Doanh thu hệ thống là dữ liệu cực kỳ quan trọng. YugabyteDB đóng vai trò như một "Két sắt an toàn" bảo vệ các con số này3,4.    ◦ **Độ chính xác cao:** Hỗ trợ kiểu dữ liệu `NUMERIC(19, 4)` giúp tránh các sai số làm tròn trong tài chính5,6.    ◦ **Cập nhật dữ liệu:** Nếu báo cáo cần được cập nhật (Overwrite) khi có sự thay đổi về trạng thái hóa đơn, YugabyteDB xử lý việc này tốt hơn ClickHouse7,8.

2\. Trường hợp chọn ClickHouse - Ưu tiên tính "Phân tích và Tốc độ"

Nếu bảng này được dùng để phục vụ các **Dashboard quản trị (OLAP)**, nơi bạn cần lọc doanh thu theo nhiều chiều (quốc gia, loại gói cước, khoảng thời gian dài nhiều năm) và yêu cầu kết quả hiển thị ngay lập tức, bạn nên chọn **ClickHouse**1,9,10.

• **Lý do chọn ClickHouse:**

    ◦ **Tốc độ tổng hợp (Aggregation Speed):** Tính toán tổng doanh thu (SUM), số lượng khách hàng (COUNT) trên hàng triệu bản ghi chỉ trong vài mili giây10,7.    ◦ **Nén dữ liệu:** Tiết kiệm chi phí lưu trữ đáng kể nhờ khả năng nén dữ liệu dạng cột lên tới tỷ lệ 10:110.    ◦ **Phân tích đa chiều:** ClickHouse hỗ trợ các truy vấn báo cáo phức tạp mà không làm ảnh hưởng đến hiệu năng của hệ thống giao dịch đang chạy11,12.

3\. Lời khuyên dựa trên luồng dữ liệu chuẩn (Best Practice)

Trong một hệ thống SaaS "World-class", người ta thường kết hợp cả hai theo mô hình **CQRS**13:

1\. **Dữ liệu thô và Phân tích nhanh (ClickHouse):** Lưu các sự kiện doanh thu, log hóa đơn vào ClickHouse để phục vụ các biểu đồ xu hướng và phân tích hành vi kinh doanh9,10.

2\. **Sổ cái doanh thu (YugabyteDB):** Một tiến trình Worker sẽ tổng hợp dữ liệu từ ClickHouse và ghi các con số "chốt sổ" cuối cùng vào bảng `saas_business_reports` trên YugabyteDB11,7.

**Kết luận:**

• Nếu bạn cần một nơi để **lưu trữ các con số doanh thu đã chốt** để làm bằng chứng tài chính: Chọn **YSQL**.

• Nếu bạn cần một nơi để **truy vấn biểu đồ Dashboard** linh hoạt và nhanh chóng: Chọn **ClickHouse**.

**Sự ví von:** YugabyteDB giống như **Báo cáo tài chính đã kiểm toán**, mọi con số phải khớp nhau từng đồng lẻ; còn ClickHouse giống như một **Radar kinh doanh**, giúp ông chủ nhìn thấy toàn cảnh thị trường và tốc độ tăng trưởng của con tàu SaaS trong thời gian thực10,12.



bảng trên dùng để truy vấn biểu đồ Dashboard linh hoạt và nhanh chóng

Dựa trên triết lý **"Polyglot Persistence"** (Dùng đúng công cụ cho đúng việc) từ các nguồn tài liệu, nếu mục tiêu chính của bạn là **truy vấn biểu đồ Dashboard linh hoạt và nhanh chóng**, bảng **saas\_business\_reports** (hoặc các bảng báo cáo tương tự) nên được lưu trữ trên **ClickHouse**1,2,3.

Dưới đây là các lý do chi tiết và phân tích sâu hơn về việc lựa chọn này:

1\. ClickHouse là "Bộ nhớ vĩnh cửu" tối ưu cho Dashboard

Các nguồn tài liệu khẳng định ClickHouse đóng vai trò là **Analytical Database (OLAP)**, chuyên xử lý các tập dữ liệu lớn phục vụ báo cáo thống kê và Dashboard1,2.

• **Tốc độ tổng hợp (Aggregation Speed):** ClickHouse có thể tính toán các chỉ số như tổng doanh thu (SUM), trung bình (AVG), hoặc đếm (COUNT) trên hàng tỷ bản ghi chỉ trong vài mili-giây3. Trong khi đó, các CSDL SQL truyền thống hoặc MongoDB có thể mất vài phút hoặc gây treo hệ thống khi thực hiện các tác vụ này3.

• **Lưu trữ dạng cột (Columnar Storage):** ClickHouse nén dữ liệu cực tốt (tỷ lệ 10:1), giúp tiết kiệm chi phí ổ cứng và tăng tốc độ đọc dữ liệu vì chỉ truy cập đúng những cột cần thiết cho biểu đồ (ví dụ: chỉ đọc cột `total_amount` và `report_date`)3,4.

2\. Tách biệt hoàn toàn để bảo vệ hệ thống giao dịch

Việc lưu bảng báo cáo Dashboard trên ClickHouse giúp hệ thống của bạn vận hành theo mô hình **CQRS (Tách biệt ghi và đọc)**5,6:

• **Không ảnh hưởng đến hiệu năng:** Khi CEO hoặc quản trị viên xem "Biểu đồ năng suất" hay "Xu hướng doanh thu 12 tháng", Backend sẽ truy vấn trực tiếp vào ClickHouse6. Hành động này hoàn toàn không chiếm dụng tài nguyên của YugabyteDB, đảm bảo các thao tác thanh toán hay đăng ký của khách hàng khác vẫn diễn ra mượt mà6.

• **Truy vấn linh hoạt:** Bạn có thể thực hiện các câu lệnh SQL báo cáo phức tạp (JOIN, GROUP BY) với khối lượng dữ liệu khổng lồ mà không sợ làm chậm hệ thống đang chạy (Operational System)2,6.

3\. Luồng dữ liệu cho Dashboard (Data Flow)

Để bảng báo cáo trên ClickHouse luôn có dữ liệu mới nhất cho Dashboard, hệ thống sẽ thực hiện theo quy trình sau5,7:

1\. **Ghi nhận:** Các giao dịch tài chính (Hóa đơn, nạp tiền) được thực hiện chính xác tại YugabyteDB8,9.

2\. **Đồng bộ (CDC):** Sử dụng các công cụ như **Debezium và Kafka** để lắng nghe thay đổi từ YugabyteDB và đẩy dữ liệu sang ClickHouse10,7.

3\. **Báo cáo:** Dữ liệu tại ClickHouse đã sẵn sàng để Dashboard truy vấn "cực nhanh"6.

Tóm tắt lựa chọn

• Nếu bạn cần **độ chính xác tuyệt đối từng đồng** để làm sổ cái tài chính: Chọn **YugabyteDB (YSQL)**8,11.

• Nếu bạn cần **tốc độ hiển thị biểu đồ và phân tích linh hoạt** trên tập dữ liệu lớn: Chọn **ClickHouse**3,7.

**Ví von:** Nếu YugabyteDB là **két sắt** giữ từng tờ hóa đơn gốc một cách cẩn thận, thì ClickHouse là một **bảng điều khiển (Radar)** hiện đại, giúp bạn nhìn thấy toàn bộ bức tranh tăng trưởng của con tàu SaaS trong thời gian thực với tốc độ ánh sáng12,13.



thiết kế chi tiết bảng saas\_business\_reports dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên kiến trúc **Polyglot Persistence** và vai trò của **ClickHouse** là kho lưu trữ dữ liệu phân tích (OLAP), bảng **saas\_business\_reports** được thiết kế để phục vụ các biểu đồ Dashboard doanh thu hệ thống với tốc độ cực nhanh, ngay cả khi dữ liệu lên tới hàng tỷ bản ghi,,.

Việc sử dụng ClickHouse giúp hệ thống tính toán các chỉ số như MRR (Doanh thu định kỳ hàng tháng), ARR và tốc độ tăng trưởng chỉ trong vài mili giây mà không gây tải cho cơ sở dữ liệu giao dịch (YugabyteDB),.

1\. Thiết kế chi tiết bảng `saas_business_reports` (ClickHouse)

Trong ClickHouse, chúng ta ưu tiên sử dụng các kiểu dữ liệu nén tốt và tránh các cột Nullable để đạt hiệu suất tối đa,.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | Khóa chính logic (UUID v7) | Định danh duy nhất cho bản ghi báo cáo. |
| **report\_date** | Date32 | NO  |     | Thành phần của **Sorting Key** | Ngày tham chiếu của dữ liệu báo cáo (YYYY-MM-DD),. |
| **revenue\_category** | Enum8 | NO  |     | `'NEW'=1, 'RENEWAL'=2, 'UPGRADE'=3, 'ADD_ON'=4` | Phân loại doanh thu để nén dữ liệu cực tốt,. |
| **total\_revenue** | Decimal128(4) | NO  | `0` | Chính xác tuyệt đối 4 số lẻ | Tổng doanh thu hệ thống của hạng mục đó trong ngày,. |
| **currency\_code** | FixedString(3) | NO  | `'VND'` | Chuẩn ISO 4217 | Mã tiền tệ (VND, USD,...),. |
| **tenant\_count** | UInt32 | NO  | `0` |     | Số lượng khách hàng đóng góp vào doanh thu này. |
| **details\_json** | String | NO  | `'{}'` | Dữ liệu dạng JSON String | Chi tiết doanh thu theo từng gói (Pro, Enterprise,...),. |
| **created\_at** | DateTime64(3) | NO  | `now()` | Độ chính xác mili-giây | Thời điểm hệ thống sinh báo cáo (UTC),. |

\--------------------------------------------------------------------------------

2\. Câu lệnh ClickHouse tạo bảng và Index

ClickHouse sử dụng công cụ **MergeTree** để lưu trữ và sắp xếp dữ liệu trên ổ đĩa. Khác với SQL truyền thống, "Index" ở đây được xác định chủ yếu qua cấu trúc `ORDER BY` (Sparse Index),.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE saas_business_reports (
    _id UUID,
    report_date Date32,
    revenue_category Enum8('NEW' = 1, 'RENEWAL' = 2, 'UPGRADE' = 3, 'ADD_ON' = 4),
    total_revenue Decimal128(4),
    currency_code FixedString(3) DEFAULT 'VND',
    tenant_count UInt32,
    details_json String DEFAULT '{}',
    created_at DateTime64(3, 'UTC') DEFAULT now()
)
ENGINE = MergeTree()
-- Phân vùng dữ liệu theo tháng để tối ưu việc xóa/truy xuất dữ liệu cũ
PARTITION BY toYYYYMM(report_date)
-- Sắp xếp dữ liệu theo ngày và loại doanh thu để biểu đồ load nhanh nhất
ORDER BY (report_date, revenue_category, _id)
SETTINGS index_granularity = 8192;

-- 2. TẠO DATA SKIPPING INDEX (Hỗ trợ truy vấn sâu)
-- Giúp tăng tốc khi lọc các báo cáo có doanh thu lớn bất thường
ALTER TABLE saas_business_reports 
ADD INDEX idx_revenue_minmax total_revenue TYPE minmax GRANULARITY 2;

-- Giúp tăng tốc khi tìm kiếm thông tin trong chuỗi JSON chi tiết
ALTER TABLE saas_business_reports 
ADD INDEX idx_details_search details_json TYPE tokenbf_v1(256, 2, 0) GRANULARITY 1;
```

3\. Phân tích tính đáp ứng cho Dashboard

• **Tốc độ "Ánh sáng":** Nhờ cấu trúc lưu trữ dạng cột (Columnar), khi Dashboard cần vẽ biểu đồ doanh thu 12 tháng, ClickHouse chỉ đọc đúng cột `total_revenue` và `report_date`, bỏ qua các cột khác, giúp giảm IO và tăng tốc độ xử lý gấp hàng trăm lần so với cơ sở dữ liệu dòng,.

• **Chính xác tài chính:** Sử dụng `Decimal128(4)` đảm bảo các con số doanh thu tổng của hệ thống SaaS không bị sai lệch dù chỉ một đồng lẻ, đáp ứng các tiêu chuẩn khắt khe về báo cáo tài chính,.

• **Linh hoạt phân tích:** Mặc dù ClickHouse lưu JSON dưới dạng String, bạn có thể sử dụng hàm `JSONExtract` để truy vấn sâu vào cột `details_json` mà không cần thay đổi cấu trúc bảng khi có thêm các gói phần mềm mới,.

• **Sắp xếp theo thời gian:** Việc sử dụng **UUID v7** kết hợp với `report_date` trong `ORDER BY` giúp dữ liệu được lưu trữ tuần tự về mặt thời gian trên ổ đĩa, giúp các truy vấn "phạm vi ngày" (Time-range queries) đạt hiệu năng tối ưu,.

**Sự ví von:** Bảng `saas_business_reports` trên ClickHouse giống như một **trạm quan sát radar** của ông chủ hệ thống SaaS. Thay vì phải đi đếm từng tờ hóa đơn lẻ trong két sắt (YugabyteDB), ông chủ chỉ cần nhìn lên màn hình radar để biết ngay dòng tiền đang đổ về từ đâu, gói cước nào đang mang lại lợi nhuận cao nhất trong thời gian thực.



liệt kê các bảng thuộc nhóm Core Logic

Dựa trên các nguồn tài liệu về kiến trúc SaaS đa khách hàng (Multi-tenant) và mô hình **Polyglot Persistence**, nhóm **Core Logic** (Lõi nghiệp vụ nền tảng) đóng vai trò là "xương sống" cung cấp hạ tầng để mọi ứng dụng nghiệp vụ (như HRM, CRM, POS) có thể vận hành ổn định và bảo mật12.

Dưới đây là danh sách các bảng thuộc nhóm Core Logic, được phân loại theo chức năng cụ thể:

1\. Nhóm Core Logic Hệ thống (Platform Core)

Nhóm này tập trung vào việc xử lý các tác vụ nền tảng, đảm bảo tính nhất quán dữ liệu và khả năng tùy biến của hệ thống3.

• **outbox\_events**: Lưu trữ các sự kiện cần gửi sang Kafka/Message Queue. Đây là bảng quan trọng để thực hiện _Transactional Outbox Pattern_, đảm bảo tính nhất quán tuyệt đối giữa các cơ sở dữ liệu khác nhau (ví dụ: khi thêm User thì Log cũng phải được ghi)4....

• **tenant\_encryption\_keys**: Lưu trữ các khóa mã hóa dữ liệu (DEK) riêng biệt cho từng Tenant. Bảng này hỗ trợ tính năng bảo mật cao cấp như **Crypto-shredding** (xóa vĩnh viễn dữ liệu bằng cách hủy khóa)7....

• **tenant\_i18n\_overrides**: Cho phép khách hàng ghi đè các thuật ngữ mặc định của hệ thống để phù hợp với đặc thù ngành nghề (ví dụ: đổi "Nhân viên" thành "Bác sĩ" hoặc "Giáo viên")610.

• **system\_jobs**: Quản lý hàng đợi các tác vụ nền (Background Jobs) như xuất báo cáo Excel, gửi email hàng loạt hoặc tính toán lương, giúp hệ thống không bị quá tải khi xử lý request611.

2\. Nhóm Identity & Structure (Định danh & Tổ chức)

Đây là nhóm bảng quản lý thực thể "Con người" và "Tổ chức" xuyên suốt toàn sàn SaaS1213.

• **users** (trước đây là `global_identities`): Lưu trữ định danh toàn cục của một con người thực (Email, Password Hash, Avatar). Một User có thể tham gia vào nhiều Tenant khác nhau14....

• **tenants**: Lưu thông tin định danh khách hàng, cấu hình vùng dữ liệu (`data_region`), trạng thái gói cước và các ứng dụng được kích hoạt12....

• **tenant\_members**: Hồ sơ thành viên của một User tại một Tenant cụ thể. Bảng này tách biệt thông tin cá nhân và thông tin nhân sự/vận hành19....

• **user\_groups** & **group\_memberships**: Quản lý các nhóm làm việc linh hoạt (Squads, Projects) hoặc các đơn vị tổ chức (Departments) và phân bổ thành viên vào các nhóm đó22....

3\. Nhóm IAM & Security (Phân quyền & Bảo mật)

Nhóm này quy định quyền hạn và kiểm soát an ninh truy cập26.

• **roles** & **permissions**: Định nghĩa vai trò (ví dụ: Admin, Viewer) và danh mục các hành động kỹ thuật được phép thực hiện2627.

• **user\_roles**: Gán vai trò cho thành viên, hỗ trợ **Data Scoping** (giới hạn phạm vi quyền theo phòng ban hoặc khu vực)26....

• **access\_control\_lists** **(ACL)**: Phân quyền chi tiết đến từng tài nguyên cụ thể (ví dụ: User A chỉ được xem báo cáo X)3031.

• **user\_sessions**: Quản lý các phiên làm việc trực tuyến, thiết bị đăng nhập và địa chỉ IP để bảo mật và cho phép thu hồi quyền truy cập từ xa2632.

• **tenant\_sso\_configs**: Cấu hình đăng nhập một lần (SSO) qua các chuẩn SAML/OIDC để tích hợp với các hệ thống doanh nghiệp như Azure AD hay Okta33....

4\. Nhóm Core Infrastructure (Định tuyến & Vận hành)

• **tenant\_app\_routes**: Bản đồ định tuyến quy định domain/path nào sẽ trỏ vào Tenant và Ứng dụng nào. Đây là bảng có tần suất đọc cực cao và thường được cache trên Redis1....

• **feature\_flags**: Cho phép bật/tắt các tính năng mới cho từng nhóm khách hàng cụ thể mà không cần triển khai lại mã nguồn (Deploy code)638.

• **tenant\_domains**: Quản lý các tên miền đã xác thực của khách hàng để kiểm soát Shadow IT và bắt buộc đăng nhập qua SSO3940.

**Sự ví von:** Nhóm **Core Logic** giống như **hệ thống điện, nước và móng nhà** của một tòa chung cư. Dù bạn xây căn hộ theo phong cách HRM, CRM hay POS, thì tất cả đều phải sử dụng chung nền móng vững chắc này để đảm bảo an toàn, ánh sáng (bảo mật) và sự lưu thông (định tuyến) cho toàn bộ cư dân (Tenant).



thiết kế chi tiết bảng tenant\_encryption\_keys dùng ClickHouse đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên các quy chuẩn về kiến trúc **Polyglot Persistence** và bảo mật dữ liệu cấp độ Enterprise (chuẩn Banking/HIPAA) trong các nguồn tài liệu, tôi xin gửi đến bạn thiết kế chi tiết.

**Lưu ý quan trọng từ các nguồn tài liệu:** Mặc dù bạn yêu cầu sử dụng ClickHouse, nhưng các nguồn tài liệu1,2,3 nhấn mạnh rằng **tenant\_encryption\_keys** là loại **Dữ liệu Lõi/Giao dịch (Critical Data)**, liên quan mật thiết đến tính đúng đắn và an toàn của hệ thống. Vì vậy, nguồn tài liệu khuyến nghị lưu trữ bảng này tại **YugabyteDB (YSQL)** để đảm bảo tính nhất quán ACID tuyệt đối2,3. Nếu lưu tại ClickHouse, bảng này thường đóng vai trò là nơi lưu trữ **lịch sử thay đổi/truy vết khóa (Audit/History)** hơn là quản lý khóa đang hoạt động4,5.

Dưới đây là thiết kế bảng được tối ưu hóa cho **ClickHouse**:

1\. Thiết kế chi tiết bảng `tenant_encryption_keys`

Bảng này quản lý các khóa mã hóa dữ liệu (DEK), hỗ trợ tính năng **Crypto-shredding** (hủy khóa để xóa vĩnh viễn dữ liệu)3,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | Khóa chính logic | Định danh duy nhất chuẩn **UUID v7**, hỗ trợ sắp xếp theo thời gian7. |
| **tenant\_id** | UUID | NO  |     | Thành phần Sorting Key | Định danh khách hàng sở hữu khóa này8. |
| **encrypted\_data\_key** | String | NO  |     |     | Khóa DEK đã được mã hóa bởi khóa Master (KEK). Lưu dưới dạng chuỗi (Base64/Hex)6. |
| **key\_version** | UInt32 | NO  | `1` | `CHECK (key_version >= 1)` | Phiên bản của khóa để hỗ trợ xoay vòng khóa (Rotation)6. |
| **status** | Enum8 | NO  | `'ACTIVE'` | `ACTIVE=1, REVOKED=2, EXPIRED=3` | Trạng thái khóa. Nếu là **REVOKED**, dữ liệu của tenant coi như bị xóa vĩnh viễn6. |
| **algorithm** | String | NO  | `'AES-256-GCM'` |     | Thuật toán mã hóa được sử dụng. |
| **rotation\_at** | DateTime64(3) | YES |     |     | Thời điểm dự kiến cần xoay vòng khóa tiếp theo6. |
| **created\_at** | DateTime64(3) | NO  | `now()` | Độ chính xác mili-giây | Thời điểm tạo khóa (chuẩn UTC)9. |
| **updated\_at** | DateTime64(3) | NO  | `now()` |     | Thời điểm cập nhật trạng thái khóa cuối cùng. |

\--------------------------------------------------------------------------------

2\. Câu lệnh ClickHouse tạo bảng và Index

Trong ClickHouse, cấu trúc `ORDER BY` đóng vai trò là chỉ mục chính (Sparse Index) để tối ưu hóa việc truy xuất dữ liệu lớn theo thời gian và khách hàng10.

```
-- 1. CÂU LỆNH TẠO BẢNG
-- Sử dụng ReplacingMergeTree để hỗ trợ cập nhật trạng thái khóa (ví dụ: khi Revoke)
CREATE TABLE tenant_encryption_keys (
    _id UUID,
    tenant_id UUID,
    encrypted_data_key String,
    key_version UInt32,
    status Enum8('ACTIVE' = 1, 'REVOKED' = 2, 'EXPIRED' = 3),
    algorithm String DEFAULT 'AES-256-GCM',
    rotation_at DateTime64(3, 'UTC'),
    created_at DateTime64(3, 'UTC') DEFAULT now(),
    updated_at DateTime64(3, 'UTC') DEFAULT now()
)
ENGINE = ReplacingMergeTree(updated_at)
-- Phân vùng theo năm để quản lý vòng đời dữ liệu bảo mật lâu dài
PARTITION BY toYear(created_at)
-- Sắp xếp tối ưu cho việc tìm khóa theo từng Tenant và phiên bản khóa
ORDER BY (tenant_id, key_version, _id)
SETTINGS index_granularity = 8192;

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (DATA SKIPPING INDEX)

-- Index hỗ trợ tìm kiếm nhanh các khóa đã bị thu hồi (Revoked) để kiểm tra tính tuân thủ
ALTER TABLE tenant_encryption_keys 
ADD INDEX idx_revoked_keys status TYPE set(0) GRANULARITY 2;

-- Index hỗ trợ bộ phận an ninh tìm kiếm các khóa sắp hết hạn xoay vòng
ALTER TABLE tenant_encryption_keys 
ADD INDEX idx_rotation_scan rotation_at TYPE minmax GRANULARITY 4;
```

3\. Phân tích bổ sung từ các nguồn tài liệu

• **Tính bảo mật tuyệt đối:** Theo nguồn6, việc sử dụng trạng thái `REVOKED` cho khóa mã hóa là phương pháp thực hiện **Crypto-shredding**. Khi khóa bị xóa hoặc đánh dấu là hủy, toàn bộ dữ liệu của Tenant đó (dù vẫn nằm trên ổ cứng) sẽ trở thành "rác vô nghĩa", đáp ứng quyền "Được quên" của GDPR11,6.

• **UUID v7 & Hiệu năng:** Sử dụng UUID v7 giúp các bản ghi khóa mới được ghi tuần tự vào đĩa, giúp ClickHouse nén dữ liệu tốt hơn và tăng tốc độ truy vấn lịch sử khóa theo thời gian7,12.

• **Lưu trữ dạng Columnar:** Việc lưu trữ tại ClickHouse cho phép hệ thống thực hiện các báo cáo tuân thủ an ninh (Compliance Reports) trên hàng triệu bản ghi khóa (trong trường hợp hệ thống có rất nhiều Tenant) một cách nhanh chóng mà không làm chậm cơ sở dữ liệu vận hành5,13.

**Sự ví von:** Bảng `tenant_encryption_keys` tại ClickHouse giống như một **quyển nhật ký của người giữ kho**. Nó ghi lại lịch sử từng chiếc chìa khóa (DEK) được tạo ra, khi nào nó được thay mới và khi nào nó bị bẻ gãy (Revoked). Dù két sắt thật (dữ liệu) nằm ở nơi khác, quyển nhật ký này giúp đảm bảo rằng bạn luôn biết chìa khóa nào đang mở được cửa nào và đảm bảo tính minh bạch cho các cuộc kiểm tra an ninh5.



nhầm, thiết kế chi tiết bảng tenant\_encryption\_keys dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn về bảo mật cấp độ Enterprise (Banking/HIPAA) và kiến trúc **Polyglot Persistence** đã thống nhất, bảng **tenant\_encryption\_keys** là thành phần cốt lõi của "Két sắt an toàn" trong **YugabyteDB (YSQL)**1....

Việc lưu trữ bảng này tại YugabyteDB thay vì ClickHouse đảm bảo tính nhất quán ACID tuyệt đối, giúp quản lý các khóa mã hóa dữ liệu (DEK) riêng biệt cho từng khách hàng và thực thi cơ chế **Crypto-shredding** (hủy khóa để xóa vĩnh viễn dữ liệu) một cách an toàn34.

1\. Thiết kế chi tiết bảng `tenant_encryption_keys` (YSQL)

Bảng này sử dụng chuẩn **UUID v7** để tối ưu hóa việc sắp xếp theo thời gian và hiệu năng Sharding phân tán của YugabyteDB56.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định khóa thuộc về khách hàng nào4. |
| **encrypted\_data\_key** | BYTEA | NO  |     |     | Khóa DEK đã được mã hóa bởi Master Key (KEK). Lưu dạng nhị phân để bảo mật cao nhất3. |
| **key\_version** | INTEGER | NO  | `1` | `CHECK (key_version >= 1)` | Phiên bản của khóa để hỗ trợ xoay vòng khóa (Rotation)3. |
| **status** | VARCHAR(20) | NO  | `'ACTIVE'` | `CHECK (status IN ('ACTIVE', 'REVOKED', 'EXPIRED'))` | Trạng thái: Nếu là **REVOKED**, dữ liệu coi như bị xóa vĩnh viễn (Crypto-shredding)3. |
| **algorithm** | VARCHAR(50) | NO  | `'AES-256-GCM'` |     | Thuật toán mã hóa được sử dụng. |
| **rotation\_at** | TIMESTAMPTZ | YES |     |     | Thời điểm dự kiến cần xoay vòng khóa tiếp theo3. |
| **version** | BIGINT | NO  | `1` |     | **Optimistic Locking** để ngăn chặn cập nhật khóa đồng thời7. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo khóa (UTC)89. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng9. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này tận dụng khả năng lưu trữ khóa ngoại và ràng buộc chặt chẽ của YSQL để đảm bảo an toàn thông tin210.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_encryption_keys (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ phía Application
    tenant_id UUID NOT NULL,
    
    -- Dữ liệu khóa nhạy cảm
    encrypted_data_key BYTEA NOT NULL,
    key_version INTEGER NOT NULL DEFAULT 1,
    algorithm VARCHAR(50) NOT NULL DEFAULT 'AES-256-GCM',
    
    -- Trạng thái & Vòng đời
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    rotation_at TIMESTAMPTZ,
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Các ràng buộc (Constraints)
    CONSTRAINT fk_key_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_key_status CHECK (status IN ('ACTIVE', 'REVOKED', 'EXPIRED')),
    CONSTRAINT chk_key_version CHECK (key_version >= 1)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lấy khóa mới nhất (phiên bản cao nhất) của một Tenant nhanh chóng
-- Phục vụ logic: Lấy khóa để giải mã dữ liệu mỗi khi có request
CREATE INDEX idx_tenant_key_active 
ON tenant_encryption_keys (tenant_id, key_version DESC) 
WHERE status = 'ACTIVE';

-- Index hỗ trợ hệ thống bảo mật quét các khóa sắp đến hạn xoay vòng
CREATE INDEX idx_key_rotation_scan 
ON tenant_encryption_keys (rotation_at) 
WHERE rotation_at IS NOT NULL AND status = 'ACTIVE';

-- Index phục vụ Audit log: Tìm kiếm lịch sử khóa của Tenant theo thời gian
CREATE INDEX idx_key_audit_history 
ON tenant_encryption_keys (tenant_id, created_at DESC);
```

3\. Phân tích tính đáp ứng và nghiệp vụ

• **Crypto-shredding chuẩn Enterprise:** Khi khách hàng yêu cầu xóa dữ liệu (theo quyền "Được quên" của GDPR), thay vì phải tìm xóa hàng tỷ bản ghi ở ClickHouse hay S3, hệ thống chỉ cần cập nhật `status = 'REVOKED'` cho khóa này tại YugabyteDB311. Không có khóa này, toàn bộ dữ liệu mã hóa của Tenant đó sẽ trở thành rác vô nghĩa ngay lập tức3.

• **Hiệu năng giải mã:** Việc sử dụng `idx_tenant_key_active` giúp tầng Application lấy đúng khóa đang hoạt động chỉ trong micro-seconds, đảm bảo không gây trễ cho các thao tác đọc/ghi dữ liệu đã mã hóa.

• **Tính toàn vẹn (ACID):** Sử dụng `BYTEA` để lưu trữ dữ liệu nhị phân của khóa giúp tránh các lỗi encoding chuỗi và đảm bảo tính nguyên vẹn của khóa DEK12.

• **Khả năng mở rộng (Geo-sharding):** Nhờ UUID v7 và cơ chế phân tán của YugabyteDB, các khóa của khách hàng ở các vùng địa lý khác nhau (data\_region) có thể được lưu trữ gần với khách hàng đó, đáp ứng các yêu cầu khắt khe về định cư dữ liệu1314.

**Sự ví von:** Bảng `tenant_encryption_keys` giống như **chùm chìa khóa tổng** được cất trong một chiếc két sắt chống cháy (YugabyteDB). Mỗi căn hộ (Tenant) có một chìa khóa riêng biệt. Nếu bạn làm mất hoặc bẻ gãy chìa khóa (Revoke), thì dù căn hộ và đồ đạc (Dữ liệu ở ClickHouse/S3) vẫn còn đó, không ai — kể cả chủ nhà — có thể vào trong xem được nội dung nữa.



thiết kế chi tiết bảng tenant\_i18n\_overrides dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn về kiến trúc SaaS đa khách hàng (Multi-tenant) và triết lý "Dùng đúng công cụ cho đúng việc" (Polyglot Persistence) từ các nguồn tài liệu, bảng **tenant\_i18n\_overrides** được thiết kế để lưu trữ trong **YugabyteDB (YSQL)** nhằm đảm bảo tính nhất quán (ACID) và khả năng mở rộng quy mô lớn12.

Bảng này đóng vai trò quan trọng trong việc cá nhân hóa trải nghiệm, cho phép mỗi khách hàng (Tenant) "may đo" lại các thuật ngữ hệ thống (ví dụ: đổi "Nhân viên" thành "Bác sĩ" hoặc "Giảng viên") để phù hợp với đặc thù ngành nghề của họ34.

1\. Thiết kế chi tiết bảng `tenant_i18n_overrides` (YSQL)

Tuân thủ quy tắc đặt tên **snake\_case** và các tiêu chuẩn định danh bằng **UUID v7** để tối ưu hóa hiệu năng sắp xếp và Sharding trong YugabyteDB5....

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất bản ghi (UUID v7), hỗ trợ sắp xếp theo thời gian78. |
| **tenant\_id** | UUID | NO  |     | `FOREIGN KEY` tham chiếu `tenants(_id)` | Xác định bản ghi thuộc về khách hàng nào49. |
| **locale** | VARCHAR(10) | NO  | `'vi-VN'` | `CHECK (LENGTH(locale) >= 2)` | Mã ngôn ngữ/định dạng (VD: 'en-US', 'vi-VN')4. |
| **translation\_key** | VARCHAR(255) | NO  |     | `CHECK (LENGTH(translation_key) > 0)` | Khóa thuật ngữ gốc của hệ thống (VD: 'common.employee')4. |
| **custom\_value** | TEXT | NO  |     | `CHECK (LENGTH(custom_value) > 0)` | Giá trị đã được khách hàng đổi tên4. |
| **version** | BIGINT | NO  | `1` | `CHECK (version >= 1)` | Hỗ trợ **Optimistic Locking** để tránh ghi đè dữ liệu10. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo bản ghi (UTC)1112. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cuối cùng12. |
| **created\_by** | UUID | YES |     |     | ID người dùng thực hiện tạo bản ghi12. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL để tạo bảng và Index

Thiết kế này đảm bảo tính duy nhất của cặp (Khách hàng + Ngôn ngữ + Khóa thuật ngữ) để dữ liệu không bị xung đột4.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_i18n_overrides (
    -- Định danh & Liên kết
    _id UUID PRIMARY KEY, -- UUID v7 sinh từ phía Application
    tenant_id UUID NOT NULL,
    
    -- Nội dung Đa ngôn ngữ
    locale VARCHAR(10) NOT NULL DEFAULT 'vi-VN',
    translation_key VARCHAR(255) NOT NULL,
    custom_value TEXT NOT NULL,
    
    -- Quản trị & Audit
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID,

    -- Ràng buộc (Constraints)
    CONSTRAINT fk_i18n_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    -- Đảm bảo mỗi key chỉ bị ghi đè 1 lần trên mỗi ngôn ngữ của 1 tenant
    CONSTRAINT uq_tenant_locale_key UNIQUE (tenant_id, locale, translation_key),
    CONSTRAINT chk_i18n_version CHECK (version >= 1),
    CONSTRAINT chk_i18n_key_len CHECK (LENGTH(translation_key) > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ lấy toàn bộ các thuật ngữ ghi đè của một Tenant khi đăng nhập
-- Giúp Backend load nhanh dữ liệu để cache lên Redis/Session [13, 14]
CREATE INDEX idx_i18n_tenant_lookup 
ON tenant_i18n_overrides (tenant_id, locale);

-- Index hỗ trợ tra cứu lịch sử thay đổi (nếu cần audit)
CREATE INDEX idx_i18n_created_at 
ON tenant_i18n_overrides (created_at DESC);
```

3\. Phân tích bổ sung dựa trên nguồn tài liệu

• **Tính linh hoạt & Cá nhân hóa:** Bảng này hiện thực hóa yêu cầu về "Custom Terminology", giúp hệ thống SaaS trở nên chuyên nghiệp hơn trong mắt khách hàng doanh nghiệp khi họ có thể tự định nghĩa ngôn ngữ riêng34.

• **Tối ưu hiệu năng:** Việc sử dụng **UUID v7** giúp YugabyteDB phân tán dữ liệu đồng đều giữa các node (Tablet Servers) mà vẫn giữ được tính thứ tự, giúp các truy vấn báo cáo hoặc quản trị đạt hiệu suất cao713.

• **Chiến lược Caching:** Vì dữ liệu này có tần suất đọc cực cao (mỗi lần load trang/API đều cần biết tên hiển thị), các nguồn tài liệu khuyến nghị sau khi truy vấn từ YSQL, nên **cache lại trên Redis** để tránh truy cập vào DB chính cho mỗi request14....

• **Bảo vệ dữ liệu:** Ràng buộc `ON DELETE CASCADE` đảm bảo rằng khi một Tenant bị xóa, toàn bộ các cấu hình ngôn ngữ liên quan cũng sẽ được dọn dẹp sạch sẽ, giữ cho hệ thống luôn gọn gàng17.

**Sự ví von:** Bảng `tenant_i18n_overrides` giống như một **bộ nhãn dán tùy chỉnh** cho một cuốn từ điển. Hệ thống cung cấp cuốn từ điển mặc định, nhưng mỗi chủ căn hộ (Tenant) có thể dán đè lên những từ ngữ họ muốn để các thành viên trong nhà (Users) cảm thấy thân thuộc và phù hợp với thói quen sinh hoạt của mình nhất4.



thiết kế chi tiết bảng system\_jobs dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên triết lý **Polyglot Persistence** và các quy chuẩn thiết kế hệ thống SaaS phân tán, bảng **system\_jobs** được lưu trữ tại **YugabyteDB (YSQL)** để đảm bảo tính bền vững (Durability) và nhất quán (ACID)1,2. Việc sử dụng YSQL thay vì Redis cho hàng đợi công việc giúp hệ thống không bị mất dữ liệu khi xảy ra sự cố và hỗ trợ các truy vấn phức tạp để quản lý trạng thái công việc2.

Dưới đây là thiết kế chi tiết đáp ứng yêu cầu phân tích các tác vụ nền như xuất báo cáo, tính lương, hoặc gửi email hàng loạt2,3.

1\. Thiết kế chi tiết bảng `system_jobs` (YSQL)

Bảng này đóng vai trò là một **Persistent Job Queue** (Hàng đợi công việc bền vững), sử dụng **UUID v7** để tối ưu hóa hiệu năng chèn dữ liệu theo thời gian thực4,2.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất chuẩn **UUID v7**4,3. |
| **tenant\_id** | UUID | YES | NULL | FK tham chiếu `tenants(_id)` | Xác định công việc thuộc về khách hàng nào để tính phí hoặc giới hạn3. |
| **job\_type** | VARCHAR(50) | NO  |     | `CHECK (length > 0)` | Loại công việc (VD: `EXPORT_EXCEL`, `CALCULATE_PAYROLL`)3. |
| **payload** | **JSONB** | NO  | `'{}'` |     | Chứa toàn bộ tham số đầu vào của công việc3. |
| **status** | VARCHAR(20) | NO  | `'PENDING'` | `CHECK IN ('PENDING', 'PROCESSING', 'COMPLETED', 'FAILED', 'CANCELLED')` | Trạng thái vòng đời của công việc3. |
| **scheduled\_at** | TIMESTAMPTZ | NO  | `now()` | Lưu chuẩn UTC5 | Thời điểm dự kiến thực hiện (hỗ trợ hẹn giờ chạy sau)3. |
| **started\_at** | TIMESTAMPTZ | YES | NULL |     | Thời điểm bắt đầu thực thi thực tế6. |
| **finished\_at** | TIMESTAMPTZ | YES | NULL |     | Thời điểm hoàn thành hoặc thất bại6. |
| **retry\_count** | INT | NO  | `0` | `CHECK (retry_count >= 0)` | Số lần đã thử lại khi gặp lỗi6. |
| **max\_retries** | INT | NO  | `3` | `CHECK (max_retries >= 0)` | Số lần thử lại tối đa cho phép6. |
| **last\_error** | TEXT | YES | NULL |     | Lưu vết nội dung lỗi cuối cùng để debug6. |
| **created\_by** | UUID | YES | NULL | FK tham chiếu `users(_id)` | ID người dùng đã kích hoạt tác vụ này6. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** tránh xử lý trùng7. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này tập trung vào việc tối ưu hóa cho các Worker quét tìm công việc mới (Pending) và quản lý tiến độ.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE system_jobs (
    -- Định danh & Phân loại
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ phía Application
    tenant_id UUID,
    job_type VARCHAR(50) NOT NULL,
    
    -- Dữ liệu & Trạng thái
    payload JSONB NOT NULL DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    
    -- Thời gian (Sử dụng TIMESTAMPTZ theo chuẩn UTC)
    scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    finished_at TIMESTAMPTZ,
    
    -- Quản lý lỗi & Thử lại
    retry_count INT NOT NULL DEFAULT 0,
    max_retries INT NOT NULL DEFAULT 3,
    last_error TEXT,
    
    -- Quản trị
    created_by UUID,
    version BIGINT NOT NULL DEFAULT 1,

    -- Các ràng buộc dữ liệu
    CONSTRAINT fk_job_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    CONSTRAINT chk_job_status CHECK (status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'FAILED', 'CANCELLED')),
    CONSTRAINT chk_retry_logic CHECK (retry_count <= max_retries)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (Tối ưu cho Worker)

-- Index quan trọng nhất: Giúp Worker tìm nhanh các job đang chờ để xử lý
-- Sử dụng Partial Index để giữ index nhỏ gọn và nhanh
CREATE INDEX idx_jobs_fetch 
ON system_jobs (scheduled_at ASC) 
WHERE status = 'PENDING';

-- Index hỗ trợ Tenant theo dõi tiến độ các công việc của họ trên UI
CREATE INDEX idx_jobs_tenant_monitor 
ON system_jobs (tenant_id, status, scheduled_at DESC);

-- Index hỗ trợ tìm kiếm các công việc bị lỗi để hệ thống tự động xử lý/báo cáo
CREATE INDEX idx_jobs_failed_analysis 
ON system_jobs (job_type) 
WHERE status = 'FAILED';
```

3\. Phân tích lợi ích kỹ thuật

• **Chống mất dữ liệu:** Khác với các hàng đợi lưu trên RAM như Redis, việc lưu tại YugabyteDB đảm bảo nếu hệ thống sập nguồn, các công việc đang chờ (như tính lương hàng ngàn nhân viên) vẫn sẽ tiếp tục được thực hiện khi hệ thống khởi động lại2.

• **Xử lý bất đồng bộ (Async):** Giúp trải nghiệm người dùng mượt mà hơn; thay vì chờ 5 phút để xuất file Excel, người dùng có thể tắt trình duyệt và nhận thông báo khi file đã sẵn sàng trong bảng `finished_at`6.

• **Optimistic Locking:** Cột `version` giúp ngăn chặn tình trạng hai Worker cùng lấy một công việc và thực hiện song song, tránh lãng phí tài nguyên hoặc sai lệch dữ liệu7.

• **UUID v7:** Giúp các bản ghi mới được chèn vào các "vùng" (Tablets) gần nhau theo thời gian, tăng tốc độ quét index cho các Worker tìm công việc mới nhất4.

**Sự ví von:** Bảng `system_jobs` giống như một **hàng đợi tại quầy dịch vụ khách hàng**. Thay vì bắt khách hàng đứng chờ trực tiếp (Request-Response truyền thống), nhân viên sẽ phát cho khách một **số thứ tự (Job ID)** và hẹn: "Anh cứ đi uống cà phê, khi nào xong chúng tôi sẽ báo". Quy trình này giúp quầy dịch vụ không bao giờ bị tắc nghẽn và mọi yêu cầu đều được ghi chép vào sổ cái chắc chắn.



thiết kế chi tiết bảng feature\_flags dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên các quy chuẩn về kiến trúc **Polyglot Persistence** và các thảo luận về việc tối ưu hóa vận hành hệ thống SaaS, bảng **feature\_flags** được lưu trữ tại **YugabyteDB (YSQL)** để đảm bảo tính nhất quán (ACID) khi cập nhật các cấu hình quan trọng1,2.

Việc sử dụng **Feature Flags** giúp tách biệt hoàn toàn giữa việc triển khai kỹ thuật (Deployment) và phát hành tính năng (Release), cho phép bật/tắt tính năng cho từng nhóm khách hàng cụ thể (như 10% người dùng thử nghiệm Beta) mà không cần can thiệp vào mã nguồn3,4,5.

1\. Thiết kế chi tiết bảng `feature_flags` (YSQL)

Bảng này tuân thủ quy tắc sử dụng **UUID v7** làm định danh chính để tối ưu hóa hiệu năng chèn dữ liệu và Sharding trong môi trường phân tán6,7.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả & Ý nghĩa Nghiệp vụ |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất bản ghi theo chuẩn **UUID v7**8,6. |
| **flag\_key** | VARCHAR(50) | NO  |     | `UNIQUE`, `CHECK (length > 0)` | Mã kỹ thuật của tính năng (VD: `ENABLE_AI_WRITING`, `BETA_UI`)2,5. |
| **description** | TEXT | YES | NULL |     | Mô tả chi tiết mục đích của cờ tính năng này2. |
| **is\_global\_enabled** | BOOLEAN | NO  | `FALSE` |     | Nếu là `TRUE`, tính năng được bật cho toàn bộ hệ thống bất kể các quy tắc khác4,5. |
| **rules** | **JSONB** | NO  | `'{}'` |     | Chứa logic bật tắt như: tỷ lệ phần trăm (`percentage`), danh sách tenant được phép (`allowed_tenants`), hoặc vùng bị loại trừ (`excluded_regions`)2,5. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** để ngăn chặn việc ghi đè cấu hình khi nhiều admin cùng chỉnh sửa9. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm tạo cờ (theo chuẩn UTC)10,11. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` |     | Thời điểm cập nhật cấu hình cuối cùng11. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này sử dụng **GIN Index** để hỗ trợ truy vấn sâu vào các quy tắc phức tạp lưu trong trường JSONB và **Partial Index** để tối ưu hóa hiệu năng12,13.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE feature_flags (
    -- Định danh & Khóa kỹ thuật
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ phía Application
    flag_key VARCHAR(50) NOT NULL,
    description TEXT,
    
    -- Trạng thái & Quy tắc
    is_global_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    rules JSONB NOT NULL DEFAULT '{}',
    
    -- Quản trị hệ thống
    version BIGINT NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ràng buộc dữ liệu
    CONSTRAINT uq_flag_key UNIQUE (flag_key),
    CONSTRAINT chk_flag_key_format CHECK (flag_key ~ '^[A-Z0-9_]+$') -- Chỉ cho phép chữ hoa, số và gạch dưới
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh theo mã tính năng
CREATE INDEX idx_flags_lookup ON feature_flags (flag_key);

-- Index GIN để truy vấn các điều kiện bên trong JSONB rules
-- Ví dụ: Tìm các cờ đang áp dụng cho một tenant_id cụ thể
CREATE INDEX idx_flags_rules_search ON feature_flags USING GIN (rules);

-- Index hỗ trợ lọc các tính năng đang hoạt động (Partial Index)
CREATE INDEX idx_flags_active_global ON feature_flags (flag_key) 
WHERE is_global_enabled = TRUE;
```

3\. Phân tích lợi ích kỹ thuật và vận hành

• **Tách biệt Thương mại và Kỹ thuật:** Khác với bảng `service_packages` quy định quyền lợi theo gói mua, `feature_flags` cho phép kỹ sư kiểm soát việc phát hành code một cách an toàn2.

• **Chiến lược "Database làm Kho - Redis làm Súng":** Mặc dù dữ liệu gốc nằm ở YugabyteDB để đảm bảo an toàn, nhưng cấu hình này nên được **cache lên Redis** để đạt tốc độ truy vấn micro-seconds mỗi khi ứng dụng kiểm tra quyền thực thi tính năng14,15,4.

• **Phân phối dần dần (Canary Release):** Thông qua trường `rules`, bạn có thể cấu hình cho phép một tính năng mới chỉ xuất hiện với một nhóm khách hàng tại vùng `data_region = 'VN_NORTH'` trước khi mở rộng ra toàn cầu2,16.

• **An toàn hệ thống:** Khi một tính năng mới gây lỗi nghiêm trọng (Critical Bug), Admin có thể ngay lập tức chuyển `is_global_enabled` về `FALSE` để "tắt nóng" tính năng đó trên toàn sàn mà không cần thực hiện quy trình Rollback code phức tạp17,5.

**Sự ví von:** Bảng `feature_flags` giống như một **hệ thống bảng điều khiển điện trung tâm** của tòa nhà. Trong khi các gói cước (`packages`) quyết định khách hàng đã trả tiền cho thiết bị nào, thì bảng điều khiển này cho phép người quản lý tòa nhà chủ động bật/tắt điện ở từng khu vực hoặc từng phòng cụ thể để bảo trì hoặc thử nghiệm mà không cần phải xây dựng lại toàn bộ hệ thống dây điện.



liệt kê các bảng thuộc nhóm Routing & Ops

Dựa trên các nguồn tài liệu về kiến trúc SaaS đa khách hàng, nhóm **Routing & Ops** (Định tuyến và Vận hành) đóng vai trò điều phối lưu lượng truy cập (traffic), bảo vệ hệ thống và quản lý việc phát hành tính năng1. Nhóm này giúp đảm bảo hệ thống vận hành ổn định, tránh vấn đề "hàng xóm ồn ào" (Noisy Neighbor) và cho phép triển khai kỹ thuật tách biệt với phát hành thương mại23.

Dưới đây là danh sách các bảng chi tiết thuộc nhóm này:

1\. `tenant_app_routes` (Bản đồ định tuyến)

Đây là bảng quan trọng nhất của lớp định tuyến, đóng vai trò xác định một request cụ thể sẽ được gửi đến Tenant nào và Ứng dụng nào45.

• **Chức năng:** Quản lý việc định tuyến dựa trên **Domain** (tên miền) và **Path** (đường dẫn). Ví dụ: `hrm.fpt.com` trỏ vào App HRM, trong khi `fpt.saas.com/crm` trỏ vào App CRM67.

• **Lưu trữ:** Dữ liệu gốc nằm tại **YugabyteDB** để đảm bảo tính nhất quán và ràng buộc duy nhất (Unique), nhưng được **cache lên Redis** để đạt tốc độ phản hồi micro-seconds48.

• **Ràng buộc chính:** Một cặp Domain + Path phải là duy nhất trên toàn hệ thống để tránh xung đột định tuyến giữa các khách hàng910.

2\. `feature_flags` (Cờ tính năng)

Bảng này quản lý việc bật hoặc tắt các tính năng cho từng nhóm đối tượng khách hàng cụ thể1112.

• **Chức năng:** Cho phép **tách biệt hoàn toàn** giữa triển khai mã nguồn (Deployment) và phát hành tính năng (Release)213. Admin có thể bật tính năng mới cho 10% khách hàng dùng thử (Beta) hoặc "tắt nóng" một tính năng nếu phát hiện lỗi nghiêm trọng mà không cần rollback code1314.

• **Cấu trúc quy tắc (Rules):** Thường lưu dưới dạng **JSONB** để chứa các logic phức tạp như tỷ lệ phần trăm người dùng, danh sách Tenant được phép hoặc vùng địa lý bị loại trừ214.

3\. `tenant_rate_limits` (Giới hạn tần suất)

Bảng này được thiết kế để bảo vệ hệ thống khỏi việc bị quá tải do một khách hàng sử dụng tài nguyên quá mức315.

• **Chức năng:** Thiết lập hạn ngạch gọi API cho từng Tenant hoặc theo gói cước dịch vụ (ví dụ: 1000 requests/phút). Điều này ngăn chặn script lỗi hoặc các cuộc tấn công DDoS nội bộ làm ảnh hưởng đến các khách hàng khác trên cùng hệ thống315.

• **Vận hành:** Tương tự như bảng định tuyến, cấu hình từ bảng này thường được đồng bộ sang **Redis** để các API Gateway (như Kong hoặc Nginx) kiểm tra ngay lập tức khi có request bay vào15.

4\. `system_announcements` (Thông báo hệ thống)

Mặc dù đôi khi được xếp vào nhóm trải nghiệm, bảng này thường thuộc về Ops khi dùng để thông báo các vấn đề vận hành16.

• **Chức năng:** Quản lý các thông báo bảo trì hoặc cảnh báo toàn sàn. Thay vì gửi hàng triệu email, hệ thống sử dụng cơ chế "Pull-based", nơi người dùng sẽ nhận thông báo khi họ load trang dựa trên vùng địa lý hoặc gói cước đang sử dụng1617.

**Tóm lại:** Nhóm bảng này giống như một **trạm điều phối giao thông** và **hệ thống an ninh** cho tòa nhà SaaS. Trong đó, `tenant_app_routes` là biển chỉ dẫn đường đi, `tenant_rate_limits` là cửa kiểm soát lưu lượng để tránh tắc nghẽn, và `feature_flags` là hệ thống công tắc điều khiển từng thiết bị điện trong tòa nhà mà không cần phải can thiệp vào mạng lưới dây dẫn chính14....



thiết kế chi tiết bảng tenant\_rate\_limits dùng YSQL đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh ysql để tạo bảng và index

Dựa trên triết lý **"Polyglot Persistence"** và các quy chuẩn thiết kế hệ thống SaaS đa khách hàng (Multi-tenant) từ các nguồn tài liệu, bảng **tenant\_rate\_limits** được lưu trữ tại **YugabyteDB (YSQL)** đóng vai trò là "Nguồn sự thật" (Source of Truth) cho các chính sách giới hạn băng thông và tần suất gọi API12.

Việc sử dụng YugabyteDB đảm bảo tính nhất quán dữ liệu khi Admin cập nhật hạn ngạch, sau đó các giá trị này sẽ được đồng bộ sang **Redis** để lớp API Gateway tra cứu với tốc độ micro- giây nhằm bảo vệ hệ thống khỏi vấn đề "hàng xóm ồn ào" (Noisy Neighbor)2....

1\. Thiết kế chi tiết bảng `tenant_rate_limits` (YSQL)

Bảng này sử dụng định danh **UUID v7** để tối ưu hóa hiệu năng sắp xếp và chèn dữ liệu trong môi trường phân tán của YugabyteDB56.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | UUID | NO  |     | `PRIMARY KEY` | Định danh duy nhất theo chuẩn **UUID v7**57. |
| **tenant\_id** | UUID | YES | NULL | `FK` tham chiếu `tenants(_id)` | Nếu NULL, đây là cấu hình mặc định toàn sàn (Global Default)2. |
| **api\_group** | VARCHAR(50) | NO  |     | `CHECK (length > 0)` | Nhóm API bị giới hạn (VD: 'REPORTING\_API', 'CORE\_API')2. |
| **limit\_count** | INT | NO  |     | `CHECK (limit_count > 0)` | Số lượng request tối đa được phép2. |
| **window\_seconds** | INT | NO  | `60` | `CHECK (window_seconds > 0)` | Khung thời gian áp dụng giới hạn (tính bằng giây)2. |
| **is\_active** | BOOLEAN | NO  | `TRUE` |     | Trạng thái kích hoạt của quy tắc8. |
| **description** | TEXT | YES | NULL |     | Ghi chú về mục đích của giới hạn này. |
| **created\_at** | TIMESTAMPTZ | NO  | `now()` | Chuẩn UTC9 | Thời điểm tạo bản ghi610. |
| **updated\_at** | TIMESTAMPTZ | NO  | `now()` | Chuẩn UTC9 | Thời điểm cập nhật cuối cùng10. |
| **version** | BIGINT | NO  | `1` |     | Hỗ trợ **Optimistic Locking** khi cập nhật cấu hình11. |

\--------------------------------------------------------------------------------

2\. Câu lệnh YSQL tạo bảng và Index

Thiết kế này đảm bảo tính duy nhất của cấu hình để tránh xung đột logic định tuyến và giới hạn12.

```
-- 1. CÂU LỆNH TẠO BẢNG
CREATE TABLE tenant_rate_limits (
    -- Định danh & Phân loại
    _id UUID PRIMARY KEY, -- Sinh UUID v7 từ Application
    tenant_id UUID NULL,
    api_group VARCHAR(50) NOT NULL,
    
    -- Tham số giới hạn
    limit_count INT NOT NULL,
    window_seconds INT NOT NULL DEFAULT 60,
    
    -- Trạng thái & Vận hành
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    description TEXT,
    
    -- Audit & Concurrency
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version BIGINT NOT NULL DEFAULT 1,

    -- Ràng buộc (Constraints)
    CONSTRAINT fk_rate_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(_id) ON DELETE CASCADE,
    -- Mỗi Tenant chỉ có 1 rule cho 1 nhóm API cụ thể [12]
    CONSTRAINT uq_tenant_api_group UNIQUE (tenant_id, api_group),
    CONSTRAINT chk_limit_positive CHECK (limit_count > 0),
    CONSTRAINT chk_window_positive CHECK (window_seconds > 0)
);

-- 2. CHIẾN LƯỢC ĐÁNH INDEX (INDEXING STRATEGY)

-- Index hỗ trợ tìm kiếm nhanh các giới hạn theo Tenant [6, 13]
CREATE INDEX idx_rate_limit_tenant ON tenant_rate_limits (tenant_id) 
WHERE is_active = TRUE;

-- Index hỗ trợ Worker đồng bộ dữ liệu sang Redis
-- Tìm các bản ghi mới cập nhật để update cache
CREATE INDEX idx_rate_limit_sync ON tenant_rate_limits (updated_at DESC);
```

3\. Phân tích tính đáp ứng và lợi ích

• **Bảo vệ hệ thống (Anti-DDoS nội bộ):** Việc thiết lập `limit_count` và `window_seconds` giúp chặn các script lỗi hoặc các cuộc tấn công từ bên trong một Tenant trước khi chúng làm nghẽn tài nguyên chung của toàn sàn213.

• **Tối ưu hiệu năng:** Mặc dù bảng lưu ở YugabyteDB để đảm bảo an toàn, nhưng nhờ cấu trúc `UNIQUE (tenant_id, api_group)`, hệ thống đồng bộ có thể dễ dàng map dữ liệu sang **Redis Hash Map** theo dạng `rate_limit:{tenant_id}:{api_group}`, giúp API Gateway kiểm tra quyền truy cập trong thời gian thực với độ trễ dưới 1ms414.

• **Linh hoạt theo gói cước:** Bạn có thể kết hợp dữ liệu từ bảng này với bảng `service_packages` để tự động gán hạn ngạch cao hơn cho các khách hàng trả phí nhiều tiền hơn215.

• **Tính toàn vẹn (ACID):** Sử dụng YugabyteDB giúp đảm bảo rằng khi Admin thay đổi giới hạn (ví dụ: giảm từ 1000 xuống 100 req/min do nợ cước), thay đổi này sẽ được thực hiện một cách an toàn và không bị mất mát dữ liệu1617.

**Sự ví von:** Bảng `tenant_rate_limits` giống như một **hệ thống van điều tiết nước** trong tòa nhà SaaS. YugabyteDB là **trung tâm điều khiển** nơi các kỹ sư thiết lập lưu lượng cho từng căn hộ, còn Redis là các **vòi phun thực tế** phản ứng ngay lập tức để đảm bảo không một căn hộ nào dùng quá mức làm yếu đi dòng nước của những người hàng xóm khác1318.



liệt kê các bảng thuộc nhóm DYNAMIC CONFIGURATION

Dựa trên các nguồn tài liệu về kiến trúc hệ thống SaaS quy mô lớn, nhóm **DYNAMIC CONFIGURATION (Cấu hình động)** là một phần quan trọng của tầng dữ liệu vận hành, chịu trách nhiệm lưu trữ các thiết lập linh hoạt và không có cấu trúc cố định1,2.

Dưới đây là danh sách chi tiết các bảng thuộc nhóm này, cùng với vai trò và lý do kỹ thuật đằng sau việc lựa chọn công nghệ lưu trữ:

1\. Bảng `tenant_app_configs` (Cấu hình ứng dụng của Tenant)

Đây là bảng cốt lõi trong nhóm cấu hình động, đóng vai trò là "bộ não linh hoạt" của hệ thống3.

• **Cơ sở dữ liệu lưu trữ:** **MongoDB** (Dạng Document Store)4,2.

• **Mục đích:** Lưu trữ các cài đặt liên quan đến sở thích vận hành của từng khách hàng ("Làm như thế nào?") thay vì quy định quyền lợi ("Được làm gì?")5.

• **Nội dung cụ thể:** Bao gồm các thiết lập như màu sắc giao diện (theme\_color), logo riêng, các bước trong quy trình làm việc (workflow\_steps), hoặc các cài đặt đặc thù của từng ứng dụng (HRM, CRM)5,2.

• **Lý do chọn MongoDB:** Mỗi khách hàng (Tenant) có thể có nhu cầu cấu hình khác nhau với các trường dữ liệu lồng nhau phức tạp3,6. MongoDB cho phép lưu trữ dưới dạng JSON tùy ý mà không cần thực hiện lệnh `ALTER TABLE` gây khóa bảng như trong các cơ sở dữ liệu SQL truyền thống7.

2\. Bảng `custom_fields` (Định nghĩa trường dữ liệu mở rộng)

Bảng này cho phép hệ thống SaaS đáp ứng nhu cầu cá nhân hóa dữ liệu của khách hàng doanh nghiệp2.

• **Cơ sở dữ liệu lưu trữ:** **MongoDB**8,9.

• **Mục đích:** Lưu trữ định nghĩa của các trường dữ liệu mà khách hàng tự thêm vào các biểu mẫu có sẵn của hệ thống2.

• **Ví dụ:** Tenant A muốn thêm trường "Nhóm máu" vào biểu mẫu hồ sơ nhân viên, trong khi Tenant B muốn thêm trường "Số CMND"7,2.

• **Lý do kỹ thuật:** Việc lưu trữ metadata của các trường động này dưới dạng Document giúp dễ dàng ánh xạ (mapping) và hiển thị lên giao diện người dùng mà không bị gò bó bởi cấu trúc bảng cứng nhắc9.

3\. Bảng `workflow_definitions` (Định nghĩa quy trình)

• **Cơ sở dữ liệu lưu trữ:** **MongoDB**3.

• **Mục đích:** Lưu trữ các quy trình duyệt động giữa các người dùng (ví dụ: User A duyệt rồi đến User B, sau đó đến User C)3.

• **Đặc điểm:** Các quy trình này thường thay đổi thường xuyên và phụ thuộc hoàn toàn vào ngữ cảnh vận hành của từng khách hàng3,10.

4\. Bảng `product_catalog` hoặc `catalog` (Danh mục sản phẩm động)

• **Cơ sở dữ liệu lưu trữ:** **MongoDB**4,3.

• **Mục đích:** Lưu trữ danh mục sản phẩm của từng khách hàng4.

• **Đặc điểm:** Vì mỗi Tenant có thể kinh doanh các loại mặt hàng khác nhau với các thuộc tính sản phẩm hoàn toàn khác nhau, việc sử dụng cơ sở dữ liệu không cấu trúc giúp quản lý các thuộc tính này một cách tự nhiên3.

5\. Bảng `form_submissions` (Dữ liệu biểu mẫu động)

• **Cơ sở dữ liệu lưu trữ:** **MongoDB**7.

• **Mục đích:** Lưu trữ các dữ liệu thực tế mà người dùng nhập vào từ các biểu mẫu (form) đã được tùy chỉnh bằng các trường động7.

\--------------------------------------------------------------------------------

Tóm tắt đặc tính nhóm DYNAMIC CONFIGURATION

Các bảng trong nhóm này được tách biệt hoàn toàn với nhóm dữ liệu giao dịch (YugabyteDB) hoặc phân tích (ClickHouse) vì những lý do sau:

• **Tính linh hoạt (Schema Flexibility):** Đáp ứng yêu cầu mỗi khách hàng có một bộ trường dữ liệu riêng biệt7,6.

• **Mô hình tài liệu (Document Model):** Dữ liệu cấu hình thường được lấy ra trọn gói (Get whole object) để sử dụng ngay trên giao diện, giúp giảm thiểu việc phải JOIN nhiều bảng phức tạp7.

• **Phân tách mối quan tâm:** Việc thay đổi cấu hình động của Tenant A không bao giờ ảnh hưởng đến hiệu năng hay cấu trúc dữ liệu của Tenant B3.

**Ví von:** Nếu các bảng giao dịch (như `subscriptions`) là **khung xương thép** cố định của tòa nhà SaaS để đảm bảo an toàn, thì nhóm **Dynamic Configuration** giống như **hệ thống nội thất di động**. Mỗi cư dân (Tenant) có thể tự do sắp xếp, thêm bớt bàn ghế hoặc sơn lại màu tường theo sở thích riêng mà không cần phải đục phá hay xây dựng lại kết cấu chính của tòa nhà3,7.



các bảng này có hơi đi lạc sang phần các phần mềm saas chi tiết không? đang thiết kế phần lõi saas thôi mà

Nhận xét của bạn rất chính xác và phản ánh đúng tư duy thiết kế hệ thống chuyên nghiệp. Trong quá trình xây dựng, ranh giới giữa **SaaS Core (Phần lõi)** và **Business Logic (Nghiệp vụ chi tiết)** đôi khi bị mờ nhạt nếu chúng ta không áp dụng triệt để nguyên tắc "Phân tách mối quan tâm" (Separation of Concerns)12.

Dưới đây là phân tích chi tiết để giúp bạn "kéo" thiết kế về đúng phần lõi, loại bỏ các thành phần đã bị "đi lạc" sang phần mềm nghiệp vụ (như HRM, CRM, POS):

1\. Phân định ranh giới: Core vs. App

Theo các nguồn tài liệu, một hệ thống SaaS chuẩn cần phân biệt rõ hai thế giới3:

• **SaaS Core (Nền tảng):** Chỉ cung cấp hạ tầng để mọi ứng dụng đều chạy được. Nhiệm vụ của nó là quản lý: Ai là khách hàng (Tenant), ai là người dùng (User), họ mua gói gì (Subscription), và họ đi vào bằng đường nào (Routing)14.

• **Business Apps (HRM, CRM, POS...):** Đây mới là nơi chứa các logic chi tiết như "Chấm công", "Hợp đồng", "Bán hàng", hay "Tồn kho"35.

2\. Những bảng nào thực sự đã "đi lạc"?

Dựa trên phân tích về sự xung đột giữa nền tảng và nghiệp vụ, các bảng sau đây nên được tách ra khỏi phần lõi và đưa vào lớp ứng dụng (Business Layer)67:

• **product\_catalog** **/** **catalog****:** Đây là danh mục hàng hóa của Tenant (như quần áo, đồ ăn). SaaS Core chỉ nên quản lý `service_packages` (các gói cước phần mềm mà bạn bán cho khách)78.

• **form\_submissions****:** Đây là dữ liệu người dùng nhập vào các biểu mẫu nghiệp vụ. Core không nên quan tâm đến nội dung này9.

• **workflow\_definitions** **(chi tiết):** Nếu là quy trình duyệt nghỉ phép hay duyệt chi, nó thuộc về HRM/Accounting. Core chỉ nên cung cấp một bảng `approvals` chung cho các yêu cầu hệ thống110.

• **departments****:** Tên gọi này quá đậm chất HRM. Trong phần lõi, chúng ta nên dùng tên gọi mang tính hạ tầng hơn như **user\_groups** hoặc **member\_groups** để đại diện cho một nhóm người dùng bất kỳ (có thể là phòng ban, cũng có thể là một team dự án)1112.

3\. Thiết kế "Lõi tinh gọn" (Refined SaaS Core)

Để đảm bảo phần lõi "cường tráng" và không bị vỡ cấu trúc khi mở rộng, danh sách bảng Core Identity & Structure cần được tinh chỉnh lại như sau413:

• **Nhóm Identity (Định danh):**

    ◦ **users****:** Con người thực (Email, Password)1415.    ◦ **tenant\_members****:** Chỉ lưu trạng thái: User này có thuộc Tenant này không và đang `ACTIVE` hay `SUSPENDED`1113.

• **Nhóm Structure (Cấu trúc):**

    ◦ **user\_groups** **(hoặc** **groups****):** Cấu trúc nhóm đa năng để App HRM dùng làm "Phòng ban", App CRM dùng làm "Team Sale"1216.    ◦ **group\_memberships****:** Liên kết người dùng vào các nhóm trên1718.

• **Nhóm Infrastructure (Hạ tầng vận hành):**

    ◦ **tenants****:** Trái tim hệ thống, lưu thông tin khách hàng và vùng dữ liệu (`data_region`)1920.    ◦ **tenant\_app\_routes****:** Bản đồ định tuyến để biết Domain/Path nào trỏ vào App nào1921.    ◦ **tenant\_app\_configs****:** Đây là bảng "động" duy nhất ở lõi, nhưng nó chỉ chứa các cấu hình vận hành (như màu sắc, logo, ngôn ngữ) thay vì dữ liệu nghiệp vụ2223.    ◦ **outbox\_events****:** Đảm bảo nhất quán dữ liệu khi đồng bộ giữa các dịch vụ2425.

4\. Cách các App nghiệp vụ sử dụng Core

Thiết kế chuẩn là các App sẽ "ký gửi" hoặc "tham chiếu" vào Core2:

• **App HRM:** Sẽ tự tạo bảng `hrm_profiles` liên kết 1-1 với `tenant_members` để lưu lương và ngày thử việc2.

• **App CRM:** Sẽ tự tạo bảng `crm_leads` và dùng `user_id` từ Core để biết ai đang chăm sóc khách hàng đó26.

• **Core:** Cung cấp bảng **access\_control\_lists** **(ACL)**. Bất kỳ App nào (HRM hay CRM) muốn tính năng "Chia sẻ" hoặc "Phân quyền đến từng thư mục" đều sẽ gọi vào bảng này của Core2728.

**Sự ví von:** Thiết kế **SaaS Core** giống như việc bạn xây dựng **khung nhà, hệ thống điện và ống nước** của một tòa chung cư. Các bảng nghiệp vụ (HRM, CRM) giống như **nội thất và cách bài trí** của từng căn hộ. Người thợ xây (Core Developer) không nên quyết định khách hàng sẽ đặt bàn ăn ở đâu hay dùng loại rèm cửa nào, nhưng phải đảm bảo ở bất kỳ vị trí nào khách muốn, họ đều có thể kết nối vào hệ thống điện và nước của tòa nhà117.



bảng tenant\_app\_configs nên lưu bằng CSDL nào?

Dựa trên thông tin từ các nguồn tài liệu về kiến trúc hệ thống SaaS đa khách hàng (Multi-tenant), bảng **tenant\_app\_configs** nên được lưu trữ bằng cơ sở dữ liệu **MongoDB** (thuộc nhóm Document Store)1,2,3.

Dưới đây là các phân tích chi tiết lý giải tại sao MongoDB là lựa chọn tối ưu cho loại dữ liệu này:

1\. Phân loại theo triết lý "Polyglot Persistence"

Trong kiến trúc đa lưu trữ bền vững (Polyglot Persistence), hệ thống được chia thành nhiều tầng dữ liệu khác nhau dựa trên đặc tính truy cập và nghiệp vụ1,4. Bảng `tenant_app_configs` được xếp vào **Tier 1: Document Store (MongoDB)**, đóng vai trò là "Bộ não linh hoạt" của hệ thống2. Đây là nơi lưu trữ các dữ liệu mang tính chất cấu trúc lồng nhau, thay đổi thường xuyên và phụ thuộc hoàn toàn vào ngữ cảnh của từng khách hàng (Tenant)2,5.

2\. Lý do kỹ thuật nên chọn MongoDB

Các nguồn tài liệu đưa ra ba lý do chính cho lựa chọn này:

• **Tính linh hoạt của Schema (Schema Flexibility):** Mỗi khách hàng có nhu cầu cấu hình khác nhau; ví dụ Tenant A muốn thêm trường "Mã số thuế" vào cấu hình, trong khi Tenant B thì không2,5. MongoDB cho phép xử lý các thay đổi này một cách tự nhiên mà không cần thực hiện lệnh `ALTER TABLE` – vốn thường gây khóa bảng (lock) trong các cơ sở dữ liệu SQL truyền thống2,5.

• **Mô hình tài liệu (Document Model):** Dữ liệu cấu hình thường được ứng dụng lấy ra trọn gói (Get whole object) dưới dạng JSON để sử dụng ngay trên giao diện2,5. Việc lưu trữ dạng Document giúp giảm thiểu các truy vấn `JOIN` nhiều bảng phức tạp, từ đó tối ưu hiệu năng truy xuất2,5.

• **Định danh thống nhất:** Mặc dù lưu ở MongoDB, các nguồn tài liệu quy định thống nhất đặt tên trường khóa chính là **\_id** và sử dụng kiểu chuỗi (UUID) để dễ dàng đồng bộ và ánh xạ dữ liệu với các cơ sở dữ liệu khác như YugabyteDB hay ClickHouse6,7.

3\. Vai trò nghiệp vụ của bảng `tenant_app_configs`

Bảng này được thiết kế để lưu trữ các **Cấu hình (Configs)**, dùng để quy định sở thích vận hành của khách hàng ("Làm như thế nào?")8. Điều này giúp phân biệt rõ với các **Tính năng (Features)** quy định quyền lợi ("Được làm gì?") thường được lưu trong SQL8. Các ví dụ điển hình lưu trong bảng này bao gồm:

• Màu sắc giao diện (theme\_color), Logo riêng của doanh nghiệp8,3.

• Các bước trong quy trình phê duyệt động (workflow\_steps)8,3.

• Các cài đặt logic đặc thù cho từng ứng dụng của Tenant3.

4\. Luồng xử lý dữ liệu (Data Flow)

Trong thực tế vận hành, khi một Admin của Tenant thực hiện thay đổi cấu hình (ví dụ sửa Workflow), dữ liệu JSON sẽ được ghi vào MongoDB9. Sau đó, hệ thống có thể sử dụng cơ chế **Change Data Capture (CDC)** qua Kafka để đồng bộ các thay đổi này sang **ClickHouse** nhằm mục đích lưu vết nhật ký thay đổi (Audit Logs) mà không làm chậm cơ sở dữ liệu vận hành chính9,10.

**Tóm lại:** Việc lưu `tenant_app_configs` trong MongoDB giúp hệ thống SaaS của bạn có "bộ khung" linh hoạt, cho phép mỗi khách hàng tự do trang trí và sắp xếp "nội thất" cấu hình mà không làm ảnh hưởng đến kết cấu chịu lực của toàn bộ tòa nhà hệ thống2,11.



thiết kế chi tiết bảng tenant\_app\_configs dùng MongoDB đáp ứng được các phân tích ở trên, dùng UUID v7, kẻ dạng bảng gồm các cột: Tên trường (Field),Kiểu dữ liệu,Null?,Mặc định (Default),Ràng buộc (Constraints) & Logic Kiểm tra, Mô tả viết câu lệnh để tạo bảng và index

Dựa trên triết lý **Polyglot Persistence** và các quy chuẩn kiến trúc SaaS đa khách hàng đã thống nhất trong các nguồn tài liệu, bảng **tenant\_app\_configs** được lưu trữ tại **MongoDB (Tier 1: Document Store)**1,2. Đây là "bộ não linh hoạt" của hệ thống, nơi lưu trữ các cấu hình động, không cấu trúc hoặc có cấu trúc lồng nhau phức tạp tùy thuộc vào sở thích vận hành của từng khách hàng2,3.

Dưới đây là thiết kế chi tiết và các câu lệnh thực thi tối ưu cho MongoDB:

1\. Thiết kế chi tiết bộ sưu tập (Collection) `tenant_app_configs`

Trong MongoDB, một "bảng" được gọi là một "bộ sưu tập" (collection)2. Để đảm bảo khả năng đồng bộ và ánh xạ dữ liệu giữa các cơ sở dữ liệu khác nhau (như YugabyteDB hay ClickHouse), chúng ta thống nhất dùng kiểu dữ liệu **String (UUID v7)** cho khóa chính4,5,6.

| Tên trường (Field) | Kiểu dữ liệu | Null? | Mặc định (Default) | Ràng buộc (Constraints) & Logic Kiểm tra | Mô tả |
| --- | --- | --- | --- | --- | --- |
| **\_id** | String (UUID) | NO  | \-  | Khóa chính, định dạng **UUID v7**4,6 | Định danh duy nhất, hỗ trợ sắp xếp theo thời gian5,6. |
| **tenant\_id** | String (UUID) | NO  | \-  | **Shard Key**, tham chiếu `tenants._id`7,8 | Xác định cấu hình thuộc về khách hàng nào8. |
| **app\_code** | String | NO  | \-  | Duy nhất theo cặp `(tenant_id, app_code)` | Mã định danh ứng dụng (VD: 'HRM', 'CRM', 'POS')8. |
| **configs** | Object (BSON) | NO  | `{}` | Schema-less (Linh hoạt)3 | Chứa các cài đặt động như `theme_color`, `workflow_steps`, logo9,2. |
| **version** | Int64 | NO  | `1` | `version >= 1`10 | Hỗ trợ **Optimistic Locking** để tránh ghi đè dữ liệu10. |
| **created\_at** | Date (ISODate) | NO  | `now()` | Chuẩn UTC11,12 | Thời điểm tạo bản ghi12. |
| **updated\_at** | Date (ISODate) | NO  | `now()` | Chuẩn UTC11,12 | Thời điểm cập nhật cuối cùng12. |

\--------------------------------------------------------------------------------

2\. Câu lệnh tạo Collection và Index trong MongoDB

Mặc dù MongoDB tự động tạo collection khi có dữ liệu chèn vào, nhưng để đảm bảo tính chặt chẽ về mặt kỹ thuật và hiệu năng, chúng ta nên định nghĩa các ràng buộc và chỉ mục (Index) trước.

Câu lệnh tạo Collection với Schema Validation (Ràng buộc dữ liệu)

Việc sử dụng JSON Schema giúp kiểm soát các trường bắt buộc ngay tại tầng cơ sở dữ liệu.

```
db.createCollection("tenant_app_configs", {
   validator: {
      $jsonSchema: {
         bsonType: "object",
         required: ["_id", "tenant_id", "app_code", "configs", "version", "created_at", "updated_at"],
         properties: {
            _id: { bsonType: "string", description: "Must be a UUID v7 string" },
            tenant_id: { bsonType: "string", description: "Must be a UUID string of the tenant" },
            app_code: { bsonType: "string", description: "App code identifier (e.g., HRM, CRM)" },
            configs: { bsonType: "object", description: "Flexible configuration object" },
            version: { bsonType: "long", minimum: 1 },
            created_at: { bsonType: "date" },
            updated_at: { bsonType: "date" }
         }
      }
   }
});
```

Câu lệnh tạo Index (Chỉ mục)

Các chỉ mục này giúp tối ưu hóa việc tra cứu cấu hình cho từng ứng dụng của từng khách hàng và hỗ trợ quá trình đồng bộ dữ liệu (CDC)13,14.

```
// 1. Index duy nhất: Đảm bảo một Tenant chỉ có một bộ cấu hình cho mỗi App
db.tenant_app_configs.createIndex(
    { "tenant_id": 1, "app_code": 1 }, 
    { unique: true, name: "idx_tenant_app_unique" }
);

// 2. Index cho Sharding: Tối ưu hóa việc phân tán dữ liệu theo khách hàng
// Thường sử dụng tenant_id làm Shard Key trong kiến trúc SaaS
db.tenant_app_configs.createIndex({ "tenant_id": 1 });

// 3. Index hỗ trợ CDC/Sync: Tìm kiếm các bản ghi mới cập nhật để đẩy sang ClickHouse
db.tenant_app_configs.createIndex({ "updated_at": -1 });

// 4. Index hỗ trợ tìm kiếm sâu trong JSON (GIN Index tương đương trong Mongo)
// Ví dụ: Tìm các tenant đang cấu hình theme_color là 'blue'
db.tenant_app_configs.createIndex({ "configs.theme_color": 1 }, { sparse: true });
```

3\. Phân tích lợi ích kỹ thuật dựa trên các nguồn

• **Tính linh hoạt tuyệt đối:** Việc sử dụng MongoDB cho bảng này cho phép Tenant A thêm các bước duyệt quy trình (workflow) khác hoàn toàn với Tenant B mà không cần phải thực hiện lệnh `ALTER TABLE` gây khóa hệ thống ở các DB quan hệ truyền thống3.

• **Hiệu năng truy xuất:** Toàn bộ cấu hình của một ứng dụng được lấy ra trong một lần đọc duy nhất (Single Document Read), giúp giảm thiểu việc phải thực hiện các phép JOIN phức tạp3.

• **Khả năng đồng bộ (CDC):** Nhờ việc lưu trữ dưới dạng Document và có trường `updated_at`, các công cụ như Debezium có thể dễ dàng lắng nghe OpLog của MongoDB để đồng bộ các thay đổi cấu hình sang **ClickHouse** phục vụ mục đích truy vết (Audit Logs)15,14.

• **UUID v7 & Tính nhất quán:** Việc dùng UUID v7 làm `_id` giúp dữ liệu có tính thứ tự theo thời gian, tăng hiệu năng ghi và dễ dàng đối soát khi dữ liệu "chảy" qua các lớp DB khác nhau trong hệ thống5,6.

**Sự ví von:** Bảng `tenant_app_configs` giống như một **quyển sổ tay trang trí nội thất** của từng căn hộ trong tòa nhà SaaS. Trong khi khung nhà (Tenants) và hệ thống điện nước (IAM) được cố định ở "két sắt" YugabyteDB, thì quyển sổ tay này cho phép mỗi chủ nhà tự do thay đổi màu sơn, cách bài trí phòng khách mà không làm ảnh hưởng đến kết cấu chung của toàn bộ tòa nhà2,3.
